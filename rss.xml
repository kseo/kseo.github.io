<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Haskell for Pragmatic Programmers</title>
        <link>http://kseo.github.io/</link>
        <description><![CDATA[Kwang Yul Seo's Haskell Blog]]></description>
        <atom:link href="http://kseo.github.io//rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Wed, 01 Jun 2016 00:00:00 UT</lastBuildDate>
        <item>
    <title>Learn Haskell to be a better programmer</title>
    <link>http://kseo.github.io//posts/2016-06-01-learn-haskell-to-be-a-better-programmer.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on June  1, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/category%20theory.html">category theory</a>, <a href="/tags/composition.html">composition</a>
      
  </div>

<p>Haskell is notorious for being hard to learn. Pure functions, lazy evaluation, Haskell type system are just start.</p>
<p>To use Haskell effectively, it is necessary to learn the abstract concepts borrowed from the category theory such as Functor, Applicative Functor and Monad. You need to understand these concepts throughly because most of Haskell code is written using these abstract non-sense.</p>
<p>Of course, it is still possible to write IO code and use <code>Maybe</code>, <code>Either</code> and <code>List</code> types without understanding Monad. But then why do you want to learn Haskell anyway? If you avoid learning these concpets, you can’t learn much from Haskell. It would be much beneficial to learn other more practical languages.</p>
<p>Before explaining why you should learn Haskell, let’s ask a question. What’s the essence of programming?</p>
<p>Programming is basically instructing the computer to some labor. For example, “Load the value at memory x into the register, add 1 to it, and store the value back to the memory” is a program.</p>
<p>But a program is not just a sequence of instructions. It is a solution to our real problem. What makes programming interesting is that the problems we solve as a programmer is much bigger in size than simply loading a value from the memory and doing some arithmetic.</p>
<p>So programming is to divide a big problem that can’t be solved at once into many small problems, solve them independently, and compose the resulting small programs into a program that solves the original problem. In other words, the essence of programming is recomposition after decomposition. See Bartosz Milewski’s <a href="https://bartoszmilewski.com/2014/11/04/category-the-essence-of-composition/">Category: The Essence of Composition</a>.</p>
<p>Here comes the most important property of programming, which is called <em>composability</em>. We need to solve many complex problems which are similar but not exactly same. If we can compose small reusable programs into a new program which solves the new problem, the productivity of a programmer will be dramatically increased.</p>
<p>The changes of programming paradigm in the history can be explained as our continous endeavor to enhance the composability. For example, the shift from assembly programming with goto to structure programming emphasizing subroutine and loop was necessary as the problem size increases. We desparately needed a better way to compose programs.</p>
<p>But as the complexity of problem drastically increased again in 80-90s, we needed a new programming paradigm called object-oriented programming. Classes and objects, encapsulation and information hiding were another endeavor to imporve the composability of programs.</p>
<p>Now in 2010s, functional programming is gaining attention. The complexity of problems we have today is enormous and we need new tools and concepts to cope with ever increasing complexity. Classes are not enough. We need more composability.</p>
<p>Haskell provides new tools and concepts which can help organize code better. Concepts like Functor, Applicative Functor, Monad, Arrow and Lense all provide new means to compose programs. See Gabriel Gonzalez’s <a href="http://www.haskellforall.com/2012/08/the-category-design-pattern.html">The category design pattern</a>.</p>
<p>In fact, you already know some of these concepts. For example, ES6’s Promise, C#’s null propagation operator, Python’s list comprehension all share the same monadic structure. But you probably never noticed the common structure lying behind these different language features. After you learn Haskell, you will begin to see the common structure you’ve never imagined before.</p>
<p>In summary, the essence of programming is <em>composition</em>. Haskell provides new tools and concepts to compose programs. Learning Haskell improves your code organizational skills and make you prepared to handle more complex problems. <a href="http://learnyouahaskell.com/chapters">Learn you a Haskell for great good!</a></p>
</article>
]]></description>
    <pubDate>Wed, 01 Jun 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-06-01-learn-haskell-to-be-a-better-programmer.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Learning Prolog to be a better Haskell programmer</title>
    <link>http://kseo.github.io//posts/2014-02-17-learning-prolog-to-be-a-better-haskell-programmer.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on February 17, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/prolog.html">prolog</a>, <a href="/tags/type-level%20programming.html">type-level programming</a>, <a href="/tags/functional%20dependencies.html">functional dependencies</a>, <a href="/tags/type%20families.html">type families</a>
      
  </div>

<p>While learning some advanced topics of the Haskell type system, I found type level programming is reminiscent of logic programming.</p>
<p>For example, <a href="http://www.cse.chalmers.se/~hallgren/Papers/wm01.html">Fun with Functional Dependencies</a> shows how to implement insertion sort using functional dependencies in a programming style similar to Prolog. <a href="https://wiki.haskell.org/Simonpj/Talk:FunWithTypeFuns">Fun with Type Functions</a> also shows a similar example using type families.</p>
<p>This similarity is not a coincidence because of the correspondence between a logic system and a type system, which is known as <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curry-Howard isomorphism</a>.</p>
<p>Lesson: Learn Prolog to be a better Haskell programmer!</p>
<h2 id="references">References</h2>
<p>There is <a href="https://mail.haskell.org/pipermail/haskell-cafe/2010-June/079412.html">a discussion</a> on the Haskell-cafe.</p>
</article>
]]></description>
    <pubDate>Mon, 17 Feb 2014 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2014-02-17-learning-prolog-to-be-a-better-haskell-programmer.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Data.Map vs Data.IntMap</title>
    <link>http://kseo.github.io//posts/2014-02-12-data-map-vs-data-intmap.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on February 12, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Data.Map.html">Data.Map</a>, <a href="/tags/Data.IntMap.html">Data.IntMap</a>
      
  </div>

<p>A map is the one of most widely used data structures in many applications. Thus, many language runtimes provide an efficient implementation of a map. In a purely functional programming language, map is usually implemented as a balanced binary tree. Haskell is no exception here and the implementation of Haskell’s <code>Data.Map</code> is based on size balanced binary trees described in</p>
<ul>
<li>Stephen Adams, <a href="http://www.swiss.ai.mit.edu/~adams/BB/">“Efficient sets: a balancing act”</a>, Journal of Functional Programming 3(4):553-562, October 1993, .</li>
<li>J. Nievergelt and E.M. Reingold, “Binary search trees of bounded balance”, SIAM journal of computing 2(1), March 1973.</li>
</ul>
<p><code>Data.Map</code> is parameterized over key and value types, so that you can use any type you want as long as key is an instance of <code>Ord</code> type class. So, for example, you can use <code>Int</code> as the key type and store any type you want.</p>
<p>However, Haskell also provides a special version <code>Data.IntMap</code> for <code>Int</code> key. It seems redundant at first, but <code>Data.IntMap</code> is different from <code>Data.Map</code> in that it supports efficient merging of two maps. The implementation of <code>Data.IntMap</code> is described in</p>
<ul>
<li>Chris Okasaki and Andy Gill, <a href="http://citeseer.ist.psu.edu/okasaki98fast.html">“Fast Mergeable Integer Maps”</a>, Workshop on ML, September 1998, pages 77-86,</li>
<li>D.R. Morrison, “/PATRICIA — Practical Algorithm To Retrieve Information Coded In Alphanumeric/”, Journal of the ACM, 15(4), October 1968, pages 514-534.</li>
</ul>
<p>The author of <code>Data.IntMap</code> mentions that insertions and deletions of <code>Data.IntMap</code> when compared to a generic size-balanced map implementation are also much faster. This observation suggests that we should use <code>Data.IntMap</code> whenever possible whether or not we need union or intersection of twp maps.</p>
</article>
]]></description>
    <pubDate>Wed, 12 Feb 2014 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2014-02-12-data-map-vs-data-intmap.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Record wildcards</title>
    <link>http://kseo.github.io//posts/2014-02-10-record-wildcards.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on February 10, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/record%20wildcards.html">record wildcards</a>, <a href="/tags/language%20extension.html">language extension</a>
      
  </div>

<p>Haskell record syntax is a bit verbose. For records with many fields, it is tiresome to write each field individually in a record pattern, as in</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">C</span> <span class="fu">=</span> <span class="dt">C</span> {<span class="ot">a ::</span> <span class="dt">Int</span>,<span class="ot"> b ::</span> <span class="dt">Int</span>,<span class="ot"> c ::</span> <span class="dt">Int</span>,<span class="ot"> d ::</span> <span class="dt">Int</span>}

f (<span class="dt">C</span> {a <span class="fu">=</span> <span class="dv">1</span>, b <span class="fu">=</span> b, c <span class="fu">=</span> c, d <span class="fu">=</span> d}) <span class="fu">=</span> b <span class="fu">+</span> c <span class="fu">+</span> d</code></pre></div>
<p><a href="https://ocharles.org.uk/blog/posts/2014-12-04-record-wildcards.html">Record wildcard syntax</a> lets us use <code>..</code> in a record pattern, which simplifies pattern <code>f=f</code> to <code>f</code>. The above pattern can be rewritten with record wildcards syntax</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f (<span class="dt">C</span> {a <span class="fu">=</span> <span class="dv">1</span>, <span class="fu">..</span>}) <span class="fu">=</span> b <span class="fu">+</span> c <span class="fu">+</span> d</code></pre></div>
<p>This simple example does not show the merit of record wildcards vividly. Let’s see a real world example. <a href="http://hackage.haskell.org/package/hs-java">hs-java</a> is a package written by Ilya V. Portnov, which provides data types for Java .class files format and functions to assemble/disassemble Java bytecode.</p>
<p>The datatype for a JVM class file is <code>Class</code>, which has many fields as in</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Class</span> stage <span class="fu">=</span> <span class="dt">Class</span> {
<span class="ot">  magic ::</span> <span class="dt">Word32</span>,                         <span class="co">-- ^ Magic value: 0xCAFEBABE</span>
<span class="ot">  minorVersion ::</span> <span class="dt">Word16</span>,
<span class="ot">  majorVersion ::</span> <span class="dt">Word16</span>,
<span class="ot">  constsPoolSize ::</span> <span class="dt">Word16</span>,                <span class="co">-- ^ Number of items in constants pool</span>
<span class="ot">  constsPool ::</span> <span class="dt">Pool</span> stage,                <span class="co">-- ^ Constants pool itself</span>
<span class="ot">  accessFlags ::</span> <span class="dt">AccessFlags</span> stage,        <span class="co">-- ^ See @JVM.Types.AccessFlag@</span>
<span class="ot">  thisClass ::</span> <span class="dt">Link</span> stage <span class="dt">B.ByteString</span>,    <span class="co">-- ^ Constants pool item index for this class</span>
<span class="ot">  superClass ::</span> <span class="dt">Link</span> stage <span class="dt">B.ByteString</span>,   <span class="co">-- ^ --/-- for super class, zero for java.lang.Object</span>
<span class="ot">  interfacesCount ::</span> <span class="dt">Word16</span>,               <span class="co">-- ^ Number of implemented interfaces</span>
<span class="ot">  interfaces ::</span> [<span class="dt">Link</span> stage <span class="dt">B.ByteString</span>], <span class="co">-- ^ Constants pool item indexes for implemented interfaces</span>
<span class="ot">  classFieldsCount ::</span> <span class="dt">Word16</span>,              <span class="co">-- ^ Number of class fileds</span>
<span class="ot">  classFields ::</span> [<span class="dt">Field</span> stage],            <span class="co">-- ^ Class fields</span>
<span class="ot">  classMethodsCount ::</span> <span class="dt">Word16</span>,             <span class="co">-- ^ Number of class methods</span>
<span class="ot">  classMethods ::</span> [<span class="dt">Method</span> stage],          <span class="co">-- ^ Class methods</span>
<span class="ot">  classAttributesCount ::</span> <span class="dt">Word16</span>,          <span class="co">-- ^ Number of class attributes</span>
<span class="ot">  classAttributes ::</span> <span class="dt">Attributes</span> stage      <span class="co">-- ^ Class attributes</span>
  }</code></pre></div>
<p>It is declared as an instance of <a href="http://hackage.haskell.org/package/binary-0.7.1.0/docs/Data-Binary.html">Binary</a> class for serialization. Its put method uses the record wildcards syntax not to repeat field names as in the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Binary</span> (<span class="dt">Class</span> <span class="dt">File</span>) <span class="kw">where</span>
  put (<span class="dt">Class</span> {<span class="fu">..</span>}) <span class="fu">=</span> <span class="kw">do</span>
    put magic
    put minorVersion
    put majorVersion
    putPool constsPool
    put accessFlags
    put thisClass
    put superClass
    put interfacesCount
    forM_ interfaces put
    put classFieldsCount
    forM_ classFields put
    put classMethodsCount
    forM_ classMethods put
    put classAttributesCount
    forM_ (attributesList classAttributes) put</code></pre></div>
<p>You can see the real difference by comparing this with a more verbose version which does not use record wildcards.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Binary</span> (<span class="dt">Class</span> <span class="dt">File</span>) <span class="kw">where</span>
  put (<span class="dt">Class</span> {magic<span class="fu">=</span>magic, minorVersion<span class="fu">=</span>minorVersion, majorVersion<span class="fu">=</span>majorVersion, constsPool<span class="fu">=</span>constsPool, accessFlags<span class="fu">=</span>accessFlags, thisCla    ss<span class="fu">=</span>thisClass, superClass<span class="fu">=</span>superClass, interfacesCount<span class="fu">=</span>interfacesCount, interfaces<span class="fu">=</span>interfaces, classFieldsCount<span class="fu">=</span>classFieldsCount, classFie    lds<span class="fu">=</span>classFields, classMethodsCount<span class="fu">=</span>classMethodsCount, classMethods<span class="fu">=</span>classMethods, classAttributesCount<span class="fu">=</span>classAttributesCount, classAttributes<span class="fu">=</span>classAttributes}) <span class="fu">=</span> <span class="kw">do</span>
 <span class="fu">...</span></code></pre></div>
</article>
]]></description>
    <pubDate>Mon, 10 Feb 2014 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2014-02-10-record-wildcards.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Multi-line strings in Haskell</title>
    <link>http://kseo.github.io//posts/2014-02-06-multi-line-strings-in-haskell.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on February  6, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/multi-line%20string.html">multi-line string</a>, <a href="/tags/quasiquotation.html">quasiquotation</a>
      
  </div>

<p>Haskell supports multi-line string literals in several ways.</p>
<h2 id="unlines">unlines</h2>
<p><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:unlines">unlines</a> joins lines, after appending a terminating newline to each.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">multi <span class="fu">=</span> unlines [<span class="st">&quot;line1&quot;</span>, <span class="st">&quot;line2&quot;</span>, <span class="st">&quot;line3&quot;</span>]</code></pre></div>
<h2 id="multi-line-string-literal">Multi-line string literal</h2>
<p>We should escape it using <code>\</code> and then another <code>\</code> where the string starts again.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">multi <span class="fu">=</span> <span class="st">&quot;line1\</span>
<span class="st">\line2\</span>
<span class="st">\line3&quot;</span></code></pre></div>
<h2 id="quasiquotation">Quasiquotation</h2>
<p>The <a href="http://hackage.haskell.org/package/raw-strings-qq">raw-strings-qq</a> package provides a quasiquoter for raw string literals. In addition to supporting multi-line string, it does not recognize escape sequences. So we don’t need to add <code>\</code> as in multi-line string literals. <code>{-# LANGUAGE QuasiQuotes #-}</code> is required to use this feature.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span>
<span class="kw">import </span><span class="dt">Text.RawString.QQ</span>
multi <span class="fu">=</span> [r<span class="fu">|</span>line1
line2
line3<span class="fu">|</span>]</code></pre></div>
<p>I prefer quasiquotation because I use multi-line string literals for HTML/XML fragments and it is laborious to escape all special characters such as quotes.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span>
<span class="kw">import </span><span class="dt">Text.RawString.QQ</span>
 
<span class="ot">multiline ::</span> <span class="dt">String</span>
multiline <span class="fu">=</span> [r<span class="fu">|&lt;</span><span class="dt">HTML</span><span class="fu">&gt;</span>
<span class="fu">&lt;</span><span class="dt">HEAD</span><span class="fu">&gt;</span>
<span class="fu">&lt;</span><span class="dt">TITLE</span><span class="fu">&gt;</span><span class="dt">Auto</span><span class="fu">-</span>generated html formated source<span class="fu">&lt;/</span><span class="dt">TITLE</span><span class="fu">&gt;</span>
<span class="fu">&lt;</span><span class="dt">META</span> <span class="dt">HTTP</span><span class="fu">-</span><span class="dt">EQUIV</span><span class="fu">=</span><span class="st">&quot;Content-Type&quot;</span> <span class="dt">CONTENT</span><span class="fu">=</span><span class="st">&quot;text/html; charset=windows-1252&quot;</span><span class="fu">&gt;</span>
<span class="fu">&lt;/</span><span class="dt">HEAD</span><span class="fu">&gt;</span>
<span class="fu">&lt;</span><span class="dt">BODY</span> <span class="dt">LINK</span><span class="fu">=</span><span class="st">&quot;800080&quot;</span> <span class="dt">BGCOLOR</span><span class="fu">=</span><span class="st">&quot;#ffffff&quot;</span><span class="fu">&gt;</span>
<span class="fu">&lt;</span><span class="dt">P</span><span class="fu">&gt;</span> <span class="fu">&lt;/</span><span class="dt">P</span><span class="fu">&gt;</span>
<span class="fu">&lt;</span><span class="dt">PRE</span><span class="fu">&gt;|</span>]</code></pre></div>
<p>There are other quasi-quote packages such as <a href="http://hackage.haskell.org/package/interpolatedstring-qq">string-qq</a>, <a href="http://hackage.haskell.org/package/string-quote">string-quote</a> and <a href="http://hackage.haskell.org/package/interpolatedstring-qq">interpolatedstring-qq</a>.</p>
</article>
]]></description>
    <pubDate>Thu, 06 Feb 2014 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2014-02-06-multi-line-strings-in-haskell.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Default values of Haskell Types</title>
    <link>http://kseo.github.io//posts/2014-02-06-default-values-of-haskell-types.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on February  6, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/default%20value.html">default value</a>
      
  </div>

<p>Java types have default values. If you don’t explicitly assign a value in a field declaration, it gets its default value of the given type. For example, the default value of <code>int</code> is <code>0</code> and the default value of <code>boolean</code> is <code>false</code>.</p>
<p>On the contrary, Haskell types do not provide default values. This is natural because Haskell does not destructively update a variable initialized with the the default value.</p>
<p>However, it is handy to have a default value in some cases such as a record with many fields. Haskell libraries often provide a default value for such a record for the ease of construction. For example, <a href="http://bscarlet.github.io/llvm-general/3.3.8.2/doc/html/llvm-general-pure/index.html">llvm-general-pure</a> provides <code>defaultModule</code>, which is the default value of <code>Module</code>. The data constructor <code>Module</code> has 4 fields:</p>
<ul>
<li><code>moduleName :: String</code></li>
<li><code>moduleDataLayout :: Maybe DataLayout</code> – a DataLayout, if specified, must match that of the eventual code generator</li>
<li><code>moduleTargetTriple :: Maybe String</code></li>
<li><code>moduleDefinitions :: [Definition]</code></li>
</ul>
<p>Using <code>defaultModule</code>, you don’t need to supply all these fields. You can construct a <code>Module</code> value using Haskell record update syntax as in the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">defaultModule { moduleName<span class="fu">=</span><span class="st">&quot;mymodule&quot;</span> }</code></pre></div>
<p>The <a href="http://hackage.haskell.org/package/data-default">data-default</a> package provides a type class <code>Default</code>, which is useful for this purpose. If a given type is an instance of <code>Default</code>, you can get its default value using <code>def</code> method. Instances are provided for <code>()</code>, <code>Set</code>, <code>Map</code>, <code>Int</code>, <code>Integer</code>, <code>Float</code>, <code>Double</code>, and many others.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span> <span class="dt">Data.Default</span><span class="fu">&gt;</span><span class="ot"> def ::</span> <span class="dt">Int</span>
<span class="dv">0</span>
<span class="dt">Prelude</span> <span class="dt">Data.Default</span><span class="fu">&gt;</span><span class="ot"> def ::</span> [a]
[]
<span class="dt">Prelude</span> <span class="dt">Data.Default</span><span class="fu">&gt;</span><span class="ot"> def ::</span> <span class="dt">Double</span>
<span class="fl">0.0</span></code></pre></div>
</article>
]]></description>
    <pubDate>Thu, 06 Feb 2014 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2014-02-06-default-values-of-haskell-types.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Data.Typeable and Data.Dynamic in Haskell</title>
    <link>http://kseo.github.io//posts/2014-02-03-data-typeable-and-data-dynamic-in-haskell.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on February  3, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Data.Typeable.html">Data.Typeable</a>, <a href="/tags/Data.Dynamic.html">Data.Dynamic</a>, <a href="/tags/dynamic%20typing.html">dynamic typing</a>
      
  </div>

<p><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Typeable.html">Data.Typeable</a> is a way to implement dynamic (delayed) type checking in Haskell using a <a href="http://www.haskell.org/haskellwiki/Heterogenous_collections#A_Universal_type">universal type</a>.</p>
<p>For example, you can implement a heterogenous list in Haskell. <code>toDyn</code> converts any <code>Typeable</code> instance into <code>Dynamic</code> which is similar to Java <code>Object</code> type. Any type that is an instance of <code>Typeable</code> class can be wrapped with <code>Dynamic</code> type.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Dynamic</span>
<span class="kw">import </span><span class="dt">Data.Maybe</span>
 
<span class="ot">hlist ::</span> [<span class="dt">Dynamic</span>]
hlist <span class="fu">=</span> [ toDyn <span class="st">&quot;string&quot;</span>
        , toDyn (<span class="dv">7</span><span class="ot"> ::</span> <span class="dt">Int</span>)
        , toDyn (pi<span class="ot"> ::</span> <span class="dt">Double</span>)
        , toDyn <span class="ch">&#39;x&#39;</span>
        , toDyn ((), <span class="dt">Just</span> <span class="st">&quot;foo&quot;</span>)
        ]
 
<span class="ot">dyn ::</span> <span class="dt">Dynamic</span>
dyn <span class="fu">=</span> hlist <span class="fu">!!</span> <span class="dv">1</span></code></pre></div>
<p>To be precise, <code>hlist</code> is not actually a heterogenous list from the point of Haskell type system. It is just a homogenous list of <code>Dynamic</code>. The chapter 20, “Untyped Means Uni-Typed” of Harper’s textbook also emphasizes this observation: dynamic types (with typeable representations) are statically typed languages with only one type.</p>
<p>You can convert a <code>Dynamic</code> object back into an ordinary Haskell value using <code>fromDynamic</code>. Type checking is dynamic because it is delayed to runtime.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">v ::</span> <span class="dt">Int</span>
v <span class="fu">=</span> <span class="kw">case</span> fromDynamic dyn <span class="kw">of</span>
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;Type mismatch&quot;</span>
        <span class="dt">Just</span> x  <span class="ot">-&gt;</span> x</code></pre></div>
<p>You can make any type <code>Typeable</code> by adding <code>deriving Data.Typeable</code>. In GHC, you need to turn on <code>-XDeriveDataTypeable</code> option to make GHC automatically derive the instance for you.</p>
<p>The <code>Data.Typeable</code> class is used primarily for generic programming in the “Scrap Your Boilerplate (SYB)” style. I will write more on this later.</p>
<h2 id="references">References</h2>
<ul>
<li>Martín Abadi, Luca Cardelli, Benjamin Pierce and Gordon Plotkin, “<a href="http://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-47.pdf">Dynamic Typing in a Statically Typed Language</a>”, ACM Transactions on Programming Languages and Systems (TOPLAS), 1991.</li>
<li>James Cheney and Ralf Hinze, “<a href="https://www.cs.ox.ac.uk/people/ralf.hinze/publications/HW02.pdf">A lightweight implementation of generics and dynamics</a>”, Haskell ’02: Proceedings of the 2002 ACM SIGPLAN Workshop on Haskell, 2002.</li>
<li>Lammel, Ralf and Jones, Simon Peyton, “<a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/hmap.ps">Scrap your boilerplate: a practical design pattern for generic programming</a>”, TLDI ’03: Proceedings of the 2003 ACM SIGPLAN International Workshop on Types in Languages Design and Implementation, 2003</li>
<li>Harper, 2011, Practical Foundations for Programming Languages.</li>
</ul>
</article>
]]></description>
    <pubDate>Mon, 03 Feb 2014 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2014-02-03-data-typeable-and-data-dynamic-in-haskell.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Implementing Union-Find algorithms in Haskell</title>
    <link>http://kseo.github.io//posts/2014-01-30-implementing-union-find-in-haskell.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on January 30, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/ST%20monad.html">ST monad</a>, <a href="/tags/union%20find.html">union find</a>
      
  </div>

<p>The union/find algorithm makes critical use of updatable states. Its efficiency relies on the set representations being simplified each time the structure is examined. Purely functional languages, which lack updatable states seem inherently inefficient to implement the algorithm.</p>
<p>Fortunately, we can implement the algorithm efficiently in Haskell with the help of <code>ST</code> monad which provides support for strict state threads. It is described in the PLDI ’94 paper by John Launchbury and Simon Peyton Jones <a href="http://research.microsoft.com/~simonpj/Papers/lazy-functional-state-threads.ps.Z">Lazy Functional State Threads</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">UnionFind</span> s <span class="fu">=</span> <span class="dt">UnionFind</span> {
<span class="ot">    ids::</span> <span class="dt">STUArray</span> s <span class="dt">Int</span> <span class="dt">Int</span>
  ,<span class="ot"> szs::</span> <span class="dt">STUArray</span> s <span class="dt">Int</span> <span class="dt">Int</span>
  }
 
<span class="ot">newUnionFind ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">UnionFind</span> s)
newUnionFind n <span class="fu">=</span> liftM2 <span class="dt">UnionFind</span> (newListArray (<span class="dv">0</span>, n<span class="fu">-</span><span class="dv">1</span>) [<span class="dv">0</span><span class="fu">..</span>n<span class="fu">-</span><span class="dv">1</span>]) (newArray (<span class="dv">0</span>, n<span class="fu">-</span><span class="dv">1</span>) <span class="dv">1</span>)
 
<span class="ot">find ::</span> (<span class="dt">UnionFind</span> s) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Bool</span>
find uf p q <span class="fu">=</span> liftM2 (<span class="fu">==</span>) (root uf p) (root uf q)
 
<span class="ot">root ::</span> (<span class="dt">UnionFind</span> s) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s <span class="dt">Int</span>
root uf i <span class="fu">=</span> <span class="kw">do</span>
    id <span class="ot">&lt;-</span> readArray (ids uf) i
    <span class="kw">if</span> (id <span class="fu">/=</span> i)
        <span class="kw">then</span> <span class="kw">do</span>
            gpid <span class="ot">&lt;-</span> readArray (ids uf) id
            writeArray (ids uf) i gpid
            root uf id
        <span class="kw">else</span> return i
 
<span class="ot">unite ::</span> (<span class="dt">UnionFind</span> s) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()
unite uf p q <span class="fu">=</span> <span class="kw">do</span>
    i <span class="ot">&lt;-</span> root uf p
    j <span class="ot">&lt;-</span> root uf q
    szi <span class="ot">&lt;-</span> readArray (szs uf) i
    szj <span class="ot">&lt;-</span> readArray (szs uf) j
    <span class="kw">if</span> (szi <span class="fu">&lt;</span> szj)
        <span class="kw">then</span> <span class="kw">do</span>
            writeArray (ids uf) i j
            writeArray (szs uf) j (szi <span class="fu">+</span> szj)
        <span class="kw">else</span> <span class="kw">do</span>
            writeArray (ids uf) j i
            writeArray (szs uf) i (szj <span class="fu">+</span> szi)</code></pre></div>
<p>The code above implements the weighted quick-union with path compression specified in <a href="http://www.cs.princeton.edu/~rs/AlgsDS07/01UnionFind.pdf">Union-Find Algorithms</a>. You can see that the code is almost the same to the Java code. Because <a href="http://www.haskell.org/haskellwiki/Monad/ST">ST monad</a> uses mutable memory internally, the behavior is also the same to that of imperative languages.</p>
<p>You can run the code with <code>runST</code> function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">main <span class="fu">=</span> print <span class="fu">$</span> runST <span class="fu">$</span> <span class="kw">do</span>
    uf <span class="ot">&lt;-</span> newUnionFind <span class="dv">10</span>
    unite uf <span class="dv">3</span> <span class="dv">4</span> <span class="co">-- 0, 1, 2, {3, 4}, 5, 6, 7, 8, 9</span>
    unite uf <span class="dv">4</span> <span class="dv">9</span> <span class="co">-- 0, 1, 2, {3, 4, 9}, 5, 6, 7, 8</span>
    unite uf <span class="dv">8</span> <span class="dv">0</span> <span class="co">-- {0, 8}, 1, 2, {3, 4, 9}, 5, 6, 7, 8</span>
    unite uf <span class="dv">2</span> <span class="dv">3</span> <span class="co">-- {0, 8}, 1, {2, 3, 4, 9}, 5, 6, 7</span>
    unite uf <span class="dv">5</span> <span class="dv">6</span> <span class="co">-- {0, 8}, 1, {2, 3, 4, 9}, {5, 6}, 7</span>
    unite uf <span class="dv">5</span> <span class="dv">9</span> <span class="co">-- {0, 8}, 1, {2, 3, 4, 5, 6, 9}, 7</span>
    unite uf <span class="dv">7</span> <span class="dv">3</span> <span class="co">-- {0, 8}, 1, {2, 3, 4, 5, 6, 7, 9}</span>
    unite uf <span class="dv">4</span> <span class="dv">8</span> <span class="co">-- 1, {0, 2, 3, 4, 5, 6, 7, 8, 9}</span>
    find uf <span class="dv">1</span> <span class="dv">2</span> <span class="co">-- False</span></code></pre></div>
<p>The complete source code is <a href="https://gist.github.com/kseo/8693028">here</a>.</p>
</article>
]]></description>
    <pubDate>Thu, 30 Jan 2014 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2014-01-30-implementing-union-find-in-haskell.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Switching from monads to applicative functors</title>
    <link>http://kseo.github.io//posts/2014-01-26-swtiching-from-monads-to-applicative-functors.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on January 26, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/monad.html">monad</a>, <a href="/tags/applicative%20functor.html">applicative functor</a>
      
  </div>

<p>Many applications of monads actually do not require monads but only applicative functors. Monads allow us to run actions depending on the results of earlier actions, but not all applications of monads need this extended functionality.</p>
<p>It is better to use applicative functors where possible because there are some advantages of applicative functors. <a href="http://www.haskell.org/haskellwiki/Applicative_functor#Some_advantages_of_applicative_functors">Applicative functor on the Haskell Wiki</a> mentions two:</p>
<ul>
<li><p>Code that uses only on the <code>Applicative</code> interface are more general than ones uses the <code>Monad</code> interface, because there are more applicative functors than monads. The <code>ZipList</code> is an applicative functor on lists, where <code>liftA2</code> is implemented by <code>zipWith</code>. It is a typical example of an applicative functor that is not a monad.</p></li>
<li><p>Programming with <code>Applicative</code> has a more applicative/functional feel. Especially for newbies, it may encourage functional style even when programming with effects. <code>Monad</code> programming with do notation encourages a more sequential &amp; imperative style.</p></li>
</ul>
<p>There is another advantage. Applicative functors do not need special transformers because they can be combined in a generic way.</p>
<p>But there is a problem. It is usually not easy to decide if we need monads or applicative functors up front. You ambitiously start with applicative functors and find later that you actually needed monads. Sad!</p>
<p>Here is my tip. I start with monads but use only <code>return</code>, <code>ap</code>, <code>liftM</code>, <code>liftM2</code>, … instead of <code>do</code>, <code>&gt;&gt;=</code>. The most common pattern is</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">do</span> x <span class="ot">&lt;-</span> fx
   y <span class="ot">&lt;-</span> fy
   return (g x y)</code></pre></div>
<p>This can be rewritten as <code>liftM2 g fx fy</code>. Once you are sure that you need only those monad methods, you can mechanically switch from monads to applicative functors using the following translation table:</p>
<ul>
<li><code>import Control.Monad</code> -&gt; <code>import Control.Applicative</code></li>
<li><code>return</code> -&gt; <code>pure</code></li>
<li><code>ap</code> -&gt; -&gt; <code>(&lt;*&gt;)</code></li>
<li><code>liftM</code> -&gt; <code>liftA</code> or <code>(&lt;$&gt;)</code></li>
<li><code>liftM2</code> -&gt; <code>liftA2</code></li>
<li><code>(Monad m =&gt;)</code> -&gt; <code>(Applicative f =&gt;)</code></li>
</ul>
</article>
]]></description>
    <pubDate>Sun, 26 Jan 2014 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2014-01-26-swtiching-from-monads-to-applicative-functors.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Type Checking with Phantom Type</title>
    <link>http://kseo.github.io//posts/2014-01-20-type-checking-with-phantom-type.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on January 20, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/phantom%20type.html">phantom type</a>, <a href="/tags/empty%20type.html">empty type</a>
      
  </div>

<p>In a toy programming language compiler I’ve written recently, the AST for <code>Program</code> has a type variable <code>a</code> which is not used on the right-hand side of its definition.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Program</span> a <span class="fu">=</span>
    <span class="dt">PDefs</span> [<span class="dt">Def</span>]
    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</code></pre></div>
<p>Here <code>Program</code> is a <a href="http://www.haskell.org/haskellwiki/Phantom_type">phantom type</a> because the type parameter <code>a</code> does not appear after the <code>=</code> sign.</p>
<p>But why do we need a type variable if it won’t be used anyway? You can see the hint from the type signature of the type checker:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">check ::</span> (<span class="dt">Program</span> <span class="dt">NoTypeAnnotation</span>) <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">TypeError</span> (<span class="dt">Program</span> <span class="dt">TypeAnnotation</span>)</code></pre></div>
<p>Once a program passes type checking, its type changes from <code>Program NoTypeAnnotation</code> to <code>Program TypeAnnotation</code>. A type variable <code>a</code> is used to differentiate a program with and without type annotations.</p>
<p>Later compiler phases explicitly require its argument type to be <code>Program TypeAnnotation</code>, so I can’t accidentally pass a program which hasn’t been type-checked yet. For example, <code>desugarProgram</code> requires its argument to be of type <code>Program TypeAnnotation</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">desugarProgram ::</span> <span class="dt">Program</span> <span class="dt">TypeAnnotation</span> <span class="ot">-&gt;</span> <span class="dt">ProgramC</span></code></pre></div>
<p><code>NoTypeAnnotation</code> and <code>TypeAnnotation</code> are declared as <a href="https://wiki.haskell.org/Empty_type">empty type</a>s because their values are never needed. <a href="https://prime.haskell.org/wiki/EmptyDataDecls">EmptyDataDecls</a> language extension allows us to not specify any constructors as in the following:</p>
<pre><code>data NoTypeAnnotation
data TypeAnnotation</code></pre>
</article>
]]></description>
    <pubDate>Mon, 20 Jan 2014 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2014-01-20-type-checking-with-phantom-type.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>

    </channel>
</rss>
