<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Haskell for Pragmatic Programmers</title>
        <link>http://kseo.github.io/</link>
        <description><![CDATA[Kwang Yul Seo's Haskell Blog]]></description>
        <atom:link href="http://kseo.github.io//rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Tue, 14 Jun 2016 00:00:00 UT</lastBuildDate>
        <item>
    <title>Objects versus Abstract Data Types</title>
    <link>http://kseo.github.io//posts/2016-06-14-objects-vs-abstract-data-types.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on June 14, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/objects.html">objects</a>, <a href="/tags/abstract%20data%20types.html">abstract data types</a>
      
  </div>

<p>William R. Cook’s essay titled <a href="http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf">On Understanding Data Abstraction, Revisited</a> explains the differences between two forms of data abstraction, <em>objects</em> and <em>abstract data types</em>. His another paper, <a href="https://www.cs.utexas.edu/users/wcook/papers/OOPvsADT/CookOOPvsADT90.pdf">Object-Oriented Programming Versus Abstract Data Types</a> shows why distinguishing these two data abstractions are important:</p>
<blockquote>
<p>Object-oriented programming and abstract data types can also be viewed as complementary implementation techniques: objects are centered around the constructors of a data abstraction, while abstract data types are organized around the operations. These differences have consequences relating to extensibility, efficiency, typing, and verification; in many cases the strengths of one paradigm are the weaknesses of the other. Most object-oriented programming languages support aspects of both techniques, not a unification of them, so an understanding of their relative merits is useful in designing programs.</p>
</blockquote>
<p>Haskell type classes are also discussed in Cook’s essay. He described Haskell type classes as a powerful mechanism for parameterization and extensibility because type classes are unique in that they have properties of both objects and abstract data types:</p>
<ul>
<li>Type classes do not allow different instances to interoperate, but they allow multiple type class instances within a single program.</li>
<li>Type classes are similar to object interfaces in allowing a method to operate on any value that has the necessary operations.</li>
<li>Type classes are based on algebraic signatures as in abstract data types, but they do not enforce any hiding of representations.</li>
</ul>
</article>
]]></description>
    <pubDate>Tue, 14 Jun 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-06-14-objects-vs-abstract-data-types.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Learn Haskell to be a better programmer</title>
    <link>http://kseo.github.io//posts/2016-06-01-learn-haskell-to-be-a-better-programmer.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on June  1, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/category%20theory.html">category theory</a>, <a href="/tags/composition.html">composition</a>
      
  </div>

<p>Haskell is notorious for being hard to learn. Pure functions, lazy evaluation, Haskell type system are just start.</p>
<p>To use Haskell effectively, it is necessary to learn the abstract concepts borrowed from the category theory such as Functor, Applicative Functor and Monad. You need to understand these concepts throughly because most of Haskell code is written using these abstract non-sense.</p>
<p>Of course, it is still possible to write IO code and use <code>Maybe</code>, <code>Either</code> and <code>List</code> types without understanding Monad. But then why do you want to learn Haskell anyway? If you avoid learning these concpets, you can’t learn much from Haskell. It would be much beneficial to learn other more practical languages.</p>
<p>Before explaining why you should learn Haskell, let’s ask a question. What’s the essence of programming?</p>
<p>Programming is basically instructing the computer to some labor. For example, “Load the value at memory x into the register, add 1 to it, and store the value back to the memory” is a program.</p>
<p>But a program is not just a sequence of instructions. It is a solution to our real problem. What makes programming interesting is that the problems we solve as a programmer is much bigger in size than simply loading a value from the memory and doing some arithmetic.</p>
<p>So programming is to divide a big problem that can’t be solved at once into many small problems, solve them independently, and compose the resulting small programs into a program that solves the original problem. In other words, the essence of programming is recomposition after decomposition. See Bartosz Milewski’s <a href="https://bartoszmilewski.com/2014/11/04/category-the-essence-of-composition/">Category: The Essence of Composition</a>.</p>
<p>Here comes the most important property of programming, which is called <em>composability</em>. We need to solve many complex problems which are similar but not exactly same. If we can compose small reusable programs into a new program which solves the new problem, the productivity of a programmer will be dramatically increased.</p>
<p>The changes of programming paradigm in the history can be explained as our continous endeavor to enhance the composability. For example, the shift from assembly programming with goto to structure programming emphasizing subroutine and loop was necessary as the problem size increases. We desparately needed a better way to compose programs.</p>
<p>But as the complexity of problem drastically increased again in 80-90s, we needed a new programming paradigm called object-oriented programming. Classes and objects, encapsulation and information hiding were another endeavor to imporve the composability of programs.</p>
<p>Now in 2010s, functional programming is gaining attention. The complexity of problems we have today is enormous and we need new tools and concepts to cope with ever increasing complexity. Classes are not enough. We need more composability.</p>
<p>Haskell provides new tools and concepts which can help organize code better. Concepts like Functor, Applicative Functor, Monad, Arrow and Lense all provide new means to compose programs. See Gabriel Gonzalez’s <a href="http://www.haskellforall.com/2012/08/the-category-design-pattern.html">The category design pattern</a>.</p>
<p>In fact, you already know some of these concepts. For example, ES6’s Promise, C#’s null propagation operator, Python’s list comprehension all share the same monadic structure. But you probably never noticed the common structure lying behind these different language features. After you learn Haskell, you will begin to see the common structure you’ve never imagined before.</p>
<p>In summary, the essence of programming is <em>composition</em>. Haskell provides new tools and concepts to compose programs. Learning Haskell improves your code organizational skills and make you prepared to handle more complex problems. <a href="http://learnyouahaskell.com/chapters">Learn you a Haskell for great good!</a></p>
</article>
]]></description>
    <pubDate>Wed, 01 Jun 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-06-01-learn-haskell-to-be-a-better-programmer.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Fay + Node.js</title>
    <link>http://kseo.github.io//posts/2014-03-11-fay-with-nodejs.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on March 11, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Fay.html">Fay</a>, <a href="/tags/node.js.html">node.js</a>
      
  </div>

<p><a href="https://github.com/faylang/fay">Fay</a> is a proper subset of Haskell that compiles to JavaScript. Thus it is by definition a statically typed lazy pure functional language. If you want a more thorough introduction to Fay, please read Paul Callaghan’s <a href="https://pragprog.com/magazines/2012-12/web-programming-in-haskell">Web Programming in Haskell</a> and <a href="https://ocharles.org.uk/blog/posts/2013-12-23-24-days-of-hackage-fay.html">Oliver Charles’s 24 Days of Hackage: fay</a>.</p>
<p>The original intention of Fay is to use Haskell on the client side. If you use a Haskell web framework such as Yesod or Snap, using Fay you can use the same language on both client and server sides and some code can actually be shared.</p>
<p>However, because Fay is simply a subset of Haskell that compiles to JavaScript with no dependencies on the client side, you can use it on the server side too in combination with Node.js. I am not saying it is actually a good idea to write server code in Fay, but it is at least fun to investigate the feasibility. Here is <a href="https://gist.github.com/kseo/9477930">a web server example</a> written in Fay.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE EmptyDataDecls #-}</span>
<span class="kw">module</span> <span class="dt">Hello</span> <span class="kw">where</span></code></pre></div>
<p><code>EmptyDataDecls</code> is required because JavaScript types are represented by empty data declarations in Fay.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">FFI</span></code></pre></div>
<p>FFI module provides a foreign function interface.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Http</span>
<span class="kw">data</span> <span class="dt">HttpServer</span>
<span class="kw">data</span> <span class="dt">Request</span>
<span class="kw">data</span> <span class="dt">Response</span></code></pre></div>
<p><code>Http</code>, <code>HttpServer</code>, <code>Request</code> and <code>Response</code> are JavaScript types we use in this example. They are represented by empty data declarations.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">requireHttp ::</span> <span class="dt">Fay</span> <span class="dt">Http</span>
requireHttp <span class="fu">=</span> ffi <span class="st">&quot;require(&#39;http&#39;)&quot;</span></code></pre></div>
<p>This is a simple example of a FFI declaration. It returns the result of <code>require('http')</code> as a <code>Http</code> instance. Fay is a monad which is similar to IO monad. Because a FFI function often has side effects, Fay monad is used to represent this.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">createServer ::</span> <span class="dt">Http</span> <span class="ot">-&gt;</span> (<span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()) <span class="ot">-&gt;</span> <span class="dt">Fay</span> <span class="dt">HttpServer</span>
createServer <span class="fu">=</span> ffi <span class="st">&quot;%1.createServer(%2)&quot;</span>
 
<span class="ot">consoleLog ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()
consoleLog <span class="fu">=</span> ffi <span class="st">&quot;console.log(%1)&quot;</span>
 
<span class="ot">listen ::</span> <span class="dt">HttpServer</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()
listen <span class="fu">=</span> ffi <span class="st">&quot;%1.listen(%2, %3)&quot;</span>
  
<span class="ot">writeHead ::</span> <span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()
writeHead <span class="fu">=</span> ffi <span class="st">&quot;%1.writeHead(%2, %3)&quot;</span>
  
<span class="ot">end ::</span> <span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()
end <span class="fu">=</span> ffi <span class="st">&quot;%1.end(%2)&quot;</span></code></pre></div>
<p>These FFI declarations use <code>%1</code>, <code>%2</code> that corresponds to the arguments we specify in the type. Most Fay types are automatically serialized and deserialized. Note that we can only use point free style in FFI functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">Fay</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  http <span class="ot">&lt;-</span> requireHttp
  server <span class="ot">&lt;-</span> createServer http (\req res <span class="ot">-&gt;</span> <span class="kw">do</span>
    writeHead res <span class="dv">200</span> <span class="st">&quot;{ &#39;Content-Type&#39;: &#39;text/plain&#39; }&quot;</span>
    end res <span class="st">&quot;Hello World\n&quot;</span>
    )
  listen server <span class="dv">1337</span> <span class="st">&quot;127.0.0.1&quot;</span>
  consoleLog <span class="st">&quot;Server running at http://127.0.0.1:1337/&quot;</span></code></pre></div>
<p><code>main</code> is the entry point to our web server example. Its return type is <code>Fay ()</code> because a Fay program can’t do anything without interacting with the world outside. Because we already wrapped all the Node.js APIs we use, we can program as if we write a normal Haskell program.</p>
<p>Compare our Fay web server program with the original Node.js program. Except for the FFI bindings, the main code is almost the same as before. However, our version is much more type-safe!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">var http <span class="fu">=</span> require(<span class="ch">&#39;http&#39;</span>);
http<span class="fu">.</span>createServer(function (req, res) {
  res<span class="fu">.</span>writeHead(<span class="dv">200</span>, {<span class="ch">&#39;Content-Type&#39;</span><span class="fu">:</span> <span class="ch">&#39;text/plain&#39;</span>});
  res<span class="fu">.</span>end(<span class="ch">&#39;Hello World\n&#39;</span>);
})<span class="fu">.</span>listen(<span class="dv">1337</span>, <span class="ch">&#39;127.0.0.1&#39;</span>);
console<span class="fu">.</span>log(<span class="ch">&#39;Server running at http://127.0.0.1:1337/&#39;</span>);</code></pre></div>
</article>
]]></description>
    <pubDate>Tue, 11 Mar 2014 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2014-03-11-fay-with-nodejs.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Evaluation Strategy: Haskell vs Scala</title>
    <link>http://kseo.github.io//posts/2014-03-02-evaluation-strategy-haskell-vs-scala.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on March  2, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Scala.html">Scala</a>, <a href="/tags/evaluation%20strategy.html">evaluation strategy</a>
      
  </div>

<p>Haskell is a non-strict language, and GHC uses a strategy called laziness which combines non-strictness and sharing for efficiency.</p>
<p>Thus, you can easily implement <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:const">const</a> which never uses the second argument.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">const x y <span class="fu">=</span> x</code></pre></div>
<p>With this definition, it is okay to pass <code>undefined</code> as the second argument of <code>const</code> because <code>y</code> is not never evaluated. But in Haskell, you can also make an argument strict using the <a href="https://ocharles.org.uk/blog/posts/2014-12-05-bang-patterns.html">BangPatterns GHC extension</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">const x <span class="fu">!</span>y <span class="fu">=</span> x</code></pre></div>
<p>Interestingly, the situation is reversed in Scala whose default evaluation strategy is strict.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">const</span>(x: Int, y:Int) = x</code></pre></div>
<p>You can make an argument non-strict by putting the <code>=&gt;</code> symbol between the variable name and the type.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">const</span>(x: Int, y: =&gt; Int) = x</code></pre></div>
</article>
]]></description>
    <pubDate>Sun, 02 Mar 2014 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2014-03-02-evaluation-strategy-haskell-vs-scala.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Learning Prolog to be a better Haskell programmer</title>
    <link>http://kseo.github.io//posts/2014-02-17-learning-prolog-to-be-a-better-haskell-programmer.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on February 17, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/prolog.html">prolog</a>, <a href="/tags/type-level%20programming.html">type-level programming</a>, <a href="/tags/functional%20dependencies.html">functional dependencies</a>, <a href="/tags/type%20families.html">type families</a>
      
  </div>

<p>While learning some advanced topics of the Haskell type system, I found type level programming is reminiscent of logic programming.</p>
<p>For example, <a href="http://www.cse.chalmers.se/~hallgren/Papers/wm01.html">Fun with Functional Dependencies</a> shows how to implement insertion sort using functional dependencies in a programming style similar to Prolog. <a href="https://wiki.haskell.org/Simonpj/Talk:FunWithTypeFuns">Fun with Type Functions</a> also shows a similar example using type families.</p>
<p>This similarity is not a coincidence because of the correspondence between a logic system and a type system, which is known as <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curry-Howard isomorphism</a>.</p>
<p>Lesson: Learn Prolog to be a better Haskell programmer!</p>
<h2 id="references">References</h2>
<p>There is <a href="https://mail.haskell.org/pipermail/haskell-cafe/2010-June/079412.html">a discussion</a> on the Haskell-cafe.</p>
</article>
]]></description>
    <pubDate>Mon, 17 Feb 2014 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2014-02-17-learning-prolog-to-be-a-better-haskell-programmer.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Data.Map vs Data.IntMap</title>
    <link>http://kseo.github.io//posts/2014-02-12-data-map-vs-data-intmap.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on February 12, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Data.Map.html">Data.Map</a>, <a href="/tags/Data.IntMap.html">Data.IntMap</a>
      
  </div>

<p>A map is the one of most widely used data structures in many applications. Thus, many language runtimes provide an efficient implementation of a map. In a purely functional programming language, map is usually implemented as a balanced binary tree. Haskell is no exception here and the implementation of Haskell’s <code>Data.Map</code> is based on size balanced binary trees described in</p>
<ul>
<li>Stephen Adams, <a href="http://www.swiss.ai.mit.edu/~adams/BB/">“Efficient sets: a balancing act”</a>, Journal of Functional Programming 3(4):553-562, October 1993, .</li>
<li>J. Nievergelt and E.M. Reingold, “Binary search trees of bounded balance”, SIAM journal of computing 2(1), March 1973.</li>
</ul>
<p><code>Data.Map</code> is parameterized over key and value types, so that you can use any type you want as long as key is an instance of <code>Ord</code> type class. So, for example, you can use <code>Int</code> as the key type and store any type you want.</p>
<p>However, Haskell also provides a special version <code>Data.IntMap</code> for <code>Int</code> key. It seems redundant at first, but <code>Data.IntMap</code> is different from <code>Data.Map</code> in that it supports efficient merging of two maps. The implementation of <code>Data.IntMap</code> is described in</p>
<ul>
<li>Chris Okasaki and Andy Gill, <a href="http://citeseer.ist.psu.edu/okasaki98fast.html">“Fast Mergeable Integer Maps”</a>, Workshop on ML, September 1998, pages 77-86,</li>
<li>D.R. Morrison, “/PATRICIA — Practical Algorithm To Retrieve Information Coded In Alphanumeric/”, Journal of the ACM, 15(4), October 1968, pages 514-534.</li>
</ul>
<p>The author of <code>Data.IntMap</code> mentions that insertions and deletions of <code>Data.IntMap</code> when compared to a generic size-balanced map implementation are also much faster. This observation suggests that we should use <code>Data.IntMap</code> whenever possible whether or not we need union or intersection of twp maps.</p>
</article>
]]></description>
    <pubDate>Wed, 12 Feb 2014 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2014-02-12-data-map-vs-data-intmap.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Record wildcards</title>
    <link>http://kseo.github.io//posts/2014-02-10-record-wildcards.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on February 10, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/record%20wildcards.html">record wildcards</a>, <a href="/tags/language%20extension.html">language extension</a>
      
  </div>

<p>Haskell record syntax is a bit verbose. For records with many fields, it is tiresome to write each field individually in a record pattern, as in</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">C</span> <span class="fu">=</span> <span class="dt">C</span> {<span class="ot">a ::</span> <span class="dt">Int</span>,<span class="ot"> b ::</span> <span class="dt">Int</span>,<span class="ot"> c ::</span> <span class="dt">Int</span>,<span class="ot"> d ::</span> <span class="dt">Int</span>}

f (<span class="dt">C</span> {a <span class="fu">=</span> <span class="dv">1</span>, b <span class="fu">=</span> b, c <span class="fu">=</span> c, d <span class="fu">=</span> d}) <span class="fu">=</span> b <span class="fu">+</span> c <span class="fu">+</span> d</code></pre></div>
<p><a href="https://ocharles.org.uk/blog/posts/2014-12-04-record-wildcards.html">Record wildcard syntax</a> lets us use <code>..</code> in a record pattern, which simplifies pattern <code>f=f</code> to <code>f</code>. The above pattern can be rewritten with record wildcards syntax</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f (<span class="dt">C</span> {a <span class="fu">=</span> <span class="dv">1</span>, <span class="fu">..</span>}) <span class="fu">=</span> b <span class="fu">+</span> c <span class="fu">+</span> d</code></pre></div>
<p>This simple example does not show the merit of record wildcards vividly. Let’s see a real world example. <a href="http://hackage.haskell.org/package/hs-java">hs-java</a> is a package written by Ilya V. Portnov, which provides data types for Java .class files format and functions to assemble/disassemble Java bytecode.</p>
<p>The datatype for a JVM class file is <code>Class</code>, which has many fields as in</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Class</span> stage <span class="fu">=</span> <span class="dt">Class</span> {
<span class="ot">  magic ::</span> <span class="dt">Word32</span>,                         <span class="co">-- ^ Magic value: 0xCAFEBABE</span>
<span class="ot">  minorVersion ::</span> <span class="dt">Word16</span>,
<span class="ot">  majorVersion ::</span> <span class="dt">Word16</span>,
<span class="ot">  constsPoolSize ::</span> <span class="dt">Word16</span>,                <span class="co">-- ^ Number of items in constants pool</span>
<span class="ot">  constsPool ::</span> <span class="dt">Pool</span> stage,                <span class="co">-- ^ Constants pool itself</span>
<span class="ot">  accessFlags ::</span> <span class="dt">AccessFlags</span> stage,        <span class="co">-- ^ See @JVM.Types.AccessFlag@</span>
<span class="ot">  thisClass ::</span> <span class="dt">Link</span> stage <span class="dt">B.ByteString</span>,    <span class="co">-- ^ Constants pool item index for this class</span>
<span class="ot">  superClass ::</span> <span class="dt">Link</span> stage <span class="dt">B.ByteString</span>,   <span class="co">-- ^ --/-- for super class, zero for java.lang.Object</span>
<span class="ot">  interfacesCount ::</span> <span class="dt">Word16</span>,               <span class="co">-- ^ Number of implemented interfaces</span>
<span class="ot">  interfaces ::</span> [<span class="dt">Link</span> stage <span class="dt">B.ByteString</span>], <span class="co">-- ^ Constants pool item indexes for implemented interfaces</span>
<span class="ot">  classFieldsCount ::</span> <span class="dt">Word16</span>,              <span class="co">-- ^ Number of class fileds</span>
<span class="ot">  classFields ::</span> [<span class="dt">Field</span> stage],            <span class="co">-- ^ Class fields</span>
<span class="ot">  classMethodsCount ::</span> <span class="dt">Word16</span>,             <span class="co">-- ^ Number of class methods</span>
<span class="ot">  classMethods ::</span> [<span class="dt">Method</span> stage],          <span class="co">-- ^ Class methods</span>
<span class="ot">  classAttributesCount ::</span> <span class="dt">Word16</span>,          <span class="co">-- ^ Number of class attributes</span>
<span class="ot">  classAttributes ::</span> <span class="dt">Attributes</span> stage      <span class="co">-- ^ Class attributes</span>
  }</code></pre></div>
<p>It is declared as an instance of <a href="http://hackage.haskell.org/package/binary-0.7.1.0/docs/Data-Binary.html">Binary</a> class for serialization. Its put method uses the record wildcards syntax not to repeat field names as in the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Binary</span> (<span class="dt">Class</span> <span class="dt">File</span>) <span class="kw">where</span>
  put (<span class="dt">Class</span> {<span class="fu">..</span>}) <span class="fu">=</span> <span class="kw">do</span>
    put magic
    put minorVersion
    put majorVersion
    putPool constsPool
    put accessFlags
    put thisClass
    put superClass
    put interfacesCount
    forM_ interfaces put
    put classFieldsCount
    forM_ classFields put
    put classMethodsCount
    forM_ classMethods put
    put classAttributesCount
    forM_ (attributesList classAttributes) put</code></pre></div>
<p>You can see the real difference by comparing this with a more verbose version which does not use record wildcards.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Binary</span> (<span class="dt">Class</span> <span class="dt">File</span>) <span class="kw">where</span>
  put (<span class="dt">Class</span> {magic<span class="fu">=</span>magic, minorVersion<span class="fu">=</span>minorVersion, majorVersion<span class="fu">=</span>majorVersion, constsPool<span class="fu">=</span>constsPool, accessFlags<span class="fu">=</span>accessFlags, thisCla    ss<span class="fu">=</span>thisClass, superClass<span class="fu">=</span>superClass, interfacesCount<span class="fu">=</span>interfacesCount, interfaces<span class="fu">=</span>interfaces, classFieldsCount<span class="fu">=</span>classFieldsCount, classFie    lds<span class="fu">=</span>classFields, classMethodsCount<span class="fu">=</span>classMethodsCount, classMethods<span class="fu">=</span>classMethods, classAttributesCount<span class="fu">=</span>classAttributesCount, classAttributes<span class="fu">=</span>classAttributes}) <span class="fu">=</span> <span class="kw">do</span>
 <span class="fu">...</span></code></pre></div>
</article>
]]></description>
    <pubDate>Mon, 10 Feb 2014 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2014-02-10-record-wildcards.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Multi-line strings in Haskell</title>
    <link>http://kseo.github.io//posts/2014-02-06-multi-line-strings-in-haskell.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on February  6, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/multi-line%20string.html">multi-line string</a>, <a href="/tags/quasiquotation.html">quasiquotation</a>
      
  </div>

<p>Haskell supports multi-line string literals in several ways.</p>
<h2 id="unlines">unlines</h2>
<p><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:unlines">unlines</a> joins lines, after appending a terminating newline to each.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">multi <span class="fu">=</span> unlines [<span class="st">&quot;line1&quot;</span>, <span class="st">&quot;line2&quot;</span>, <span class="st">&quot;line3&quot;</span>]</code></pre></div>
<h2 id="multi-line-string-literal">Multi-line string literal</h2>
<p>We should escape it using <code>\</code> and then another <code>\</code> where the string starts again.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">multi <span class="fu">=</span> <span class="st">&quot;line1\</span>
<span class="st">\line2\</span>
<span class="st">\line3&quot;</span></code></pre></div>
<h2 id="quasiquotation">Quasiquotation</h2>
<p>The <a href="http://hackage.haskell.org/package/raw-strings-qq">raw-strings-qq</a> package provides a quasiquoter for raw string literals. In addition to supporting multi-line string, it does not recognize escape sequences. So we don’t need to add <code>\</code> as in multi-line string literals. <code>{-# LANGUAGE QuasiQuotes #-}</code> is required to use this feature.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span>
<span class="kw">import </span><span class="dt">Text.RawString.QQ</span>
multi <span class="fu">=</span> [r<span class="fu">|</span>line1
line2
line3<span class="fu">|</span>]</code></pre></div>
<p>I prefer quasiquotation because I use multi-line string literals for HTML/XML fragments and it is laborious to escape all special characters such as quotes.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span>
<span class="kw">import </span><span class="dt">Text.RawString.QQ</span>
 
<span class="ot">multiline ::</span> <span class="dt">String</span>
multiline <span class="fu">=</span> [r<span class="fu">|&lt;</span><span class="dt">HTML</span><span class="fu">&gt;</span>
<span class="fu">&lt;</span><span class="dt">HEAD</span><span class="fu">&gt;</span>
<span class="fu">&lt;</span><span class="dt">TITLE</span><span class="fu">&gt;</span><span class="dt">Auto</span><span class="fu">-</span>generated html formated source<span class="fu">&lt;/</span><span class="dt">TITLE</span><span class="fu">&gt;</span>
<span class="fu">&lt;</span><span class="dt">META</span> <span class="dt">HTTP</span><span class="fu">-</span><span class="dt">EQUIV</span><span class="fu">=</span><span class="st">&quot;Content-Type&quot;</span> <span class="dt">CONTENT</span><span class="fu">=</span><span class="st">&quot;text/html; charset=windows-1252&quot;</span><span class="fu">&gt;</span>
<span class="fu">&lt;/</span><span class="dt">HEAD</span><span class="fu">&gt;</span>
<span class="fu">&lt;</span><span class="dt">BODY</span> <span class="dt">LINK</span><span class="fu">=</span><span class="st">&quot;800080&quot;</span> <span class="dt">BGCOLOR</span><span class="fu">=</span><span class="st">&quot;#ffffff&quot;</span><span class="fu">&gt;</span>
<span class="fu">&lt;</span><span class="dt">P</span><span class="fu">&gt;</span> <span class="fu">&lt;/</span><span class="dt">P</span><span class="fu">&gt;</span>
<span class="fu">&lt;</span><span class="dt">PRE</span><span class="fu">&gt;|</span>]</code></pre></div>
<p>There are other quasi-quote packages such as <a href="http://hackage.haskell.org/package/interpolatedstring-qq">string-qq</a>, <a href="http://hackage.haskell.org/package/string-quote">string-quote</a> and <a href="http://hackage.haskell.org/package/interpolatedstring-qq">interpolatedstring-qq</a>.</p>
</article>
]]></description>
    <pubDate>Thu, 06 Feb 2014 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2014-02-06-multi-line-strings-in-haskell.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Default values of Haskell Types</title>
    <link>http://kseo.github.io//posts/2014-02-06-default-values-of-haskell-types.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on February  6, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/default%20value.html">default value</a>
      
  </div>

<p>Java types have default values. If you don’t explicitly assign a value in a field declaration, it gets its default value of the given type. For example, the default value of <code>int</code> is <code>0</code> and the default value of <code>boolean</code> is <code>false</code>.</p>
<p>On the contrary, Haskell types do not provide default values. This is natural because Haskell does not destructively update a variable initialized with the the default value.</p>
<p>However, it is handy to have a default value in some cases such as a record with many fields. Haskell libraries often provide a default value for such a record for the ease of construction. For example, <a href="http://bscarlet.github.io/llvm-general/3.3.8.2/doc/html/llvm-general-pure/index.html">llvm-general-pure</a> provides <code>defaultModule</code>, which is the default value of <code>Module</code>. The data constructor <code>Module</code> has 4 fields:</p>
<ul>
<li><code>moduleName :: String</code></li>
<li><code>moduleDataLayout :: Maybe DataLayout</code> – a DataLayout, if specified, must match that of the eventual code generator</li>
<li><code>moduleTargetTriple :: Maybe String</code></li>
<li><code>moduleDefinitions :: [Definition]</code></li>
</ul>
<p>Using <code>defaultModule</code>, you don’t need to supply all these fields. You can construct a <code>Module</code> value using Haskell record update syntax as in the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">defaultModule { moduleName<span class="fu">=</span><span class="st">&quot;mymodule&quot;</span> }</code></pre></div>
<p>The <a href="http://hackage.haskell.org/package/data-default">data-default</a> package provides a type class <code>Default</code>, which is useful for this purpose. If a given type is an instance of <code>Default</code>, you can get its default value using <code>def</code> method. Instances are provided for <code>()</code>, <code>Set</code>, <code>Map</code>, <code>Int</code>, <code>Integer</code>, <code>Float</code>, <code>Double</code>, and many others.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Prelude</span> <span class="dt">Data.Default</span><span class="fu">&gt;</span><span class="ot"> def ::</span> <span class="dt">Int</span>
<span class="dv">0</span>
<span class="dt">Prelude</span> <span class="dt">Data.Default</span><span class="fu">&gt;</span><span class="ot"> def ::</span> [a]
[]
<span class="dt">Prelude</span> <span class="dt">Data.Default</span><span class="fu">&gt;</span><span class="ot"> def ::</span> <span class="dt">Double</span>
<span class="fl">0.0</span></code></pre></div>
</article>
]]></description>
    <pubDate>Thu, 06 Feb 2014 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2014-02-06-default-values-of-haskell-types.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Data.Typeable and Data.Dynamic in Haskell</title>
    <link>http://kseo.github.io//posts/2014-02-03-data-typeable-and-data-dynamic-in-haskell.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on February  3, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Data.Typeable.html">Data.Typeable</a>, <a href="/tags/Data.Dynamic.html">Data.Dynamic</a>, <a href="/tags/dynamic%20typing.html">dynamic typing</a>
      
  </div>

<p><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Typeable.html">Data.Typeable</a> is a way to implement dynamic (delayed) type checking in Haskell using a <a href="http://www.haskell.org/haskellwiki/Heterogenous_collections#A_Universal_type">universal type</a>.</p>
<p>For example, you can implement a heterogenous list in Haskell. <code>toDyn</code> converts any <code>Typeable</code> instance into <code>Dynamic</code> which is similar to Java <code>Object</code> type. Any type that is an instance of <code>Typeable</code> class can be wrapped with <code>Dynamic</code> type.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Dynamic</span>
<span class="kw">import </span><span class="dt">Data.Maybe</span>
 
<span class="ot">hlist ::</span> [<span class="dt">Dynamic</span>]
hlist <span class="fu">=</span> [ toDyn <span class="st">&quot;string&quot;</span>
        , toDyn (<span class="dv">7</span><span class="ot"> ::</span> <span class="dt">Int</span>)
        , toDyn (pi<span class="ot"> ::</span> <span class="dt">Double</span>)
        , toDyn <span class="ch">&#39;x&#39;</span>
        , toDyn ((), <span class="dt">Just</span> <span class="st">&quot;foo&quot;</span>)
        ]
 
<span class="ot">dyn ::</span> <span class="dt">Dynamic</span>
dyn <span class="fu">=</span> hlist <span class="fu">!!</span> <span class="dv">1</span></code></pre></div>
<p>To be precise, <code>hlist</code> is not actually a heterogenous list from the point of Haskell type system. It is just a homogenous list of <code>Dynamic</code>. The chapter 20, “Untyped Means Uni-Typed” of Harper’s textbook also emphasizes this observation: dynamic types (with typeable representations) are statically typed languages with only one type.</p>
<p>You can convert a <code>Dynamic</code> object back into an ordinary Haskell value using <code>fromDynamic</code>. Type checking is dynamic because it is delayed to runtime.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">v ::</span> <span class="dt">Int</span>
v <span class="fu">=</span> <span class="kw">case</span> fromDynamic dyn <span class="kw">of</span>
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;Type mismatch&quot;</span>
        <span class="dt">Just</span> x  <span class="ot">-&gt;</span> x</code></pre></div>
<p>You can make any type <code>Typeable</code> by adding <code>deriving Data.Typeable</code>. In GHC, you need to turn on <code>-XDeriveDataTypeable</code> option to make GHC automatically derive the instance for you.</p>
<p>The <code>Data.Typeable</code> class is used primarily for generic programming in the “Scrap Your Boilerplate (SYB)” style. I will write more on this later.</p>
<h2 id="references">References</h2>
<ul>
<li>Martín Abadi, Luca Cardelli, Benjamin Pierce and Gordon Plotkin, “<a href="http://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-47.pdf">Dynamic Typing in a Statically Typed Language</a>”, ACM Transactions on Programming Languages and Systems (TOPLAS), 1991.</li>
<li>James Cheney and Ralf Hinze, “<a href="https://www.cs.ox.ac.uk/people/ralf.hinze/publications/HW02.pdf">A lightweight implementation of generics and dynamics</a>”, Haskell ’02: Proceedings of the 2002 ACM SIGPLAN Workshop on Haskell, 2002.</li>
<li>Lammel, Ralf and Jones, Simon Peyton, “<a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/hmap.ps">Scrap your boilerplate: a practical design pattern for generic programming</a>”, TLDI ’03: Proceedings of the 2003 ACM SIGPLAN International Workshop on Types in Languages Design and Implementation, 2003</li>
<li>Harper, 2011, Practical Foundations for Programming Languages.</li>
</ul>
</article>
]]></description>
    <pubDate>Mon, 03 Feb 2014 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2014-02-03-data-typeable-and-data-dynamic-in-haskell.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>

    </channel>
</rss>
