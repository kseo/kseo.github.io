<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Haskell for Pragmatic Programmers</title>
        <link>http://kseo.github.io/</link>
        <description><![CDATA[Kwang Yul Seo's Haskell Blog]]></description>
        <atom:link href="http://kseo.github.io//rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Thu, 29 Dec 2016 00:00:00 UT</lastBuildDate>
        <item>
    <title>Two encodings of substitution operation</title>
    <link>http://kseo.github.io//posts/2016-12-29-two-encodings-of-substitution-operation.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 29, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/substitution.html">substitution</a>
      
  </div>

<p>Substitution operations are heavily used in implementing type checkers. A substitution is a finite mappings from type variables to types. Thus it is natural to define <code>Subst</code> as a list of <code>(Name, Type)</code> pairs as in the following example.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Bifunctor</span>

<span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="kw">data</span> <span class="dt">Type</span> <span class="fu">=</span> <span class="dt">TVar</span> <span class="dt">Name</span>
          <span class="fu">|</span> <span class="dt">TCon</span> <span class="dt">Name</span> [<span class="dt">Type</span>]

<span class="kw">type</span> <span class="dt">Subst</span> <span class="fu">=</span> [(<span class="dt">Name</span>, <span class="dt">Type</span>)]</code></pre></div>
<p>Composition of substitutions can be encoded as operations over the underlying association list.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">idSubst ::</span> <span class="dt">Subst</span>
idSubst <span class="fu">=</span> []

<span class="ot">composeSubst ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Subst</span>
composeSubst s1 s2 <span class="fu">=</span> map (second (applySubst s1)) s2 <span class="fu">++</span> s1</code></pre></div>
<p><code>applySubst</code> applies the substitution given over the structure of the type replacing type variables as specified.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">applySubst ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>
applySubst s (<span class="dt">TVar</span> n) <span class="fu">=</span> <span class="kw">case</span> lookup n s <span class="kw">of</span>
                          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">TVar</span> n
                          <span class="dt">Just</span> t <span class="ot">-&gt;</span> t
applySubst s (<span class="dt">TCon</span> n ts) <span class="fu">=</span> <span class="dt">TCon</span> n (map (applySubst s) ts)</code></pre></div>
<p>Martin Grabm¨uller’s <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.65.7733&amp;rep=rep1&amp;type=pdf">Algorithm W Step by Step</a> uses a slight variation of this encoding to implement Hindley-Milner type system. His version uses <code>Map Name Type</code> instead of <code>[(Name, String)]</code> for efficient lookup.</p>
<p>Alternatively, we can encode substitution operations directly as a function from type variables to types.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Subst</span> <span class="fu">=</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>

<span class="ot">idSubst ::</span> <span class="dt">Subst</span>
idSubst n <span class="fu">=</span> <span class="dt">TVar</span> n

<span class="ot">composeSubst ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Subst</span>
composeSubst s1 s2 <span class="fu">=</span> applySubst s1 <span class="fu">.</span> s2

<span class="ot">applySubst ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>
applySubst s (<span class="dt">TVar</span> n) <span class="fu">=</span> s n
applySubst s (<span class="dt">TCon</span> n ts) <span class="fu">=</span> <span class="dt">TCon</span> n (map (applySubst s) ts)</code></pre></div>
<p>Simon Peyton Jones’s <a href="https://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/">The Implementation of Functional Programming Languages</a> uses this encoding of substitution to implement the type checker.</p>
<p>These two encodings are equivalent.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Thu, 29 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-29-two-encodings-of-substitution-operation.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Lazy vs Strict State Monad</title>
    <link>http://kseo.github.io//posts/2016-12-28-lazy-vs-strict-state-monad.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 28, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/state%20monad.html">state monad</a>, <a href="/tags/lazy.html">lazy</a>, <a href="/tags/strict.html">strict</a>
      
  </div>

<p><a href="https://www.stackage.org/lts-7.12/package/mtl-2.2.1">mtl</a> (or its underlying <a href="https://www.stackage.org/lts-7.12/package/transformers-0.5.2.0">transformers</a>) package provides two types of <code>State</code> monad; <code>Control.Monad.State.Strict</code> and <code>Control.Monad.State.Lazy</code>. <code>Control.Monad.State</code> re-exports <code>Control.Monad.State.Lazy</code>.</p>
<p>The difference between these two state monads does not matter in most cases, but it may cause unexpected surprises when infinite lists are involved. In this post, I am going to explain the subtle difference between lazy and strict state monads.</p>
<p>Let’s start the discussion with a simple example. The program shown below returns an infinite list of integers <code>[1..]</code> in a lazy state monad. Running the program prints <code>[1,2,3,4,5]</code> as expected.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.State.Lazy</span>

<span class="ot">foo ::</span> <span class="dt">State</span> () [<span class="dt">Int</span>]
foo <span class="fu">=</span> traverse pure [<span class="dv">1</span><span class="fu">..</span>]

main <span class="fu">=</span> print <span class="fu">$</span> take <span class="dv">5</span> (evalState foo ())</code></pre></div>
<p>However, when we replace the import with <code>Control.Monad.State.Strict</code>, the program hangs up.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.State.Strict</span>

<span class="ot">foo ::</span> <span class="dt">State</span> () [<span class="dt">Int</span>]
foo <span class="fu">=</span> traverse pure [<span class="dv">1</span><span class="fu">..</span>]

main <span class="fu">=</span> print <span class="fu">$</span> take <span class="dv">5</span> (evalState foo ())</code></pre></div>
<p>What happened here? The definition of <code>traverse</code> might give us a hint.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Traversable</span> [] <span class="kw">where</span>
  traverse f <span class="fu">=</span> List.foldr cons_f (pure [])
    <span class="kw">where</span> cons_f x ys <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> f x <span class="fu">&lt;*&gt;</span> ys</code></pre></div>
<p>From the definition of <code>traverse</code>, we can see that <code>traverse return [1..]</code> expands to</p>
<pre><code>(:) &lt;$&gt; (return 1) &lt;*&gt; ((:) &lt;$&gt; (return 2) &lt;*&gt; ((:) &lt;$&gt; (return 3) &lt;*&gt; (...)))</code></pre>
<p><code>(&lt;$&gt;)</code> and <code>(&lt;*&gt;)</code> operators are used to combine values. <code>(&lt;$&gt;)</code> are <code>(&lt;*&gt;)</code> are defined in <code>Functor</code> and <code>Applicative</code> instances of <code>State</code> monad respectively.</p>
<p>Let’s compare the definitions of these operators.</p>
<ul>
<li>Control.Monad.Trans.State.Lazy</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Functor</span> m) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span>
    fmap f m <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \ s <span class="ot">-&gt;</span>
        fmap (\ <span class="fu">~</span>(a, s&#39;) <span class="ot">-&gt;</span> (f a, s&#39;)) <span class="fu">$</span> runStateT m s

<span class="kw">instance</span> (<span class="dt">Functor</span> m, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span>
    pure a <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \ s <span class="ot">-&gt;</span> return (a, s)
    <span class="dt">StateT</span> mf <span class="fu">&lt;*&gt;</span> <span class="dt">StateT</span> mx <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \ s <span class="ot">-&gt;</span> <span class="kw">do</span>
        <span class="fu">~</span>(f, s&#39;) <span class="ot">&lt;-</span> mf s
        <span class="fu">~</span>(x, s&#39;&#39;) <span class="ot">&lt;-</span> mx s&#39;
        return (f x, s&#39;&#39;)</code></pre></div>
<ul>
<li>Control.Monad.Trans.State.Strict</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Functor</span> m) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span>
    fmap f m <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \ s <span class="ot">-&gt;</span>
        fmap (\ (a, s&#39;) <span class="ot">-&gt;</span> (f a, s&#39;)) <span class="fu">$</span> runStateT m s

<span class="kw">instance</span> (<span class="dt">Functor</span> m, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span>
    pure a <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \ s <span class="ot">-&gt;</span> return (a, s)
    <span class="dt">StateT</span> mf <span class="fu">&lt;*&gt;</span> <span class="dt">StateT</span> mx <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \ s <span class="ot">-&gt;</span> <span class="kw">do</span>
        (f, s&#39;) <span class="ot">&lt;-</span> mf s
        (x, s&#39;&#39;) <span class="ot">&lt;-</span> mx s&#39;
        return (f x, s&#39;&#39;)</code></pre></div>
<p>The two definitions are almost the same except for a small difference in pattern matching. Did you find it? Yes, the lazy version uses a tilde <code>~</code> in pattern matching on a pair. It is a <a href="https://wiki.haskell.org/Lazy_pattern_match">lazy pattern</a> matching.</p>
<p>Here’s the secret. In the strict version, the pattern matches on the pair forces its evaluation. So <code>traverse pure [1..]</code> never returns until its evaluation is finished. The lazy version avoids this evaluation of the pair using an irrefutable pattern <code>~(a,w)</code>. Evaluation is forced later when the pair is actually needed. This is why we can manipulate infinite lists in a lazy state monad.</p>
<p>But this observation does not imply that we should always prefer the lazy version of state monad because the lazy state monad often builds up large thunks and causes space leaks due to its laziness.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Wed, 28 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-28-lazy-vs-strict-state-monad.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Higher rank polymorphism</title>
    <link>http://kseo.github.io//posts/2016-12-27-higher-rank-polymorphism.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 27, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/higher%20rank%20polymorphism.html">higher rank polymorphism</a>, <a href="/tags/let%20bound%20polymorphism.html">let bound polymorphism</a>, <a href="/tags/RankNTypes.html">RankNTypes</a>, <a href="/tags/ScopedTypeVariables.html">ScopedTypeVariables</a>
      
  </div>

<p>The type system of Haskell is based on <em>Hindley-Milner</em>, so it has so called <em>let-bound polymorphism</em>. It means identifiers bound using a <code>let</code> or <code>where</code> clause can be polymorphic. On the contrary, lambda-bound identifiers are monomorphic.</p>
<p>For example, the following program is illegal in Haskell:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foo ::</span> (<span class="dt">Int</span>, <span class="dt">Char</span>)
foo <span class="fu">=</span> (\f <span class="ot">-&gt;</span> (f <span class="dv">1</span>, f <span class="ch">&#39;a&#39;</span>)) id</code></pre></div>
<p>The <a href="https://www.haskell.org/tutorial/pitfalls.html">Typing Pitfalls</a> section of “A Gentle Introduction to Haskell, Version 98” also mentions a similar case.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> f g  <span class="fu">=</span>  (g [], g <span class="ch">&#39;a&#39;</span>)                       <span class="co">-- ill-typed expression</span>
<span class="kw">in</span> f (\x<span class="ot">-&gt;</span>x)</code></pre></div>
<p>Thanks to <em>let-polymorphism</em>, we can easily make <code>foo</code> type-check by moving <code>f</code> to <code>where</code> clause.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foo ::</span> (<span class="dt">Int</span>, <span class="dt">Char</span>)
foo <span class="fu">=</span> (f <span class="dv">1</span>, f <span class="ch">&#39;a&#39;</span>)
  <span class="kw">where</span> f <span class="fu">=</span> id</code></pre></div>
<p>Or by binding <code>f</code> with <code>let</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foo ::</span> (<span class="dt">Int</span>, <span class="dt">Char</span>)
foo <span class="fu">=</span> <span class="kw">let</span> f <span class="fu">=</span> id
       <span class="kw">in</span> (f <span class="dv">1</span>, f <span class="ch">&#39;a&#39;</span>)</code></pre></div>
<p>This is rather unfortunate because all these forms represent the same program, but only one of them fails to type check.</p>
<p>If Haskell can’t infer the type for us, let’s bite the bullet and perform the type inference by ourselves. What’s the type of <code>f</code>? It is <code>forall a. a -&gt; a</code>. Thus the type of <code>foo</code> is <code>(forall a. a -&gt; a) -&gt; (Int, Char)</code>.</p>
<p>Aha! This is a higher-rank type (rank 2 in this case) and we can specify the type of <code>f</code> using two GHC extensions; <code>RankNTypes</code> and <code>ScopedTypeVariables</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RankNTypes #-}</span>
<span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span>

<span class="ot">foo ::</span> (<span class="dt">Int</span>, <span class="dt">Char</span>)
foo <span class="fu">=</span> (\(<span class="ot">f ::</span> forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (f <span class="dv">1</span>, f <span class="ch">&#39;a&#39;</span>)) id</code></pre></div>
<p><code>RankNTypes</code> allows us to express higher-rank types and <code>ScopeTypeVariables</code> allows free type variables to be re-used in the scope of a function</p>
<p>Now our program is well-typed!</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Tue, 27 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-27-higher-rank-polymorphism.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Type Isomorphism</title>
    <link>http://kseo.github.io//posts/2016-12-25-type-isomorphism.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 25, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/type%20isomorphism.html">type isomorphism</a>
      
  </div>

<p>Type isomorphisms are a general notion of conversion between types. We say that type <code>A</code> and <code>B</code> are isomorphic, if we have conversion functions <code>f :: A -&gt; B</code> and <code>g :: B -&gt; A</code> such that</p>
<pre><code>f . g = idB
g . f = idA</code></pre>
<p>Type isomorphisms imply that we can safely convert without loss of information between types.</p>
<h1 id="motivation">Motivation</h1>
<p>There always exist multiple types that can represent the same values we want to represent. The problem is that they are not compatible because the type system does not automatically recognize them as equal. So we might not be able to reuse the existing libraries as the types we use in our program are not compatible with the types these libraries use. Type isomorphisms provide wrapping/unwrapping functions that can safely convert between these types.</p>
<p>Type isomorphisms also help us understand various transformations used in equational reasoning and API design.</p>
<h1 id="basics">Basics</h1>
<p>Haskell programmers already use the type isomorphism to reason about programs. For example, we know that pair <code>(a,b)</code> is isomorphic to <code>(b,a)</code> because <code>swap</code> is the conversion function in both directions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">swap ::</span> (a,b) <span class="ot">-&gt;</span> (b,a)
swap (a, b) <span class="fu">=</span> (b, a)</code></pre></div>
<p>Another example of type isomorphism is <code>a</code> and <code>() -&gt; a</code>. We can define conversion functions as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> a <span class="ot">-&gt;</span> () <span class="ot">-&gt;</span> a
f <span class="fu">=</span> \x _ <span class="ot">-&gt;</span> x

<span class="ot">g ::</span> (() <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a
g k <span class="fu">=</span> k ()</code></pre></div>
<p>What about <code>a -&gt; ()</code>? This type is unsurprisingly isomorphic to <code>()</code> because <code>a -&gt; ()</code> type has only one inhabitant which discards the argument and returns <code>()</code>. Conversion functions are:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> (a <span class="ot">-&gt;</span> ()) <span class="ot">-&gt;</span> ()
f _ <span class="fu">=</span> ()

<span class="ot">g ::</span> () <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> ()
g <span class="fu">=</span> \_ _ <span class="ot">-&gt;</span> ()</code></pre></div>
<h1 id="currying-and-uncurrying">Currying and uncurrying</h1>
<p>In functional programming, <em>currying</em> transforms a function that takes multiple arguments via a pair, into a function that accepts the first argument of the pair, and returns a function that accepts the second argument, before returning the result. <em>uncurrying</em> performs transformation in the opposite direction.</p>
<p>Here are the types of <code>curry</code> and <code>uncurry</code> functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">curry<span class="ot"> ::</span> ((a, b) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c
uncurry<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a, b) <span class="ot">-&gt;</span> c</code></pre></div>
<p>From the signature of these functions, we can see that <code>(a, b) -&gt; c</code> and <code>a -&gt; b -&gt; c</code> are isomorphic by <code>curry</code> and <code>uncurry</code> functions.</p>
<h1 id="continuation">Continuation</h1>
<p><code>a</code> can be converted to <code>(a -&gt; r) -&gt; r</code> by CPS transformation. A CPS term can be converted back to the direct style by applying <code>id</code> function.</p>
<pre><code>{-# LANGUAGE RankNTypes #-}

f :: a -&gt; (a -&gt; r) -&gt; r
f a b = b a

g :: (forall r. (a -&gt; r) -&gt; r) -&gt; a
g a = a id</code></pre>
<p><code>RankNTypes</code> extension is necessary to represent the type of <code>g</code>.</p>
<h1 id="algebraic-data-types">Algebraic data types</h1>
<p>Every algebraic data type can be represented with combinations of <em>product</em> and <em>sum</em> types. This is why these types are called <em>algebraic data types</em>.</p>
<p>In Haskell, products are encoded by <code>(a, b)</code> and sums are encoded by <code>Either a b</code>. Thus an algebraic data type of Haskell is isomorphic to some combinations of <code>(a, b)</code> and <code>Either a b</code>. Let’s see a few examples.</p>
<p><code>Bool</code> is isomorphic to <code>Either () ()</code> because we can define conversion functions <code>f</code> and <code>g</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> () ()
f <span class="dt">True</span> <span class="fu">=</span> <span class="dt">Left</span> ()
f <span class="dt">False</span> <span class="fu">=</span> <span class="dt">Right</span> ()

<span class="ot">g ::</span> <span class="dt">Either</span> () () <span class="ot">-&gt;</span> <span class="dt">Bool</span>
g (<span class="dt">Left</span> ()) <span class="fu">=</span> <span class="dt">True</span>
g (<span class="dt">Right</span> ()) <span class="fu">=</span> <span class="dt">False</span></code></pre></div>
<p><code>Maybe a</code> is isomorphic to <code>Either a ()</code> or <code>Either () a</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> () a
f (<span class="dt">Just</span> x) <span class="fu">=</span> <span class="dt">Right</span> x
f <span class="dt">Nothing</span> <span class="fu">=</span> <span class="dt">Left</span> ()

<span class="ot">g ::</span> <span class="dt">Either</span> () a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
g (<span class="dt">Left</span> ()) <span class="fu">=</span> <span class="dt">Nothing</span>
g (<span class="dt">Right</span> x) <span class="fu">=</span> <span class="dt">Just</span> x</code></pre></div>
<h1 id="playing-with-type-isomorphism">Playing with type isomorphism</h1>
<p><em>unfold</em> is the categorical dual of <em>fold</em>. It means we can get the type of <code>unfold</code> by reversing arrows of <code>fold</code>.</p>
<p>Here are the type signatures of <code>foldr</code> and <code>unfoldr</code> taken from the <code>base</code> library.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b
<span class="ot">unfoldr ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, b)) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> [a])</code></pre></div>
<p>It is not obvious how <code>foldr</code> and <code>unfoldr</code> are related. But we can apply the types isomorphism we’ve learned to derive the type of <code>unfoldr</code> from <code>foldr</code>.</p>
<pre><code>(a → b → b) → b → ([a] → b)
=== ((a, b) → b) → b → ([a] → b)
=== ((a, b) → b) → (() -&gt; b) → ([a] → b)
=== (((a, b) → b), (() -&gt; b)) → ([a] → b)
=== ((Either (a, b) ()) → b) → ([a] → b)
=== (Maybe (a, b) -&gt; b) → ([a] → b)</code></pre>
<p>We used the following type isomorphisms:</p>
<ul>
<li><code>a -&gt; b -&gt; c ~= (a, b) -&gt; c</code></li>
<li><code>a ~= () -&gt; a</code></li>
<li><code>((a -&gt; c), (b -&gt; c)) ~= Either a b -&gt; c</code></li>
<li><code>Either a () ~= Maybe a</code>.</li>
</ul>
<p>Finally, by reversing the arrows of <code>foldr</code>, we get <code>unfoldr</code>.</p>
<pre><code>foldr   :: (Maybe (a, b) -&gt; b           ) -&gt; ([a] -&gt; b  )
unfoldr :: (b            -&gt; Maybe (a, b)) -&gt; (b   -&gt; [a])</code></pre>
<p>Interested readers might want to take a look at my previous post <a href="http://kseo.github.io/posts/2016-12-12-unfold-and-fold.html">unfold and fold</a> and Conal Elliott’s <a href="http://conal.net/talks/folds-and-unfolds.pdf">Folds and unfolds all around us</a> for the details.</p>
<h1 id="existentials">Existentials</h1>
<p><code>{∃X,T}</code> and <code>∀Y. (∀X. T→Y) → Y</code> are isomorphic types. My previous post <a href="http://kseo.github.io/posts/2016-12-19-encoding-existentials.html">Encoding existentials</a> shows how we can encode existential types using only <code>RankNTypes</code> and <em>forall</em> quantifier.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Sun, 25 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-25-type-isomorphism.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Reader monad and SKI combinators</title>
    <link>http://kseo.github.io//posts/2016-12-24-reader-monad-and-ski-combinators.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 24, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/reader%20monad.html">reader monad</a>, <a href="/tags/ski%20combinator.html">ski combinator</a>
      
  </div>

<p>In this post, I am going to show you the relationship between the reader monad and the SKI combinators.</p>
<h1 id="reader-monad">Reader monad</h1>
<p>The reader monad encapsulates computations which read values from a shared environment. Here’s the definition of our beloved <code>Reader</code> monad.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Reader</span> r a <span class="fu">=</span> <span class="dt">Reader</span> {
<span class="ot">  runReader ::</span> r <span class="ot">-&gt;</span> a
}

<span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Reader</span> r ) <span class="kw">where</span>
  return a <span class="fu">=</span> <span class="dt">Reader</span> <span class="fu">$</span> \_ <span class="ot">-&gt;</span> a
  m <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> <span class="dt">Reader</span> <span class="fu">$</span> \r <span class="ot">-&gt;</span> runReader (k (runReader m r )) r</code></pre></div>
<p>There are actually two instances of the reader monad in Haskell. The function monad <code>(-&gt;) r</code> is also a reader monad. The definition of the function monad is just like the <code>Reader</code> monad, but without <code>newtype</code> wrapping and unwrapping.</p>
<pre><code>instance Monad ((-&gt;) r ) where
  return a = \_ -&gt; a
  m &gt;&gt;= k = \r -&gt; k (m r ) r</code></pre>
<p>From now on, I will use the function monad definition because it makes our presentation more clear. But remember these two monad definitions are isomorphic.</p>
<h1 id="ski-combinators">SKI combinators</h1>
<p><a href="https://en.wikipedia.org/wiki/Combinatory_logic">Combinatory logic</a> is a formal system without the need for variables. It was introduced by Moses Schönfinkel and Haskell Curry.</p>
<p>The SKI calculus is a combinatory logic with three combinators S, K and I. It is a universal system as all operations in lambda calculus can be encoded via <em>abstraction elimination</em> into the SKI calculus.</p>
<p>The Haskell definition of <code>s</code>, <code>k</code> and <code>i</code> are as follows:</p>
<pre><code>k :: a -&gt; b -&gt; a
k x y = x

s :: (a -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
s x y z = (x z) (y z)

i :: a -&gt; a
i x = x</code></pre>
<p>From the types of these combinators, we can see that <code>k</code> is Haskell’s <code>const</code> function and <code>i</code> is Haskell’s <code>id</code> function.</p>
<p>Technically speaking, we don’t need the I combinator to encode lambda calculus into the SKI combinators because we can encode I in terms of S and K. I is just for convenience.</p>
<h1 id="relationship">Relationship</h1>
<p>So what’s the relationship between the reader monad and the SKI combinators? Let’s look at the types of the reader monad more closely.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">return<span class="ot"> ::</span> a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> a
<span class="ot">(&gt;&gt;=) ::</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> b</code></pre></div>
<p>Can you see the similarity to the types of the combinator <code>k</code> and <code>s</code>? The function <code>return</code> is the same as <code>k</code>, but the function <code>(&gt;&gt;=)</code> is somewhat similar but not exactly the same as <code>s</code>.</p>
<p>Let’s see the <em>applicative functor</em> definition of the reader monad instead.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pure<span class="ot"> ::</span> a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> a
<span class="ot">(&lt;*&gt;) ::</span> (r <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> b</code></pre></div>
<p>Now we can see that the type of <code>(&lt;*&gt;)</code> is the same to the type of <code>s</code>. Because these functions are fully polymorphic, we don’t need to check the definition of these functions to see if they are really equivalent.</p>
<p><a href="http://www.staff.city.ac.uk/~ross/papers/Applicative.html">Conor McBride and Ross Paterson’s paper</a> also mentions this relationship briefly.</p>
<h1 id="conclusion">Conclusion</h1>
<p>We’ve just discovered that <code>k</code> and <code>s</code> combinators of SKI calculus correspond to <code>pure</code> and <code>(&lt;*&gt;)</code> functions of the reader monad. Because we can encode any lambda calculus term into SKI calculus, we can encode any lambda calculus term into the reader monad too! Amazing, isn’t it?</p>
<h1 id="references">References</h1>
<ol style="list-style-type: decimal">
<li><a href="https://themonadreader.wordpress.com/2011/01/09/issue-17/">The Monad.Reader Issue 17: The Reader Monad and Abstraction Elimination</a></li>
<li><a href="http://brandon.si/code/do-applicative-functors-generalize-the-s-k-combinators/">Do Applicative Functors Generalize the S &amp; K Combinators?</a></li>
</ol>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Sat, 24 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-24-reader-monad-and-ski-combinators.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Organize code using monads</title>
    <link>http://kseo.github.io//posts/2016-12-23-organize-code-using-monads.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 23, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/monad.html">monad</a>, <a href="/tags/monad%20transformer.html">monad transformer</a>, <a href="/tags/lambda%20lifting.html">lambda lifting</a>
      
  </div>

<p>Novice Haskell programmers think that monads are only for IO and stateful computations. But experienced Haskell programmers use monads to better structure their programs.</p>
<p>In this blog post, I am going to show you how we can better organize our code using monads.</p>
<h1 id="motivating-example-lambda-lifting">Motivating example: Lambda lifting</h1>
<p><em>Lambda lifting</em> is a compiler transformation which eliminates all free variables from function definitions. It is an important step in a lazy functional language because it greatly simplifies evaluation on the graph reduction machine.</p>
<p>In his <a href="https://www.microsoft.com/en-us/research/publication/a-modular-fully-lazy-lambda-lifter-in-haskell/">paper</a>, Simon Peyton Jones describes how to perform lambda lifting in a modular fashion. The lambda lifter works in three steps:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | freeVars: Annotate every node in the expression with its free variables.</span>
<span class="ot">freeVars ::</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> <span class="dt">AnnExpr</span> <span class="dt">Name</span> (<span class="dt">Set</span> <span class="dt">Name</span>)

<span class="co">-- | Abstract the free variables from each lambda abstraction, replacing the lambda abstraction with the application of the new abstraction.</span>
<span class="ot">abstract ::</span> <span class="dt">AnnExpr</span> <span class="dt">Name</span> (<span class="dt">Set</span> <span class="dt">Name</span>) <span class="ot">-&gt;</span> <span class="dt">Expression</span>

<span class="co">-- | Give a unique name to each supercombinator and collect all the supercombinator definitions.</span>
<span class="ot">collectSCs ::</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> [<span class="dt">SCDefn</span>]</code></pre></div>
<p><code>lambdaLift</code> is the composition of these three functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lambdaLift ::</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> [<span class="dt">SCDefn</span>]
lambdaLift <span class="fu">=</span> collectSCs <span class="fu">.</span> abstract <span class="fu">.</span> freeVars</code></pre></div>
<p>I am not going to explain the details of these steps in this post. Interested readers are referred to SPJ’s <a href="https://www.microsoft.com/en-us/research/publication/a-modular-fully-lazy-lambda-lifter-in-haskell/">paper</a> and <a href="https://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/">book</a>.</p>
<p>Instead, let’s dive into the last step and see how <code>collectSCs</code> is actually implemented.</p>
<h1 id="collecting-supercombinators">Collecting supercombinators</h1>
<p><code>collectSCs</code> is defined in terms of a helper function named <code>collecSC'</code> which returns both the collection of supercombinators it has found and the transformed expression. It also carries around a <em>name supply</em> as an argument and returns the depleted supply as a result because it needs to generate fresh names for supercombinators.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Gives a unique name to each supercombinator, collects all the</span>
<span class="co">-- supercombinator definitions into a single list, and introduce the</span>
<span class="co">-- $main supercombinator definition.</span>
<span class="ot">collectSCs ::</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> [<span class="dt">SCDefn</span>]
collectSCs e <span class="fu">=</span> (<span class="st">&quot;$main&quot;</span>, [], e&#39;) <span class="fu">:</span> scs
  <span class="kw">where</span>
  (_, scs, e&#39;) <span class="fu">=</span> collectSCs&#39; initialNameSupply e

<span class="ot">collectSCs&#39; ::</span> <span class="dt">NameSupply</span> <span class="ot">-&gt;</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> (<span class="dt">NameSupply</span>, [<span class="dt">SCDefn</span>], <span class="dt">Expression</span>)
collectSCs&#39; ns (<span class="dt">EConst</span> k) <span class="fu">=</span> (ns, [], <span class="dt">EConst</span> k)
collectSCs&#39; ns (<span class="dt">EVar</span> v) <span class="fu">=</span> (ns, [], <span class="dt">EVar</span> v)
collectSCs&#39; ns (<span class="dt">EAp</span> e1 e2) <span class="fu">=</span>
  (ns2, scs1 <span class="fu">++</span> scs2, <span class="dt">EAp</span> e1&#39; e2&#39;)
  <span class="kw">where</span>
  (ns1, scs1, e1&#39;) <span class="fu">=</span> collectSCs&#39; ns e1
  (ns2, scs2, e2&#39;) <span class="fu">=</span> collectSCs&#39; ns1 e2
collectSCs&#39; ns (<span class="dt">ELam</span> args body) <span class="fu">=</span>
  (ns2, (name, args, body&#39;) <span class="fu">:</span> bodySCs, <span class="dt">EConst</span> (<span class="dt">CFun</span> name))
  <span class="kw">where</span>
  (ns1, bodySCs, body&#39;) <span class="fu">=</span> collectSCs&#39; ns body
  (ns2, name) <span class="fu">=</span> newName ns1 <span class="st">&quot;SC&quot;</span>
collectSCs&#39; ns (<span class="dt">ELet</span> isRec defns body) <span class="fu">=</span>
  (ns2, scs, <span class="dt">ELet</span> isRec defns&#39; body&#39;)
  <span class="kw">where</span>
  (ns1, bodySCs, body&#39;) <span class="fu">=</span> collectSCs&#39; ns body
  ((ns2, scs), defns&#39;) <span class="fu">=</span> mapAccumL collectSCs&#39;&#39; (ns1, bodySCs) defns

  collectSCs&#39;&#39; (ns, scs) (name, rhs) <span class="fu">=</span>
    ((ns1, scs <span class="fu">++</span> scs&#39;), (name, rhs&#39;))
    <span class="kw">where</span>
    (ns1, scs&#39;, rhs&#39;) <span class="fu">=</span> collectSCs&#39; ns rhs</code></pre></div>
<p>The code is rather complex compared to what it actually does. The only place where interest things happen is lambda abstractions. It replaces lambda abstractions by names and return supercombinators.</p>
<p>The code is complex because it violates the most important software engineering principle: <em>separation of concerns</em>. <code>collectSCs</code> contains at least three orthogonal concerns:</p>
<ol style="list-style-type: decimal">
<li>Generation of fresh names</li>
<li>Accumulation of supercombinatros</li>
<li>Transformation of expressions</li>
</ol>
<h1 id="organize-code-using-monads">Organize code using monads</h1>
<p>Monads are great tools to separate concerns. For example, <code>Reader</code> monad helps us get rid of an extra argument used to pass a context. <code>Writer</code> monad frees us from the agony of returning the accumulated results in every function.</p>
<p>So let’s separate our concerns in <code>collectSCs</code>.</p>
<ol style="list-style-type: decimal">
<li><code>Supply</code> monad for fresh name generation (it’s a <code>State</code> monad in disguise)</li>
<li><code>Writer</code> monad for accumulation of supercombinators</li>
</ol>
<p>Because we need to compose two different monads, we use the monad transformer <code>SupplyT</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Collector</span> a <span class="fu">=</span> <span class="dt">SupplyT</span> (<span class="dt">Writer</span> [<span class="dt">SCDefn</span>]) a

<span class="ot">collectSCs ::</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> [<span class="dt">SCDefn</span>]
collectSCs e <span class="fu">=</span> (<span class="st">&quot;$main&quot;</span>, [], e&#39;) <span class="fu">:</span> scs
  <span class="kw">where</span>
  (e&#39;, scs) <span class="fu">=</span> runWriter <span class="fu">$</span> evalSupplyT <span class="dv">0</span> (collectSCs&#39; e)

<span class="ot">collectSCs&#39; ::</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> <span class="dt">Collector</span> <span class="dt">Expression</span>
collectSCs&#39; (<span class="dt">EConst</span> k) <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">EConst</span> k
collectSCs&#39; (<span class="dt">EVar</span> v) <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">EVar</span> v
collectSCs&#39; (<span class="dt">EAp</span> e1 e2) <span class="fu">=</span> <span class="kw">do</span>
  e1&#39; <span class="ot">&lt;-</span> collectSCs&#39; e1
  e2&#39; <span class="ot">&lt;-</span> collectSCs&#39; e2
  return <span class="fu">$</span> <span class="dt">EAp</span> e1&#39; e2&#39;
collectSCs&#39; (<span class="dt">ELam</span> args body) <span class="fu">=</span> <span class="kw">do</span>
  name <span class="ot">&lt;-</span> freshName
  body&#39; <span class="ot">&lt;-</span> collectSCs&#39; body
  collect (name, args, body&#39;)
  return <span class="fu">$</span> <span class="dt">EConst</span> (<span class="dt">CFun</span> name)
collectSCs&#39; (<span class="dt">ELet</span> isRec defns body) <span class="fu">=</span> <span class="kw">do</span>
  body&#39; <span class="ot">&lt;-</span> collectSCs&#39; body
  defns&#39; <span class="ot">&lt;-</span> traverse (\(name, defn) <span class="ot">-&gt;</span> (name,) <span class="fu">&lt;$&gt;</span> collectSCs&#39; defn) defns
  return <span class="fu">$</span> <span class="dt">ELet</span> isRec defns&#39; body&#39;

<span class="ot">collect ::</span> <span class="dt">SCDefn</span> <span class="ot">-&gt;</span> <span class="dt">Collector</span> ()
collect defn <span class="fu">=</span> tell [defn]</code></pre></div>
<p>We can see that the resulting code is much more readable by removing all the clutters that not not essential to the core logic.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Fri, 23 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-23-organize-code-using-monads.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Pattern Synonyms</title>
    <link>http://kseo.github.io//posts/2016-12-22-pattern-synonyms.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 22, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/GHC%20extension.html">GHC extension</a>, <a href="/tags/PatternSynonyms.html">PatternSynonyms</a>
      
  </div>

<p>(<a href="https://www.reddit.com/r/haskell/comments/5jq9gi/kwangs_haskell_blog_pattern_synonyms/">Reddit discussion</a>)</p>
<p><a href="https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms">Pattern synonyms</a> allow us give names to pattern matches. It is a relatively new GHC extension which was first introduced in GHC 7.8 and further enhanced in GHC 8.0. In this post, I will show you an usage of pattern synonyms with a practical example.</p>
<p>Our assignment is to create a compiler for a toy functional language. We’ve already finished writing the parser and the type checker. It uses a small IR based on lambda calculus. Our next plan is to transform this IR into SK combinators for execution on the graph reduction machine.</p>
<p>Here’s the datatype of our IR:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="dt">Ap</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Lambda</span> <span class="dt">VarId</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Fun</span> <span class="dt">FunId</span>
         <span class="fu">|</span> <span class="dt">Var</span> <span class="dt">VarId</span>
         <span class="fu">|</span> <span class="dt">Int</span> <span class="dt">Int</span></code></pre></div>
<p>The SK compilation scheme is taken from Simon Peyton Jones’s <a href="https://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/">The Implementation of Functional Programming Languages</a>. (You don’t need to understand how this actually works. Interested readers are referred to SPJ’s book.)</p>
<pre><code>C[e] compiles e to SK combinators

C[e1 e2] = C[e1] C[e2]
C[\x.e] = A x [C[e]]
C[cv] = cv

A x [f] abstracts x from f

A x [f1 f2] = S (A x [f1]) (A x [f2])
A x [x] = I
A x [cv] = K cv</code></pre>
<p>This compilation scheme can be succinctly implemented in Haskell using pattern matches on <code>Exp</code> because the scheme uses the data constructors of <code>Exp</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">compile ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
compile (<span class="dt">Ap</span> e1 e2) <span class="fu">=</span> <span class="dt">Ap</span> (compile e1) (compile e2)
compile (<span class="dt">Lambda</span> v e) <span class="fu">=</span> abstract v (compile e)
compile cv <span class="fu">=</span> cv

<span class="ot">abstract ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
abstract x (<span class="dt">Ap</span> f1 f2) <span class="fu">=</span> (abstract x f1) (abstract x f2)
abstract x (<span class="dt">Var</span> v) <span class="fu">|</span> x <span class="fu">==</span> v <span class="fu">=</span> i
abstract x (<span class="dt">Fun</span> v) <span class="fu">|</span> x <span class="fu">==</span> v <span class="fu">=</span> i
abstract _ cv <span class="fu">=</span> k cv

<span class="ot">s ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
s f g <span class="fu">=</span> <span class="dt">Ap</span> (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;S&quot;</span>) f ) g

<span class="ot">k ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
k c <span class="fu">=</span> <span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;K&quot;</span>) c

<span class="ot">i ::</span> <span class="dt">Exp</span>
i <span class="fu">=</span> <span class="dt">Fun</span> <span class="st">&quot;I&quot;</span></code></pre></div>
<p>So far so good, but we realized that this basic compilation algorithm tends to produce large combinator expressions. SPJ suggests that we can improve the scheme by introducing additional combinators <code>B</code> and <code>C</code>.</p>
<p>Reduction rules:</p>
<pre><code>B f g x = f (g x)
C f g x = f x g</code></pre>
<p>Optimization rules:</p>
<pre><code>S (K p) (K q) = K (p q)
S (K p) I = p
S (K p) q = B p q
S p (K q) = C p q</code></pre>
<p>The optimization algorithm can be implemented as pattern matches on <code>Exp</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">optimize ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
optimize (<span class="dt">Ap</span> (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;S&quot;</span>) (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;K&quot;</span>) p)) (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;K&quot;</span>) q)) <span class="fu">=</span> k (<span class="dt">Ap</span> p q)
optimize (<span class="dt">Ap</span> (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;S&quot;</span>) (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;K&quot;</span>) p)) (<span class="dt">Fun</span> <span class="st">&quot;I&quot;</span>)) <span class="fu">=</span> p
optimize (<span class="dt">Ap</span> (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;S&quot;</span>) (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;K&quot;</span>) p)) q) <span class="fu">=</span> b p q
optimize (<span class="dt">Ap</span> (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;S&quot;</span>) p) (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;K&quot;</span>) q)) <span class="fu">=</span> c p q
optimize x <span class="fu">=</span> x</code></pre></div>
<p>Unfortunately, this time the code is very complicated because <code>S</code>, <code>K</code> and <code>I</code> are not the data constructors of <code>Exp</code>. We have to sprinkle <code>Ap</code> and <code>Fun</code> all over to represent <code>S</code>, <code>K</code> and <code>I</code> combinators.</p>
<p>Can we improve it? As you might have expected, GHC’s <code>PatternSynonyms</code> extension is the rescue! It lets us make synonyms for complicated patterns like these. We can define <code>S</code>, <code>K</code> and <code>I</code> as pattern synonyms and use them as if they were data constructors.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pattern <span class="dt">S</span> p q <span class="fu">=</span> <span class="dt">Ap</span> (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;S&quot;</span>) p) q
pattern <span class="dt">K</span> p <span class="fu">=</span> <span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;K&quot;</span>) p
pattern <span class="dt">I</span> <span class="fu">=</span> <span class="dt">Fun</span> <span class="st">&quot;I&quot;</span></code></pre></div>
<p>With the help of these pattern synonyms, we can rewrite <code>optimize</code> function compactly.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">optimize ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
optimize (<span class="dt">S</span> (<span class="dt">K</span> p) (<span class="dt">K</span> q)) <span class="fu">=</span> k (<span class="dt">Ap</span> p q)
optimize (<span class="dt">S</span> (<span class="dt">K</span> p) <span class="dt">I</span>) <span class="fu">=</span> p
optimize (<span class="dt">S</span> (<span class="dt">K</span> p) q) <span class="fu">=</span> b p q
optimize (<span class="dt">S</span> p (<span class="dt">K</span> q)) <span class="fu">=</span> c p q
optimize x <span class="fu">=</span> x</code></pre></div>
<p>Compare the code with the optimization rules. Now they look almost the same!</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Thu, 22 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-22-pattern-synonyms.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>foldl vs foldl'</title>
    <link>http://kseo.github.io//posts/2016-12-21-foldl-vs-foldl%27.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 21, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/fold.html">fold</a>, <a href="/tags/recursion.html">recursion</a>
      
  </div>

<p>Chris Allen <a href="http://lorepub.com/post/2016-12-17-Haskell-Pitfalls">mentioned</a> <code>foldl</code> as one of the newbie traps in Haskell.</p>
<blockquote>
<p>foldl’ is always what you want, don’t use foldl!</p>
</blockquote>
<p>Because <code>foldl</code> always has to examine the whole list, there is no reason to make it lazy. It just uses more memory to do the same thing as <code>foldl'</code>.</p>
<p><a href="http://book.realworldhaskell.org/read/functional-programming.html">Real World Haskell</a> also recommends using <code>foldl'</code> instead of <code>foldl</code>.</p>
<blockquote>
<p>Due to the thunking behavior of foldl, it is wise to avoid this function in real programs: even if it doesn’t fail outright, it will be unnecessarily inefficient. Instead, import Data.List and use foldl’</p>
</blockquote>
<p><a href="https://wiki.haskell.org/Foldr_Foldl_Foldl&#39;#Foldl">Haskell Wiki</a> compares <code>foldr</code>, <code>foldl</code> and <code>foldl'</code> and recommends using either <code>foldr</code> or <code>foldl'</code>.</p>
<blockquote>
<p>foldl’ is the more efficient way to arrive at that result because it doesn’t build a huge thunk.</p>
</blockquote>
<p>But here comes a question. If <code>foldl'</code> is almost always better than <code>foldl</code>, why do we have <code>foldl</code> anyway? It makes sense only when the combining function is non-strict in its <em>first</em> argument. (The example is taken from the Haskell Wiki.)</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(?) ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
_ <span class="fu">?</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
x <span class="fu">?</span> y <span class="fu">=</span> x<span class="fu">*</span>y

<span class="ot">list ::</span> [<span class="dt">Int</span>]
list <span class="fu">=</span> [<span class="dv">2</span>,<span class="dv">3</span>,undefined,<span class="dv">5</span>,<span class="dv">0</span>]

okey <span class="fu">=</span> foldl (<span class="fu">?</span>) <span class="dv">1</span> list
boom <span class="fu">=</span> foldl&#39; (<span class="fu">?</span>) <span class="dv">1</span> list</code></pre></div>
<p>Evaluation of <code>okey</code>:</p>
<pre><code>okey --&gt;
foldl (?) 1 [2,3,undefined,5,0] --&gt;
foldl (?) (1 ? 2) [3,undefined,5,0] --&gt;
foldl (?) ((1 ? 2) ? 3) [undefined,5,0] --&gt;
foldl (?) (((1 ? 2) ? 3) ? undefined) [5,0] --&gt;
foldl (?) ((((1 ? 2) ? 3) ? undefined) ? 5) [0] --&gt;
foldl (?) (((((1 ? 2) ? 3) ? undefined) ? 5) ? 0) [] --&gt;
((((1 ? 2) ? 3) ? undefined) ? 5) ? 0 --&gt;
0</code></pre>
<p>Evaluation of <code>boom</code>:</p>
<pre><code>boom --&gt;
foldl&#39; (?) 1 [2,3,undefined,5,0] --&gt;
    1 ? 2 --&gt; 2
foldl&#39; (?) 2 [3,undefined,5,0] --&gt;
    2 ? 3 --&gt; 6
foldl&#39; (?) 6 [undefined,5,0] --&gt;
    6 ? undefined --&gt;
*** Exception: Prelude.undefined</code></pre>
<p>This example actually shows why <code>foldl</code> is so useless because it is hard to find a function which is non-strict in its <em>first</em> argument.</p>
<p>Many functions in Haskell are non-strict in its <em>second</em> argument and this is why <code>foldr</code> is useful. For example, <code>(&amp;&amp;)</code> is non-strict in its <em>second</em> argument and <code>and</code> can be efficiently defined using <code>foldr</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&amp;&amp;)                    ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="dt">True</span>  <span class="fu">&amp;&amp;</span> x              <span class="fu">=</span>  x
<span class="dt">False</span> <span class="fu">&amp;&amp;</span> _              <span class="fu">=</span>  <span class="dt">False</span>

and<span class="ot">                     ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
and                     <span class="fu">=</span>  foldr (<span class="fu">&amp;&amp;</span>) <span class="dt">True</span></code></pre></div>
<p>In conclusion, we should use <code>foldl'</code> by default unless we have a very compelling reason to use <code>foldl</code> instead.</p>
<p>But, wait! Let’s check how our beloved <code>sum</code> function is written. Because <code>(+)</code> is strict in both of its arguments, <code>foldl'</code> should have been used. But here’s <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.List.html#sum">the actual code</a> taken from the <code>base</code> package.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sum<span class="ot">                     ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
<span class="ot">{-# INLINE sum #-}</span>
sum                     <span class="fu">=</span>  foldl (<span class="fu">+</span>) <span class="dv">0</span></code></pre></div>
<p>OMG! There is a historical accident here. Interested readers are referred to <a href="http://www.well-typed.com/blog/90/">Fixing foldl</a> article from Well-Typed.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Wed, 21 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-21-foldl-vs-foldl%27.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Non empty list</title>
    <link>http://kseo.github.io//posts/2016-12-20-non-empty-list.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 20, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/non%20empty%20list.html">non empty list</a>, <a href="/tags/prelude.html">prelude</a>
      
  </div>

<p>Haskell is well known for its safety. A well-typed Haskell program never goes wrong. Is it true? Unfortunately, no. The type system of Haskell is great and it does catch many bugs at compile time, but Haskell’s <code>Prelude</code> is full of partial functions.</p>
<p>For example, <code>head</code> and <code>tail</code> functions of <code>Data.List</code> throws an error when an empty list is given as an argument.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> head []
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> Prelude.head<span class="fu">:</span> empty list</code></pre></div>
<p>That’s why we have a separate <a href="https://hackage.haskell.org/package/safe">safe</a> package which provides alternative safe functions such as <a href="https://www.stackage.org/haddock/lts-7.12/safe-0.3.10/Safe.html#v:headMay">headMay</a> and <a href="https://www.stackage.org/haddock/lts-7.12/safe-0.3.10/Safe.html#v:tailMay">tailMay</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> headMay []
<span class="dt">Nothing</span>
<span class="ot">it ::</span> <span class="dt">Maybe</span> a</code></pre></div>
<p>What if you know that your list is never empty? Checking the return value of <code>headMay</code> or <code>tailMay</code> soon becomes cumbersome.</p>
<p>Fortunately, Haskell <code>Prelude</code> provides <a href="https://www.stackage.org/haddock/lts-7.12/base-4.9.0.0/Data-List-NonEmpty.html">NonEmpty</a> data type which guarantees that the list is not empty. You can use <code>head</code> and <code>tail</code> functions without worrying about the partiality. It also provides many list functions such as <code>map</code>, <code>reverse</code> and <code>length</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:|</span>, <span class="fu">&lt;|</span>
<span class="kw">data</span> <span class="dt">NonEmpty</span> a <span class="fu">=</span> a <span class="fu">:|</span> [a]

head<span class="ot"> ::</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Tue, 20 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-20-non-empty-list.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Encoding existentials</title>
    <link>http://kseo.github.io//posts/2016-12-19-encoding-existentials.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 19, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/existential%20type.html">existential type</a>, <a href="/tags/Church%20encoding.html">Church encoding</a>
      
  </div>

<p>Existential types are important because <a href="http://theory.stanford.edu/~jcm/papers/mitch-plotkin-88.pdf">Abstract Types Have Existential Type</a>. Haskell supports existential types though a GHC extension named <code>ExistentialQuantification</code>.</p>
<p>Here’s is an example. This code below creates an abstract data type named <code>Obj</code>. Clients of <code>Obj</code> can use only <code>show</code> function because clients can’t know the hidden representation of <code>Obj</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span>

<span class="kw">data</span> <span class="dt">Obj</span> <span class="fu">=</span> forall a<span class="fu">.</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Obj</span> a

<span class="ot">obj1 ::</span> <span class="dt">Obj</span>
obj1 <span class="fu">=</span> <span class="dt">Obj</span> <span class="st">&quot;hello&quot;</span>

<span class="ot">obj2 ::</span> <span class="dt">Obj</span>
obj2 <span class="fu">=</span> <span class="dt">Obj</span> <span class="dv">1</span>

<span class="ot">app ::</span> <span class="dt">Obj</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
app (<span class="dt">Obj</span> x) <span class="fu">=</span> show x</code></pre></div>
<p>The code is simple, but confusing because it uses <em>forall</em> instead of <em>exists</em> quantifier. It becomes more clear when we rewrite the definition of <code>Obj</code> in GADT syntax.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>

<span class="kw">data</span> <span class="dt">Obj</span> <span class="kw">where</span>
  <span class="dt">Obj</span><span class="ot"> ::</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Obj</span></code></pre></div>
<p>As the type variable <code>a</code> no longer appears on the right hand side, it is considered to be existentially quantified. Also you no longer need <code>ExistentialQuantification</code>. Existentials are subsumed by GADTs.</p>
<p>There is another way to encode existential types without <code>ExistentialQuantification</code>. Because an existential type is a pair of type and a value, we can use the <a href="https://en.wikipedia.org/wiki/Church_encoding">Church encoding</a> for a pair to represent existentials.</p>
<pre><code>{∃X,T} = ∀Y. (∀X. T→Y) → Y</code></pre>
<p>In Haskell, we need to enable <code>RankNTypes</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RankNTypes #-}</span>

<span class="kw">type</span> <span class="dt">Obj</span> <span class="fu">=</span> forall y<span class="fu">.</span> (forall x<span class="fu">.</span> (<span class="dt">Show</span> x) <span class="ot">=&gt;</span> x <span class="ot">-&gt;</span> y) <span class="ot">-&gt;</span> y

<span class="ot">obj ::</span> <span class="dt">Obj</span>
obj f <span class="fu">=</span> f <span class="st">&quot;hello&quot;</span>

<span class="ot">app ::</span> <span class="dt">Obj</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
app obj <span class="fu">=</span> obj (\x <span class="ot">-&gt;</span> show x)</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Mon, 19 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-19-encoding-existentials.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>

    </channel>
</rss>
