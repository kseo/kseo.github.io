<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Haskell for Pragmatic Programmers</title>
        <link>http://kseo.github.io/</link>
        <description><![CDATA[Kwang Yul Seo's Haskell Blog]]></description>
        <atom:link href="http://kseo.github.io//rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sun, 25 Dec 2016 00:00:00 UT</lastBuildDate>
        <item>
    <title>Type Isomorphism</title>
    <link>http://kseo.github.io//posts/2016-12-25-type-isomorphism.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 25, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/type%20isomorphism.html">type isomorphism</a>
      
  </div>

<p>Type isomorphisms are a general notion of conversion between types. We say that type <code>A</code> and <code>B</code> are isomorphic, if we have conversion functions <code>f :: A -&gt; B</code> and <code>g :: B -&gt; A</code> such that</p>
<pre><code>f . g = idB
g . f = idA</code></pre>
<p>Type isomorphisms imply that we can safely convert without loss of information between types.</p>
<h1 id="motivation">Motivation</h1>
<p>There always exist multiple types that can represent the same values we want to represent. The problem is that they are not compatible because the type system does not automatically recognize them as equal. So we might not be able to reuse the existing libraries as the types we use in our program are not compatible with the types these libraries use. Type isomorphisms provide wrapping/unwrapping functions that can safely convert between these types.</p>
<p>Type isomorphisms also help us understand various transformations used in equational reasoning and API design.</p>
<h1 id="basics">Basics</h1>
<p>Haskell programmers already use the type isomorphism to reason about programs. For example, we know that pair <code>(a,b)</code> is isomorphic to <code>(b,a)</code> because <code>swap</code> is the conversion function in both directions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">swap ::</span> (a,b) <span class="ot">-&gt;</span> (b,a)
swap (a, b) <span class="fu">=</span> (b, a)</code></pre></div>
<p>Another example of type isomorphism is <code>a</code> and <code>() -&gt; a</code>. We can define conversion functions as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> a <span class="ot">-&gt;</span> () <span class="ot">-&gt;</span> a
f <span class="fu">=</span> \x _ <span class="ot">-&gt;</span> x

<span class="ot">g ::</span> (() <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a
g k <span class="fu">=</span> k ()</code></pre></div>
<p>What about <code>a -&gt; ()</code>? This type is unsurprisingly isomorphic to <code>()</code> because <code>a -&gt; ()</code> type has only one inhabitant which discards the argument and returns <code>()</code>. Conversion functions are:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> (a <span class="ot">-&gt;</span> ()) <span class="ot">-&gt;</span> ()
f _ <span class="fu">=</span> ()

<span class="ot">g ::</span> () <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> ()
g <span class="fu">=</span> \_ _ <span class="ot">-&gt;</span> ()</code></pre></div>
<h1 id="currying-and-uncurrying">Currying and uncurrying</h1>
<p>In functional programming, <em>currying</em> transforms a function that takes multiple arguments via a pair, into a function that accepts the first argument of the pair, and returns a function that accepts the second argument, before returning the result. <em>uncurrying</em> performs transformation in the opposite direction.</p>
<p>Here are the types of <code>curry</code> and <code>uncurry</code> functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">curry<span class="ot"> ::</span> ((a, b) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c
uncurry<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a, b) <span class="ot">-&gt;</span> c</code></pre></div>
<p>From the signature of these functions, we can see that <code>(a, b) -&gt; c</code> and <code>a -&gt; b -&gt; c</code> are isomorphic by <code>curry</code> and <code>uncurry</code> functions.</p>
<h1 id="continuation">Continuation</h1>
<p><code>a</code> can be converted to <code>(a -&gt; r) -&gt; r</code> by CPS transformation. A CPS term can be converted back to the direct style by applying <code>id</code> function.</p>
<pre><code>{-# LANGUAGE RankNTypes #-}

f :: a -&gt; (a -&gt; r) -&gt; r
f a b = b a

g :: (forall r. (a -&gt; r) -&gt; r) -&gt; a
g a = a id</code></pre>
<p><code>RankNTypes</code> extension is necessary to represent the type of <code>g</code>.</p>
<h1 id="algebraic-data-types">Algebraic data types</h1>
<p>Every algebraic data type can be represented with combinations of <em>product</em> and <em>sum</em> types. This is why these types are called <em>algebraic data types</em>.</p>
<p>In Haskell, products are encoded by <code>(a, b)</code> and sums are encoded by <code>Either a b</code>. Thus an algebraic data type of Haskell is isomorphic to some combinations of <code>(a, b)</code> and <code>Either a b</code>. Let’s see a few examples.</p>
<p><code>Bool</code> is isomorphic to <code>Either () ()</code> because we can define conversion functions <code>f</code> and <code>g</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> () ()
f <span class="dt">True</span> <span class="fu">=</span> <span class="dt">Left</span> ()
f <span class="dt">False</span> <span class="fu">=</span> <span class="dt">Right</span> ()

<span class="ot">g ::</span> <span class="dt">Either</span> () () <span class="ot">-&gt;</span> <span class="dt">Bool</span>
g (<span class="dt">Left</span> ()) <span class="fu">=</span> <span class="dt">True</span>
g (<span class="dt">Right</span> ()) <span class="fu">=</span> <span class="dt">False</span></code></pre></div>
<p><code>Maybe a</code> is isomorphic to <code>Either a ()</code> or <code>Either () a</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> () a
f (<span class="dt">Just</span> x) <span class="fu">=</span> <span class="dt">Right</span> x
f <span class="dt">Nothing</span> <span class="fu">=</span> <span class="dt">Left</span> ()

<span class="ot">g ::</span> <span class="dt">Either</span> () a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a
g (<span class="dt">Left</span> ()) <span class="fu">=</span> <span class="dt">Nothing</span>
g (<span class="dt">Right</span> x) <span class="fu">=</span> <span class="dt">Just</span> x</code></pre></div>
<h1 id="playing-with-type-isomorphism">Playing with type isomorphism</h1>
<p><em>unfold</em> is the categorical dual of <em>fold</em>. It means we can get the type of <code>unfold</code> by reversing arrows of <code>fold</code>.</p>
<p>Here are the type signatures of <code>foldr</code> and <code>unfoldr</code> taken from the <code>base</code> library.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b
<span class="ot">unfoldr ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, b)) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> [a])</code></pre></div>
<p>It is not obvious how <code>foldr</code> and <code>unfoldr</code> are related. But we can apply the types isomorphism we’ve learned to derive the type of <code>unfoldr</code> from <code>foldr</code>.</p>
<pre><code>(a → b → b) → b → ([a] → b)
=== ((a, b) → b) → b → ([a] → b)
=== ((a, b) → b) → (() -&gt; b) → ([a] → b)
=== (((a, b) → b), (() -&gt; b)) → ([a] → b)
=== ((Either (a, b) ()) → b) → ([a] → b)
=== (Maybe (a, b) -&gt; b) → ([a] → b)</code></pre>
<p>We used the following type isomorphisms:</p>
<ul>
<li><code>a -&gt; b -&gt; c ~= (a, b) -&gt; c</code></li>
<li><code>a ~= () -&gt; a</code></li>
<li><code>((a -&gt; c), (b -&gt; c)) ~= Either a b -&gt; c</code></li>
<li><code>Either a () ~= Maybe a</code>.</li>
</ul>
<p>Finally, by reversing the arrows of <code>foldr</code>, we get <code>unfoldr</code>.</p>
<pre><code>foldr   :: (Maybe (a, b) -&gt; b           ) -&gt; ([a] -&gt; b  )
unfoldr :: (b            -&gt; Maybe (a, b)) -&gt; (b   -&gt; [a])</code></pre>
<p>Interested readers might want to take a look at my previous post <a href="http://kseo.github.io/posts/2016-12-12-unfold-and-fold.html">unfold and fold</a> and Conal Elliott’s <a href="http://conal.net/talks/folds-and-unfolds.pdf">Folds and unfolds all around us</a> for the details.</p>
<h1 id="existentials">Existentials</h1>
<p><code>{∃X,T}</code> and <code>∀Y. (∀X. T→Y) → Y</code> are isomorphic types. My previous post <a href="http://kseo.github.io/posts/2016-12-19-encoding-existentials.html">Encoding existentials</a> shows how we can encode existential types using only <code>RankNTypes</code> and <em>forall</em> quantifier.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Sun, 25 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-25-type-isomorphism.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Reader monad and SKI combinators</title>
    <link>http://kseo.github.io//posts/2016-12-24-reader-monad-and-ski-combinators.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 24, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/reader%20monad.html">reader monad</a>, <a href="/tags/ski%20combinator.html">ski combinator</a>
      
  </div>

<p>In this post, I am going to show you the relationship between the reader monad and the SKI combinators.</p>
<h1 id="reader-monad">Reader monad</h1>
<p>The reader monad encapsulates computations which read values from a shared environment. Here’s the definition of our beloved <code>Reader</code> monad.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Reader</span> r a <span class="fu">=</span> <span class="dt">Reader</span> {
<span class="ot">  runReader ::</span> r <span class="ot">-&gt;</span> a
}

<span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Reader</span> r ) <span class="kw">where</span>
  return a <span class="fu">=</span> <span class="dt">Reader</span> <span class="fu">$</span> \_ <span class="ot">-&gt;</span> a
  m <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> <span class="dt">Reader</span> <span class="fu">$</span> \r <span class="ot">-&gt;</span> runReader (k (runReader m r )) r</code></pre></div>
<p>There are actually two instances of the reader monad in Haskell. The function monad <code>(-&gt;) r</code> is also a reader monad. The definition of the function monad is just like the <code>Reader</code> monad, but without <code>newtype</code> wrapping and unwrapping.</p>
<pre><code>instance Monad ((-&gt;) r ) where
  return a = \_ -&gt; a
  m &gt;&gt;= k = \r -&gt; k (m r ) r</code></pre>
<p>From now on, I will use the function monad definition because it makes our presentation more clear. But remember these two monad definitions are isomorphic.</p>
<h1 id="ski-combinators">SKI combinators</h1>
<p><a href="https://en.wikipedia.org/wiki/Combinatory_logic">Combinatory logic</a> is a formal system without the need for variables. It was introduced by Moses Schönfinkel and Haskell Curry.</p>
<p>The SKI calculus is a combinatory logic with three combinators S, K and I. It is a universal system as all operations in lambda calculus can be encoded via <em>abstraction elimination</em> into the SKI calculus.</p>
<p>The Haskell definition of <code>s</code>, <code>k</code> and <code>i</code> are as follows:</p>
<pre><code>k :: a -&gt; b -&gt; a
k x y = x

s :: (a -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
s x y z = (x z) (y z)

i :: a -&gt; a
i x = x</code></pre>
<p>From the types of these combinators, we can see that <code>k</code> is Haskell’s <code>const</code> function and <code>i</code> is Haskell’s <code>id</code> function.</p>
<p>Technically speaking, we don’t need the I combinator to encode lambda calculus into the SKI combinators because we can encode I in terms of S and K. I is just for convenience.</p>
<h1 id="relationship">Relationship</h1>
<p>So what’s the relationship between the reader monad and the SKI combinators? Let’s look at the types of the reader monad more closely.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">return<span class="ot"> ::</span> a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> a
<span class="ot">(&gt;&gt;=) ::</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> b</code></pre></div>
<p>Can you see the similarity to the types of the combinator <code>k</code> and <code>s</code>? The function <code>return</code> is the same as <code>k</code>, but the function <code>(&gt;&gt;=)</code> is somewhat similar but not exactly the same as <code>s</code>.</p>
<p>Let’s see the <em>applicative functor</em> definition of the reader monad instead.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pure<span class="ot"> ::</span> a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> a
<span class="ot">(&lt;*&gt;) ::</span> (r <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> b</code></pre></div>
<p>Now we can see that the type of <code>(&lt;*&gt;)</code> is the same to the type of <code>s</code>. Because these functions are fully polymorphic, we don’t need to check the definition of these functions to see if they are really equivalent.</p>
<p><a href="http://www.staff.city.ac.uk/~ross/papers/Applicative.html">Conor McBride and Ross Paterson’s paper</a> also mentions this relationship briefly.</p>
<h1 id="conclusion">Conclusion</h1>
<p>We’ve just discovered that <code>k</code> and <code>s</code> combinators of SKI calculus correspond to <code>pure</code> and <code>(&lt;*&gt;)</code> functions of the reader monad. Because we can encode any lambda calculus term into SKI calculus, we can encode any lambda calculus term into the reader monad too! Amazing, isn’t it?</p>
<h1 id="references">References</h1>
<ol style="list-style-type: decimal">
<li><a href="https://themonadreader.wordpress.com/2011/01/09/issue-17/">The Monad.Reader Issue 17: The Reader Monad and Abstraction Elimination</a></li>
<li><a href="http://brandon.si/code/do-applicative-functors-generalize-the-s-k-combinators/">Do Applicative Functors Generalize the S &amp; K Combinators?</a></li>
</ol>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Sat, 24 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-24-reader-monad-and-ski-combinators.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Organize code using monads</title>
    <link>http://kseo.github.io//posts/2016-12-23-organize-code-using-monads.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 23, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/monad.html">monad</a>, <a href="/tags/monad%20transformer.html">monad transformer</a>, <a href="/tags/lambda%20lifting.html">lambda lifting</a>
      
  </div>

<p>Novice Haskell programmers think that monads are only for IO and stateful computations. But experienced Haskell programmers use monads to better structure their programs.</p>
<p>In this blog post, I am going to show you how we can better organize our code using monads.</p>
<h1 id="motivating-example-lambda-lifting">Motivating example: Lambda lifting</h1>
<p><em>Lambda lifting</em> is a compiler transformation which eliminates all free variables from function definitions. It is an important step in a lazy functional language because it greatly simplifies evaluation on the graph reduction machine.</p>
<p>In his <a href="https://www.microsoft.com/en-us/research/publication/a-modular-fully-lazy-lambda-lifter-in-haskell/">paper</a>, Simon Peyton Jones describes how to perform lambda lifting in a modular fashion. The lambda lifter works in three steps:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | freeVars: Annotate every node in the expression with its free variables.</span>
<span class="ot">freeVars ::</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> <span class="dt">AnnExpr</span> <span class="dt">Name</span> (<span class="dt">Set</span> <span class="dt">Name</span>)

<span class="co">-- | Abstract the free variables from each lambda abstraction, replacing the lambda abstraction with the application of the new abstraction.</span>
<span class="ot">abstract ::</span> <span class="dt">AnnExpr</span> <span class="dt">Name</span> (<span class="dt">Set</span> <span class="dt">Name</span>) <span class="ot">-&gt;</span> <span class="dt">Expression</span>

<span class="co">-- | Give a unique name to each supercombinator and collect all the supercombinator definitions.</span>
<span class="ot">collectSCs ::</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> [<span class="dt">SCDefn</span>]</code></pre></div>
<p><code>lambdaLift</code> is the composition of these three functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lambdaLift ::</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> [<span class="dt">SCDefn</span>]
lambdaLift <span class="fu">=</span> collectSCs <span class="fu">.</span> abstract <span class="fu">.</span> freeVars</code></pre></div>
<p>I am not going to explain the details of these steps in this post. Interested readers are referred to SPJ’s <a href="https://www.microsoft.com/en-us/research/publication/a-modular-fully-lazy-lambda-lifter-in-haskell/">paper</a> and <a href="https://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/">book</a>.</p>
<p>Instead, let’s dive into the last step and see how <code>collectSCs</code> is actually implemented.</p>
<h1 id="collecting-supercombinators">Collecting supercombinators</h1>
<p><code>collectSCs</code> is defined in terms of a helper function named <code>collecSC'</code> which returns both the collection of supercombinators it has found and the transformed expression. It also carries around a <em>name supply</em> as an argument and returns the depleted supply as a result because it needs to generate fresh names for supercombinators.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Gives a unique name to each supercombinator, collects all the</span>
<span class="co">-- supercombinator definitions into a single list, and introduce the</span>
<span class="co">-- $main supercombinator definition.</span>
<span class="ot">collectSCs ::</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> [<span class="dt">SCDefn</span>]
collectSCs e <span class="fu">=</span> (<span class="st">&quot;$main&quot;</span>, [], e&#39;) <span class="fu">:</span> scs
  <span class="kw">where</span>
  (_, scs, e&#39;) <span class="fu">=</span> collectSCs&#39; initialNameSupply e

<span class="ot">collectSCs&#39; ::</span> <span class="dt">NameSupply</span> <span class="ot">-&gt;</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> (<span class="dt">NameSupply</span>, [<span class="dt">SCDefn</span>], <span class="dt">Expression</span>)
collectSCs&#39; ns (<span class="dt">EConst</span> k) <span class="fu">=</span> (ns, [], <span class="dt">EConst</span> k)
collectSCs&#39; ns (<span class="dt">EVar</span> v) <span class="fu">=</span> (ns, [], <span class="dt">EVar</span> v)
collectSCs&#39; ns (<span class="dt">EAp</span> e1 e2) <span class="fu">=</span>
  (ns2, scs1 <span class="fu">++</span> scs2, <span class="dt">EAp</span> e1&#39; e2&#39;)
  <span class="kw">where</span>
  (ns1, scs1, e1&#39;) <span class="fu">=</span> collectSCs&#39; ns e1
  (ns2, scs2, e2&#39;) <span class="fu">=</span> collectSCs&#39; ns1 e2
collectSCs&#39; ns (<span class="dt">ELam</span> args body) <span class="fu">=</span>
  (ns2, (name, args, body&#39;) <span class="fu">:</span> bodySCs, <span class="dt">EConst</span> (<span class="dt">CFun</span> name))
  <span class="kw">where</span>
  (ns1, bodySCs, body&#39;) <span class="fu">=</span> collectSCs&#39; ns body
  (ns2, name) <span class="fu">=</span> newName ns1 <span class="st">&quot;SC&quot;</span>
collectSCs&#39; ns (<span class="dt">ELet</span> isRec defns body) <span class="fu">=</span>
  (ns2, scs, <span class="dt">ELet</span> isRec defns&#39; body&#39;)
  <span class="kw">where</span>
  (ns1, bodySCs, body&#39;) <span class="fu">=</span> collectSCs&#39; ns body
  ((ns2, scs), defns&#39;) <span class="fu">=</span> mapAccumL collectSCs&#39;&#39; (ns1, bodySCs) defns

  collectSCs&#39;&#39; (ns, scs) (name, rhs) <span class="fu">=</span>
    ((ns1, scs <span class="fu">++</span> scs&#39;), (name, rhs&#39;))
    <span class="kw">where</span>
    (ns1, scs&#39;, rhs&#39;) <span class="fu">=</span> collectSCs&#39; ns rhs</code></pre></div>
<p>The code is rather complex compared to what it actually does. The only place where interest things happen is lambda abstractions. It replaces lambda abstractions by names and return supercombinators.</p>
<p>The code is complex because it violates the most important software engineering principle: <em>separation of concerns</em>. <code>collectSCs</code> contains at least three orthogonal concerns:</p>
<ol style="list-style-type: decimal">
<li>Generation of fresh names</li>
<li>Accumulation of supercombinatros</li>
<li>Transformation of expressions</li>
</ol>
<h1 id="organize-code-using-monads">Organize code using monads</h1>
<p>Monads are great tools to separate concerns. For example, <code>Reader</code> monad helps us get rid of an extra argument used to pass a context. <code>Writer</code> monad frees us from the agony of returning the accumulated results in every function.</p>
<p>So let’s separate our concerns in <code>collectSCs</code>.</p>
<ol style="list-style-type: decimal">
<li><code>Supply</code> monad for fresh name generation (it’s a <code>State</code> monad in disguise)</li>
<li><code>Writer</code> monad for accumulation of supercombinators</li>
</ol>
<p>Because we need to compose two different monads, we use the monad transformer <code>SupplyT</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Collector</span> a <span class="fu">=</span> <span class="dt">SupplyT</span> (<span class="dt">Writer</span> [<span class="dt">SCDefn</span>]) a

<span class="ot">collectSCs ::</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> [<span class="dt">SCDefn</span>]
collectSCs e <span class="fu">=</span> (<span class="st">&quot;$main&quot;</span>, [], e&#39;) <span class="fu">:</span> scs
  <span class="kw">where</span>
  (e&#39;, scs) <span class="fu">=</span> runWriter <span class="fu">$</span> evalSupplyT <span class="dv">0</span> (collectSCs&#39; e)

<span class="ot">collectSCs&#39; ::</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> <span class="dt">Collector</span> <span class="dt">Expression</span>
collectSCs&#39; (<span class="dt">EConst</span> k) <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">EConst</span> k
collectSCs&#39; (<span class="dt">EVar</span> v) <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">EVar</span> v
collectSCs&#39; (<span class="dt">EAp</span> e1 e2) <span class="fu">=</span> <span class="kw">do</span>
  e1&#39; <span class="ot">&lt;-</span> collectSCs&#39; e1
  e2&#39; <span class="ot">&lt;-</span> collectSCs&#39; e2
  return <span class="fu">$</span> <span class="dt">EAp</span> e1&#39; e2&#39;
collectSCs&#39; (<span class="dt">ELam</span> args body) <span class="fu">=</span> <span class="kw">do</span>
  name <span class="ot">&lt;-</span> freshName
  body&#39; <span class="ot">&lt;-</span> collectSCs&#39; body
  collect (name, args, body&#39;)
  return <span class="fu">$</span> <span class="dt">EConst</span> (<span class="dt">CFun</span> name)
collectSCs&#39; (<span class="dt">ELet</span> isRec defns body) <span class="fu">=</span> <span class="kw">do</span>
  body&#39; <span class="ot">&lt;-</span> collectSCs&#39; body
  defns&#39; <span class="ot">&lt;-</span> traverse (\(name, defn) <span class="ot">-&gt;</span> (name,) <span class="fu">&lt;$&gt;</span> collectSCs&#39; defn) defns
  return <span class="fu">$</span> <span class="dt">ELet</span> isRec defns&#39; body&#39;

<span class="ot">collect ::</span> <span class="dt">SCDefn</span> <span class="ot">-&gt;</span> <span class="dt">Collector</span> ()
collect defn <span class="fu">=</span> tell [defn]</code></pre></div>
<p>We can see that the resulting code is much more readable by removing all the clutters that not not essential to the core logic.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Fri, 23 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-23-organize-code-using-monads.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Pattern Synonyms</title>
    <link>http://kseo.github.io//posts/2016-12-22-pattern-synonyms.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 22, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/GHC%20extension.html">GHC extension</a>, <a href="/tags/PatternSynonyms.html">PatternSynonyms</a>
      
  </div>

<p>(<a href="https://www.reddit.com/r/haskell/comments/5jq9gi/kwangs_haskell_blog_pattern_synonyms/">Reddit discussion</a>)</p>
<p><a href="https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms">Pattern synonyms</a> allow us give names to pattern matches. It is a relatively new GHC extension which was first introduced in GHC 7.8 and further enhanced in GHC 8.0. In this post, I will show you an usage of pattern synonyms with a practical example.</p>
<p>Our assignment is to create a compiler for a toy functional language. We’ve already finished writing the parser and the type checker. It uses a small IR based on lambda calculus. Our next plan is to transform this IR into SK combinators for execution on the graph reduction machine.</p>
<p>Here’s the datatype of our IR:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="dt">Ap</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Lambda</span> <span class="dt">VarId</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Fun</span> <span class="dt">FunId</span>
         <span class="fu">|</span> <span class="dt">Var</span> <span class="dt">VarId</span>
         <span class="fu">|</span> <span class="dt">Int</span> <span class="dt">Int</span></code></pre></div>
<p>The SK compilation scheme is taken from Simon Peyton Jones’s <a href="https://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/">The Implementation of Functional Programming Languages</a>. (You don’t need to understand how this actually works. Interested readers are referred to SPJ’s book.)</p>
<pre><code>C[e] compiles e to SK combinators

C[e1 e2] = C[e1] C[e2]
C[\x.e] = A x [C[e]]
C[cv] = cv

A x [f] abstracts x from f

A x [f1 f2] = S (A x [f1]) (A x [f2])
A x [x] = I
A x [cv] = K cv</code></pre>
<p>This compilation scheme can be succinctly implemented in Haskell using pattern matches on <code>Exp</code> because the scheme uses the data constructors of <code>Exp</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">compile ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
compile (<span class="dt">Ap</span> e1 e2) <span class="fu">=</span> <span class="dt">Ap</span> (compile e1) (compile e2)
compile (<span class="dt">Lambda</span> v e) <span class="fu">=</span> abstract v (compile e)
compile cv <span class="fu">=</span> cv

<span class="ot">abstract ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
abstract x (<span class="dt">Ap</span> f1 f2) <span class="fu">=</span> (abstract x f1) (abstract x f2)
abstract x (<span class="dt">Var</span> v) <span class="fu">|</span> x <span class="fu">==</span> v <span class="fu">=</span> i
abstract x (<span class="dt">Fun</span> v) <span class="fu">|</span> x <span class="fu">==</span> v <span class="fu">=</span> i
abstract _ cv <span class="fu">=</span> k cv

<span class="ot">s ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
s f g <span class="fu">=</span> <span class="dt">Ap</span> (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;S&quot;</span>) f ) g

<span class="ot">k ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
k c <span class="fu">=</span> <span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;K&quot;</span>) c

<span class="ot">i ::</span> <span class="dt">Exp</span>
i <span class="fu">=</span> <span class="dt">Fun</span> <span class="st">&quot;I&quot;</span></code></pre></div>
<p>So far so good, but we realized that this basic compilation algorithm tends to produce large combinator expressions. SPJ suggests that we can improve the scheme by introducing additional combinators <code>B</code> and <code>C</code>.</p>
<p>Reduction rules:</p>
<pre><code>B f g x = f (g x)
C f g x = f x g</code></pre>
<p>Optimization rules:</p>
<pre><code>S (K p) (K q) = K (p q)
S (K p) I = p
S (K p) q = B p q
S p (K q) = C p q</code></pre>
<p>The optimization algorithm can be implemented as pattern matches on <code>Exp</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">optimize ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
optimize (<span class="dt">Ap</span> (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;S&quot;</span>) (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;K&quot;</span>) p)) (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;K&quot;</span>) q)) <span class="fu">=</span> k (<span class="dt">Ap</span> p q)
optimize (<span class="dt">Ap</span> (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;S&quot;</span>) (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;K&quot;</span>) p)) (<span class="dt">Fun</span> <span class="st">&quot;I&quot;</span>)) <span class="fu">=</span> p
optimize (<span class="dt">Ap</span> (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;S&quot;</span>) (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;K&quot;</span>) p)) q) <span class="fu">=</span> b p q
optimize (<span class="dt">Ap</span> (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;S&quot;</span>) p) (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;K&quot;</span>) q)) <span class="fu">=</span> c p q
optimize x <span class="fu">=</span> x</code></pre></div>
<p>Unfortunately, this time the code is very complicated because <code>S</code>, <code>K</code> and <code>I</code> are not the data constructors of <code>Exp</code>. We have to sprinkle <code>Ap</code> and <code>Fun</code> all over to represent <code>S</code>, <code>K</code> and <code>I</code> combinators.</p>
<p>Can we improve it? As you might have expected, GHC’s <code>PatternSynonyms</code> extension is the rescue! It lets us make synonyms for complicated patterns like these. We can define <code>S</code>, <code>K</code> and <code>I</code> as pattern synonyms and use them as if they were data constructors.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pattern <span class="dt">S</span> p q <span class="fu">=</span> <span class="dt">Ap</span> (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;S&quot;</span>) p) q
pattern <span class="dt">K</span> p <span class="fu">=</span> <span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;K&quot;</span>) p
pattern <span class="dt">I</span> <span class="fu">=</span> <span class="dt">Fun</span> <span class="st">&quot;I&quot;</span></code></pre></div>
<p>With the help of these pattern synonyms, we can rewrite <code>optimize</code> function compactly.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">optimize ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
optimize (<span class="dt">S</span> (<span class="dt">K</span> p) (<span class="dt">K</span> q)) <span class="fu">=</span> k (<span class="dt">Ap</span> p q)
optimize (<span class="dt">S</span> (<span class="dt">K</span> p) <span class="dt">I</span>) <span class="fu">=</span> p
optimize (<span class="dt">S</span> (<span class="dt">K</span> p) q) <span class="fu">=</span> b p q
optimize (<span class="dt">S</span> p (<span class="dt">K</span> q)) <span class="fu">=</span> c p q
optimize x <span class="fu">=</span> x</code></pre></div>
<p>Compare the code with the optimization rules. Now they look almost the same!</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Thu, 22 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-22-pattern-synonyms.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>foldl vs foldl'</title>
    <link>http://kseo.github.io//posts/2016-12-21-foldl-vs-foldl%27.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 21, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/fold.html">fold</a>, <a href="/tags/recursion.html">recursion</a>
      
  </div>

<p>Chris Allen <a href="http://lorepub.com/post/2016-12-17-Haskell-Pitfalls">mentioned</a> <code>foldl</code> as one of the newbie traps in Haskell.</p>
<blockquote>
<p>foldl’ is always what you want, don’t use foldl!</p>
</blockquote>
<p>Because <code>foldl</code> always has to examine the whole list, there is no reason to make it lazy. It just uses more memory to do the same thing as <code>foldl'</code>.</p>
<p><a href="http://book.realworldhaskell.org/read/functional-programming.html">Real World Haskell</a> also recommends using <code>foldl'</code> instead of <code>foldl</code>.</p>
<blockquote>
<p>Due to the thunking behavior of foldl, it is wise to avoid this function in real programs: even if it doesn’t fail outright, it will be unnecessarily inefficient. Instead, import Data.List and use foldl’</p>
</blockquote>
<p><a href="https://wiki.haskell.org/Foldr_Foldl_Foldl&#39;#Foldl">Haskell Wiki</a> compares <code>foldr</code>, <code>foldl</code> and <code>foldl'</code> and recommends using either <code>foldr</code> or <code>foldl'</code>.</p>
<blockquote>
<p>foldl’ is the more efficient way to arrive at that result because it doesn’t build a huge thunk.</p>
</blockquote>
<p>But here comes a question. If <code>foldl'</code> is almost always better than <code>foldl</code>, why do we have <code>foldl</code> anyway? It makes sense only when the combining function is non-strict in its <em>first</em> argument. (The example is taken from the Haskell Wiki.)</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(?) ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
_ <span class="fu">?</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
x <span class="fu">?</span> y <span class="fu">=</span> x<span class="fu">*</span>y

<span class="ot">list ::</span> [<span class="dt">Int</span>]
list <span class="fu">=</span> [<span class="dv">2</span>,<span class="dv">3</span>,undefined,<span class="dv">5</span>,<span class="dv">0</span>]

okey <span class="fu">=</span> foldl (<span class="fu">?</span>) <span class="dv">1</span> list
boom <span class="fu">=</span> foldl&#39; (<span class="fu">?</span>) <span class="dv">1</span> list</code></pre></div>
<p>Evaluation of <code>okey</code>:</p>
<pre><code>okey --&gt;
foldl (?) 1 [2,3,undefined,5,0] --&gt;
foldl (?) (1 ? 2) [3,undefined,5,0] --&gt;
foldl (?) ((1 ? 2) ? 3) [undefined,5,0] --&gt;
foldl (?) (((1 ? 2) ? 3) ? undefined) [5,0] --&gt;
foldl (?) ((((1 ? 2) ? 3) ? undefined) ? 5) [0] --&gt;
foldl (?) (((((1 ? 2) ? 3) ? undefined) ? 5) ? 0) [] --&gt;
((((1 ? 2) ? 3) ? undefined) ? 5) ? 0 --&gt;
0</code></pre>
<p>Evaluation of <code>boom</code>:</p>
<pre><code>boom --&gt;
foldl&#39; (?) 1 [2,3,undefined,5,0] --&gt;
    1 ? 2 --&gt; 2
foldl&#39; (?) 2 [3,undefined,5,0] --&gt;
    2 ? 3 --&gt; 6
foldl&#39; (?) 6 [undefined,5,0] --&gt;
    6 ? undefined --&gt;
*** Exception: Prelude.undefined</code></pre>
<p>This example actually shows why <code>foldl</code> is so useless because it is hard to find a function which is non-strict in its <em>first</em> argument.</p>
<p>Many functions in Haskell are non-strict in its <em>second</em> argument and this is why <code>foldr</code> is useful. For example, <code>(&amp;&amp;)</code> is non-strict in its <em>second</em> argument and <code>and</code> can be efficiently defined using <code>foldr</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&amp;&amp;)                    ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="dt">True</span>  <span class="fu">&amp;&amp;</span> x              <span class="fu">=</span>  x
<span class="dt">False</span> <span class="fu">&amp;&amp;</span> _              <span class="fu">=</span>  <span class="dt">False</span>

and<span class="ot">                     ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
and                     <span class="fu">=</span>  foldr (<span class="fu">&amp;&amp;</span>) <span class="dt">True</span></code></pre></div>
<p>In conclusion, we should use <code>foldl'</code> by default unless we have a very compelling reason to use <code>foldl</code> instead.</p>
<p>But, wait! Let’s check how our beloved <code>sum</code> function is written. Because <code>(+)</code> is strict in both of its arguments, <code>foldl'</code> should have been used. But here’s <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.List.html#sum">the actual code</a> taken from the <code>base</code> package.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sum<span class="ot">                     ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
<span class="ot">{-# INLINE sum #-}</span>
sum                     <span class="fu">=</span>  foldl (<span class="fu">+</span>) <span class="dv">0</span></code></pre></div>
<p>OMG! There is a historical accident here. Interested readers are referred to <a href="http://www.well-typed.com/blog/90/">Fixing foldl</a> article from Well-Typed.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Wed, 21 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-21-foldl-vs-foldl%27.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Non empty list</title>
    <link>http://kseo.github.io//posts/2016-12-20-non-empty-list.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 20, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/non%20empty%20list.html">non empty list</a>, <a href="/tags/prelude.html">prelude</a>
      
  </div>

<p>Haskell is well known for its safety. A well-typed Haskell program never goes wrong. Is it true? Unfortunately, no. The type system of Haskell is great and it does catch many bugs at compile time, but Haskell’s <code>Prelude</code> is full of partial functions.</p>
<p>For example, <code>head</code> and <code>tail</code> functions of <code>Data.List</code> throws an error when an empty list is given as an argument.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> head []
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> Prelude.head<span class="fu">:</span> empty list</code></pre></div>
<p>That’s why we have a separate <a href="https://hackage.haskell.org/package/safe">safe</a> package which provides alternative safe functions such as <a href="https://www.stackage.org/haddock/lts-7.12/safe-0.3.10/Safe.html#v:headMay">headMay</a> and <a href="https://www.stackage.org/haddock/lts-7.12/safe-0.3.10/Safe.html#v:tailMay">tailMay</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> headMay []
<span class="dt">Nothing</span>
<span class="ot">it ::</span> <span class="dt">Maybe</span> a</code></pre></div>
<p>What if you know that your list is never empty? Checking the return value of <code>headMay</code> or <code>tailMay</code> soon becomes cumbersome.</p>
<p>Fortunately, Haskell <code>Prelude</code> provides <a href="https://www.stackage.org/haddock/lts-7.12/base-4.9.0.0/Data-List-NonEmpty.html">NonEmpty</a> data type which guarantees that the list is not empty. You can use <code>head</code> and <code>tail</code> functions without worrying about the partiality. It also provides many list functions such as <code>map</code>, <code>reverse</code> and <code>length</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:|</span>, <span class="fu">&lt;|</span>
<span class="kw">data</span> <span class="dt">NonEmpty</span> a <span class="fu">=</span> a <span class="fu">:|</span> [a]

head<span class="ot"> ::</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Tue, 20 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-20-non-empty-list.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Encoding existentials</title>
    <link>http://kseo.github.io//posts/2016-12-19-encoding-existentials.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 19, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/existential%20type.html">existential type</a>, <a href="/tags/Church%20encoding.html">Church encoding</a>
      
  </div>

<p>Existential types are important because <a href="http://theory.stanford.edu/~jcm/papers/mitch-plotkin-88.pdf">Abstract Types Have Existential Type</a>. Haskell supports existential types though a GHC extension named <code>ExistentialQuantification</code>.</p>
<p>Here’s is an example. This code below creates an abstract data type named <code>Obj</code>. Clients of <code>Obj</code> can use only <code>show</code> function because clients can’t know the hidden representation of <code>Obj</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span>

<span class="kw">data</span> <span class="dt">Obj</span> <span class="fu">=</span> forall a<span class="fu">.</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Obj</span> a

<span class="ot">obj1 ::</span> <span class="dt">Obj</span>
obj1 <span class="fu">=</span> <span class="dt">Obj</span> <span class="st">&quot;hello&quot;</span>

<span class="ot">obj2 ::</span> <span class="dt">Obj</span>
obj2 <span class="fu">=</span> <span class="dt">Obj</span> <span class="dv">1</span>

<span class="ot">app ::</span> <span class="dt">Obj</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
app (<span class="dt">Obj</span> x) <span class="fu">=</span> show x</code></pre></div>
<p>The code is simple, but confusing because it uses <em>forall</em> instead of <em>exists</em> quantifier. It becomes more clear when we rewrite the definition of <code>Obj</code> in GADT syntax.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>

<span class="kw">data</span> <span class="dt">Obj</span> <span class="kw">where</span>
  <span class="dt">Obj</span><span class="ot"> ::</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Obj</span></code></pre></div>
<p>As the type variable <code>a</code> no longer appears on the right hand side, it is considered to be existentially quantified. Also you no longer need <code>ExistentialQuantification</code>. Existentials are subsumed by GADTs.</p>
<p>There is another way to encode existential types without <code>ExistentialQuantification</code>. Because an existential type is a pair of type and a value, we can use the <a href="https://en.wikipedia.org/wiki/Church_encoding">Church encoding</a> for a pair to represent existentials.</p>
<pre><code>{∃X,T} = ∀Y. (∀X. T→Y) → Y</code></pre>
<p>In Haskell, we need to enable <code>RankNTypes</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RankNTypes #-}</span>

<span class="kw">type</span> <span class="dt">Obj</span> <span class="fu">=</span> forall y<span class="fu">.</span> (forall x<span class="fu">.</span> (<span class="dt">Show</span> x) <span class="ot">=&gt;</span> x <span class="ot">-&gt;</span> y) <span class="ot">-&gt;</span> y

<span class="ot">obj ::</span> <span class="dt">Obj</span>
obj f <span class="fu">=</span> f <span class="st">&quot;hello&quot;</span>

<span class="ot">app ::</span> <span class="dt">Obj</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
app obj <span class="fu">=</span> obj (\x <span class="ot">-&gt;</span> show x)</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Mon, 19 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-19-encoding-existentials.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Short cut fusion</title>
    <link>http://kseo.github.io//posts/2016-12-18-short-cut-fusion.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 18, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/short%20cut%20fusion.html">short cut fusion</a>, <a href="/tags/optimization.html">optimization</a>
      
  </div>

<p>Let’s start with a simple programming task. How do you add integers from 1 to 10? In Java-like language, we use a loop to calculate the sum.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="dt">int</span> sum = <span class="dv">0</span>;
<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= <span class="dv">10</span>; i++) {
  sum += i;
}</code></pre></div>
<p>In Haskell, we can succinctly performs the same calculation using <em>list comprehension</em> and <code>foldr</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</code></pre></div>
<p>The code is short and elegant, but novice Haskell programmers are often concerned with the performance of this program. Indeed, it looks very inefficient on the surface because it first generates a list of integers from 1 to 10 by allocating each con cells, and subsequently deallocates them by folding over the list.</p>
<p>So functional programming is nice, but it is not performant in real world? The answer is no! Our Haskell compiler, GHC is smart enough to optimize this pattern into a simple loop which does not require an explicit list structure. This compiler optimization technique is called <a href="https://wiki.haskell.org/Short_cut_fusion">short cut fusion</a>.</p>
<p>Let’s see how our example is actually transformed into a simple loop step by step.</p>
<p>First, the list comprehension expression <code>[1..10]</code> is a syntactic sugar for <code>from 1 10</code>. The definition of <code>from</code> is as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">from ::</span> (<span class="dt">Ord</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]
from a b <span class="fu">=</span> <span class="kw">if</span> a <span class="fu">&gt;</span> b
           <span class="kw">then</span> []
           <span class="kw">else</span> a <span class="fu">:</span> from (a <span class="fu">+</span> <span class="dv">1</span>) b</code></pre></div>
<p><code>from</code> is a list producing function and we can abstract the definition over <em>cons</em> and <em>nil</em> by parameterizing both as arguments.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">from&#39; ::</span> (<span class="dt">Ord</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b
from&#39; a b <span class="fu">=</span> \c n <span class="ot">-&gt;</span> <span class="kw">if</span> a <span class="fu">&gt;</span> b
                    <span class="kw">then</span> n
                    <span class="kw">else</span> c a (from&#39; (a <span class="fu">+</span> <span class="dv">1</span>) b c n)</code></pre></div>
<p>The original <code>from</code> can be obtained in terms of <code>build</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">build ::</span> forall a<span class="fu">.</span> (forall b<span class="fu">.</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a]
build g <span class="fu">=</span> g (<span class="fu">:</span>) []

from a b <span class="fu">=</span> build (from&#39; a b )</code></pre></div>
<p>Here <code>build</code> is a dual of <code>foldr</code> which produces a list. You can think of <code>from'</code> as a program with ‘holes’ for constructors, and <code>build</code> plugs those holes with actual constructors.</p>
<p>The key idea of the <em>short cut fusion</em> is that <code>build</code> and <code>foldr</code> cancel each other. To put it another way, when we produce a list that will be consumed immediately, we can fuse them together.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr k z (build g) <span class="fu">=</span> g k z</code></pre></div>
<p>We now can see that the evaluation of <code>foldr (+) 0 [1..10]</code> does not produce an intermediate list.</p>
<pre><code>foldr (+) 0 (from 1 10)
=&gt; foldr (+) 0 (build (from&#39; 1 10))
=&gt; from&#39; 1 10 (+) 0
=&gt; \c n -&gt; (if 1 &gt; 10
            then n
            else c 1 (from&#39; 2 10 c n)) (+) 0
=&gt; if 1 &gt; 10
   then 0
   else 1 + (from&#39; 2 10 (+) 0)
=&gt; 1 + 2 + ... + 9 + 10 + 0
=&gt; 55</code></pre>
<p>Interested readers might like to take a look at the <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/deforestation-short-cut.pdf">original paper</a> for further information.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Sun, 18 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-18-short-cut-fusion.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Type safe continuation passing style</title>
    <link>http://kseo.github.io//posts/2016-12-17-type-safe-continuation-passing-style.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 17, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/continuation%20passing%20style.html">continuation passing style</a>, <a href="/tags/type%20safe.html">type safe</a>
      
  </div>

<p>One common mistake in JavaScript programming is to forget to invoke callback in continuation passing style code. For example, the code below may never complete:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="va">async</span>.<span class="at">series</span>([
       <span class="kw">function</span> (callback) <span class="op">{</span>
           <span class="cf">if</span> (..)
              <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;invalid input&quot;</span>)<span class="op">;</span> <span class="co">// BUG: NO callback!</span>
           <span class="cf">else</span>
              <span class="at">callback</span>(<span class="kw">null</span><span class="op">,</span> <span class="st">&#39;ok&#39;</span>)<span class="op">;</span>
       <span class="op">},</span>
       <span class="kw">function</span> (callback) <span class="op">{</span>
           ...
       <span class="op">}</span>
  ]<span class="op">,</span>
  <span class="kw">function</span> (err<span class="op">,</span> result) <span class="op">{</span> <span class="at">handleErrorOrResult</span>(err<span class="op">,</span> result)<span class="op">;}</span> <span class="co">// Might not be reached</span>
)<span class="op">;</span></code></pre></div>
<p>Unfortunately, there is no systematic way to prevent this kind of bug in JavaScript. We can write tests, but it is not practical to write tests which cover all control paths.</p>
<p>But in Haskell, thanks to the powerful type system, we can turn these bugs into type errors! Let’s take a look at the definition of <code>Application</code> from <a href="http://www.yesodweb.com/book/web-application-interface">Web Application Interface</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Application</span> <span class="fu">=</span>
    <span class="dt">Request</span> <span class="ot">-&gt;</span>
    (<span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ResponseReceived</span>) <span class="ot">-&gt;</span>
    <span class="dt">IO</span> <span class="dt">ResponseReceived</span></code></pre></div>
<p>This signature of <code>Application</code> looks similar to <code>bracket</code> function. Wai uses continuation passing style to handle resource management in an exception-safe manner.</p>
<p>There is a bonus here. A valid function of <code>Application</code> must return a <code>ResponseReceived</code>, but we can’t create one by ourselves because there is no constructor available. The only way to acquire an <code>ResponseReceived</code> value is to invoke the callback. Thus if you accidentally forget to invoke callback, it automatically becomes a type error.</p>
<p>The code snippet below returns <code>responseReceived</code> returned from <code>respond</code> to make <code>application</code> type-check. Otherwise, GHC will complain about the type mismatch.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kw">import           </span><span class="dt">Blaze.ByteString.Builder</span> (fromByteString)
<span class="kw">import           </span><span class="dt">Network.HTTP.Types</span>       (status200)
<span class="kw">import           </span><span class="dt">Network.Wai</span>
<span class="kw">import           </span><span class="dt">Network.Wai.Handler.Warp</span> (run)

application _ respond <span class="fu">=</span> <span class="kw">do</span>
  msg <span class="fu">=</span> fromByteString <span class="st">&quot;Hello world!&quot;</span>
  responseReceived <span class="ot">&lt;-</span> respond <span class="fu">$</span> responseBuilder
    status200
    [(<span class="st">&quot;Content-Type&quot;</span>, <span class="st">&quot;text/plain&quot;</span>)]
    msg
  return responseReceived

main <span class="fu">=</span> run <span class="dv">3000</span> application</code></pre></div>
<p>NOTE: We could define <code>Application</code> using <code>RankNTypes</code> GHC extension instead of <code>ResponseReceived</code> type. An old version of <code>Wai</code> actually used this definition of <code>Application</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Application</span> <span class="fu">=</span> <span class="dt">Request</span> <span class="ot">-&gt;</span> (forall b<span class="fu">.</span> (<span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b)</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Sat, 17 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-17-type-safe-continuation-passing-style.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Datatype-generic programming with bifunctors</title>
    <link>http://kseo.github.io//posts/2016-12-16-datatype-generic-programming-with-bifunctors.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 16, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/datatype-generic.html">datatype-generic</a>, <a href="/tags/bifunctors.html">bifunctors</a>
      
  </div>

<p>In the <em>origami</em> style of programming, higher-order recursion operators such as <em>map</em>, <em>fold</em> and <em>unfold</em> captures the structure of programs. These operators have two aspects: <em>mapping</em> and <em>accumulating</em>.</p>
<p><a href="https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf">The Essence of the Iterator Pattern</a> by Jeremy Gibbons and Bruno C. d. S. Oliveira show that <em>applicative functors</em> and the corresponding <code>traverse</code> operator capture the essence of the <em>ITERATOR</em> pattern providing both mapping and accumulating. This explains why Haskell’s <code>Applicative</code> and <code>Traversable</code> work so well for many data types!</p>
<p>But in this post, instead of reiterating the paper, we are going to review one of the earlier approach which provides recursion operators in datatype-generic way. Surprisingly, what we need is only <a href="https://hackage.haskell.org/package/bifunctors">bifunctors</a>.</p>
<p>This post is in literate Haskell, so let’s start with a list of GHC extensions and imports:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE DeriveFunctor #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Bifunctor</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Bifunctor.TH</span></code></pre></div>
<p><code>Data.Bifunctor.TH</code> provides a <code>TemplateHaskell</code> macro <code>deriveBifunctor</code>, which automatically derives the <code>Bifunctor</code> instance. This is possible because all sum-of-product data types induce bifunctors. Here’s our favorite list data type.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">ListF</span> a r <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a r <span class="kw">deriving</span> <span class="dt">Functor</span>
<span class="ot">&gt;</span> deriveBifunctor <span class="ch">&#39;&#39;</span><span class="dt">ListF</span></code></pre></div>
<p><code>Fix</code> is the fixed point of a <code>Bifunctor</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">Fix</span> s a <span class="fu">=</span> <span class="dt">In</span> {<span class="ot"> out ::</span> s a (<span class="dt">Fix</span> s a) }</code></pre></div>
<p>Then we define <code>List</code> as a fixed point of <code>ListF</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">List</span> <span class="fu">=</span> <span class="dt">Fix</span> <span class="dt">ListF</span></code></pre></div>
<p>To map over an arbitrary data type defined by <code>Fix</code>, we should be able to define a <code>Functor</code> instance of <code>Fix s</code>. It seems like a hard problem at first, but with enough patience and time it is actually possible to define <code>fmap</code> in terms of <code>bimap</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Bifunctor</span> s <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Fix</span> s) <span class="kw">where</span>
<span class="ot">&gt;</span>   fmap f <span class="fu">=</span> <span class="dt">In</span> <span class="fu">.</span> bimap f (fmap f) <span class="fu">.</span> out</code></pre></div>
<p>This looks magical, but we can comprehend the definition by inspecting the types of its components.</p>
<ul>
<li>out :: Fix s a -&gt; s a (Fix s a)</li>
<li>In :: s a (Fix s a) -&gt; Fix s a</li>
<li>fmap :: (a -&gt; b) -&gt; Fix s a -&gt; Fix s b</li>
<li>bimap :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; s a c -&gt; s b d</li>
</ul>
<p>The type of <code>fmap f</code> is <code>Fix s a -&gt; Fix s b</code>, so the type of <code>bimap f (fmap f)</code> is <code>s a (Fix s a) -&gt; s b (Fix s b)</code>. Now we can compose these:</p>
<ul>
<li>out :: Fix s a -&gt; s a (Fix s a)</li>
<li>bimap f (fmap f) :: s a -&gt; s a (Fix s a) -&gt; s b (Fix s b)</li>
<li>In :: s b (Fix s b) -&gt; Fix s b</li>
</ul>
<p>Thus,</p>
<ul>
<li>In . bitmap f (fmap f) . out :: Fix s a -&gt; Fix s b</li>
</ul>
<p><code>fold</code> and <code>unfold</code> can be defined similiarly:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fold ::</span> <span class="dt">Bifunctor</span> s <span class="ot">=&gt;</span> (s a b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Fix</span> s a <span class="ot">-&gt;</span> b
<span class="ot">&gt;</span> fold f <span class="fu">=</span> f <span class="fu">.</span> bimap id (fold f) <span class="fu">.</span> out
<span class="ot">&gt;</span> 
<span class="ot">&gt; unfold ::</span> <span class="dt">Bifunctor</span> s <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> s a b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Fix</span> s a
<span class="ot">&gt;</span> unfold f <span class="fu">=</span> <span class="dt">In</span> <span class="fu">.</span> bimap id (unfold f) <span class="fu">.</span> f</code></pre></div>
<p>Here’s how we use <code>fmap</code> on <code>List</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; nil ::</span> <span class="dt">List</span> a
<span class="ot">&gt;</span> nil <span class="fu">=</span> <span class="dt">In</span> <span class="dt">Nil</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a
<span class="ot">&gt;</span> cons x xs <span class="fu">=</span> <span class="dt">In</span> (<span class="dt">Cons</span> x xs)
<span class="ot">&gt;</span> 
<span class="ot">&gt; l ::</span> <span class="dt">List</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> l <span class="fu">=</span> fmap (<span class="fu">+</span><span class="dv">1</span>) (cons <span class="dv">3</span> (cons <span class="dv">4</span> nil))</code></pre></div>
<p>Tada! These recursive operators are indeed datatype-generic because the defintion of <code>fmap</code>, <code>fold</code> and <code>unfold</code> never use the specific data type we defined. They use only <code>bimap</code> which is parameterized by the shape <code>s</code> of the data. It means we can reuse these functions for other data types without reimplementing them for each type. For example, here’s a definition of <code>Tree</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">TreeF</span> a r <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Branch</span> a r r <span class="kw">deriving</span> <span class="dt">Functor</span>
<span class="ot">&gt;</span> deriveBifunctor <span class="ch">&#39;&#39;</span><span class="dt">TreeF</span>
<span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Tree</span> <span class="fu">=</span> <span class="dt">Fix</span> <span class="dt">TreeF</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; leaf ::</span> <span class="dt">Tree</span> a
<span class="ot">&gt;</span> leaf <span class="fu">=</span> <span class="dt">In</span> <span class="dt">Leaf</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; branch ::</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a
<span class="ot">&gt;</span> branch x l r<span class="fu">=</span> <span class="dt">In</span> (<span class="dt">Branch</span> x l r)</code></pre></div>
<p>To map over a tree, we can just use the same <code>fmap</code> function we defined above!</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; t ::</span> <span class="dt">Tree</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> t <span class="fu">=</span> fmap (<span class="fu">+</span><span class="dv">1</span>) (branch <span class="dv">3</span> leaf (branch <span class="dv">4</span> leaf leaf))</code></pre></div>
<p>This technique of using <em>bifunctors</em> to implement datatype-generic recursive functions is mostly superseded by <code>Applicative</code> and <code>Traversable</code> in Haskell, but I think it is still a good example which shows the real power of <em>bifunctors</em>!</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Fri, 16 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-16-datatype-generic-programming-with-bifunctors.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>

    </channel>
</rss>
