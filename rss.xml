<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Haskell for Pragmatic Programmers</title>
        <link>http://kseo.github.io/</link>
        <description><![CDATA[Kwang Yul Seo's Haskell Blog]]></description>
        <atom:link href="http://kseo.github.io//rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sun, 18 Dec 2016 00:00:00 UT</lastBuildDate>
        <item>
    <title>Short cut fusion</title>
    <link>http://kseo.github.io//posts/2016-12-18-short-cut-fusion.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 18, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/short%20cut%20fusion.html">short cut fusion</a>, <a href="/tags/optimization.html">optimization</a>
      
  </div>

<p>Let’s start with a simple programming task. How do you add integers from 1 to 10? In Java-like language, we use a loop to calculate the sum.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="dt">int</span> sum = <span class="dv">0</span>;
<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= <span class="dv">10</span>; i++) {
  sum += i;
}</code></pre></div>
<p>In Haskell, we can succinctly performs the same calculation using <em>list comprehension</em> and <code>foldr</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</code></pre></div>
<p>The code is short and elegant, but novice Haskell programmers are often concerned with the performance of this program. Indeed, it looks very inefficient on the surface because it first generates a list of integers from 1 to 10 by allocating each con cells, and subsequently deallocates them by folding over the list.</p>
<p>So functional programming is nice, but it is not performant in real world? The answer is no! Our Haskell compiler, GHC is smart enough to optimize this pattern into a simple loop which does not require an explicit list structure. This compiler optimization technique is called <a href="https://wiki.haskell.org/Short_cut_fusion">short cut fusion</a>.</p>
<p>Let’s see how our example is actually transformed into a simple loop step by step.</p>
<p>First, the list comprehension expression <code>[1..10]</code> is a syntactic sugar for <code>from 1 10</code>. The definition of <code>from</code> is as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">from a b <span class="fu">=</span> <span class="kw">if</span> a <span class="fu">&gt;</span> b
           <span class="kw">then</span> []
           <span class="kw">else</span> a <span class="fu">:</span> from (a <span class="fu">+</span> <span class="dv">1</span>) b</code></pre></div>
<p><code>from</code> is a list producing function and we can abstract the definition over <em>cons</em> and <em>nil</em> by parameterizing both as arguments.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">from&#39; a b <span class="fu">=</span> \c n <span class="ot">-&gt;</span> <span class="kw">if</span> a <span class="fu">&gt;</span> b
                    <span class="kw">then</span> n
                    <span class="kw">else</span> c a (from&#39; (a <span class="fu">+</span> <span class="dv">1</span>) b c n)</code></pre></div>
<p>The original <code>from</code> can be obtained in terms of <code>build</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">build g <span class="fu">=</span> g (<span class="fu">:</span>) []

from a b <span class="fu">=</span> build (from&#39; a b )</code></pre></div>
<p>Here <code>build</code> is a dual of <code>foldr</code> which produces a list. You can think of <code>from'</code> as a program with ‘holes’ for constructors, and <code>build</code> plugs those holes with actual constructors.</p>
<p>The key idea of the <em>short cut fusion</em> is that <code>build</code> and <code>foldr</code> cancel each other. To put it another way, when we produce a list that will be consumed immediately, we can fuse them together.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr k z (build g) <span class="fu">=</span> g k z</code></pre></div>
<p>We now can see that the evaluation of <code>foldr (+) 0 [1..10]</code> does not produce an intermediate list.</p>
<pre><code>foldr (+) 0 (from 1 10)
=&gt; foldr (+) 0 (build (from&#39; 1 10))
=&gt; from&#39; 1 10 (+) 0
=&gt; \c n -&gt; if 1 &gt; 10
           then n
           else c 1 (from&#39; 2 10 c n)
=&gt; if 1 &gt; 10
   then 0
   else 1 + (from&#39; 2 10 (+) 0)
=&gt; 1 + 2 + ... + 9 + 10 + 0
=&gt; 55</code></pre>
<p>Interested readers might like to take a look at the <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/deforestation-short-cut.pdf">original paper</a> for further information.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Sun, 18 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-18-short-cut-fusion.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Type safe continuation passing style</title>
    <link>http://kseo.github.io//posts/2016-12-17-type-safe-continuation-passing-style.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 17, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/continuation%20passing%20style.html">continuation passing style</a>, <a href="/tags/type%20safe.html">type safe</a>
      
  </div>

<p>One common mistake in JavaScript programming is to forget to invoke callback in continuation passing style code. For example, the code below may never complete:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="va">async</span>.<span class="at">series</span>([
       <span class="kw">function</span> (callback) <span class="op">{</span>
           <span class="cf">if</span> (..)
              <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;invalid input&quot;</span>)<span class="op">;</span> <span class="co">// BUG: NO callback!</span>
           <span class="cf">else</span>
              <span class="at">callback</span>(<span class="kw">null</span><span class="op">,</span> <span class="st">&#39;ok&#39;</span>)<span class="op">;</span>
       <span class="op">},</span>
       <span class="kw">function</span> (callback) <span class="op">{</span>
           ...
       <span class="op">}</span>
  ]<span class="op">,</span>
  <span class="kw">function</span> (err<span class="op">,</span> result) <span class="op">{</span> <span class="at">handleErrorOrResult</span>(err<span class="op">,</span> result)<span class="op">;}</span> <span class="co">// Might not be reached</span>
)<span class="op">;</span></code></pre></div>
<p>Unfortunately, there is no systematic way to prevent this kind of bug in JavaScript. We can write tests, but it is not practical to write tests which cover all control paths.</p>
<p>But in Haskell, thanks to the powerful type system, we can turn these bugs into type errors! Let’s take a look at the definition of <code>Application</code> from <a href="http://www.yesodweb.com/book/web-application-interface">Web Application Interface</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Application</span> <span class="fu">=</span>
    <span class="dt">Request</span> <span class="ot">-&gt;</span>
    (<span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ResponseReceived</span>) <span class="ot">-&gt;</span>
    <span class="dt">IO</span> <span class="dt">ResponseReceived</span></code></pre></div>
<p>This signature of <code>Application</code> looks similar to <code>bracket</code> function. Wai uses continuation passing style to handle resource management in an exception-safe manner.</p>
<p>There is a bonus here. A valid function of <code>Application</code> must return a <code>ResponseReceived</code>, but we can’t create one by ourselves because there is no constructor available. The only way to acquire an <code>ResponseReceived</code> value is to invoke the callback. Thus if you accidentally forget to invoke callback, it automatically becomes a type error.</p>
<p>The code snippet below returns <code>responseReceived</code> returned from <code>respond</code> to make <code>application</code> type-check. Otherwise, GHC will complain about the type mismatch.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kw">import           </span><span class="dt">Blaze.ByteString.Builder</span> (fromByteString)
<span class="kw">import           </span><span class="dt">Network.HTTP.Types</span>       (status200)
<span class="kw">import           </span><span class="dt">Network.Wai</span>
<span class="kw">import           </span><span class="dt">Network.Wai.Handler.Warp</span> (run)

application _ respond <span class="fu">=</span> <span class="kw">do</span>
  msg <span class="fu">=</span> fromByteString <span class="st">&quot;Hello world!&quot;</span>
  responseReceived <span class="ot">&lt;-</span> respond <span class="fu">$</span> responseBuilder
    status200
    [(<span class="st">&quot;Content-Type&quot;</span>, <span class="st">&quot;text/plain&quot;</span>)]
    msg
  return responseReceived

main <span class="fu">=</span> run <span class="dv">3000</span> application</code></pre></div>
<p>NOTE: We could define <code>Application</code> using <code>RankNTypes</code> GHC extension instead of <code>ResponseReceived</code> type. An old version of <code>Wai</code> actually used this definition of <code>Application</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Application</span> <span class="fu">=</span> <span class="dt">Request</span> <span class="ot">-&gt;</span> (forall b<span class="fu">.</span> (<span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b)</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Sat, 17 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-17-type-safe-continuation-passing-style.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Datatype-generic programming with bifunctors</title>
    <link>http://kseo.github.io//posts/2016-12-16-datatype-generic-programming-with-bifunctors.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 16, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/datatype-generic.html">datatype-generic</a>, <a href="/tags/bifunctors.html">bifunctors</a>
      
  </div>

<p>In the <em>origami</em> style of programming, higher-order recursion operators such as <em>map</em>, <em>fold</em> and <em>unfold</em> captures the structure of programs. These operators have two aspects: <em>mapping</em> and <em>accumulating</em>.</p>
<p><a href="https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf">The Essence of the Iterator Pattern</a> by Jeremy Gibbons and Bruno C. d. S. Oliveira show that <em>applicative functors</em> and the corresponding <code>traverse</code> operator capture the essence of the <em>ITERATOR</em> pattern providing both mapping and accumulating. This explains why Haskell’s <code>Applicative</code> and <code>Traversable</code> work so well for many data types!</p>
<p>But in this post, instead of reiterating the paper, we are going to review one of the earlier approach which provides recursion operators in datatype-generic way. Surprisingly, what we need is only <a href="https://hackage.haskell.org/package/bifunctors">bifunctors</a>.</p>
<p>This post is in literate Haskell, so let’s start with a list of GHC extensions and imports:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE DeriveFunctor #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Bifunctor</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Bifunctor.TH</span></code></pre></div>
<p><code>Data.Bifunctor.TH</code> provides a <code>TemplateHaskell</code> macro <code>deriveBifunctor</code>, which automatically derives the <code>Bifunctor</code> instance. This is possible because all sum-of-product data types induce bifunctors. Here’s our favorite list data type.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">ListF</span> a r <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a r <span class="kw">deriving</span> <span class="dt">Functor</span>
<span class="ot">&gt;</span> deriveBifunctor <span class="ch">&#39;&#39;</span><span class="dt">ListF</span></code></pre></div>
<p><code>Fix</code> is the fixed point of a <code>Bifunctor</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">Fix</span> s a <span class="fu">=</span> <span class="dt">In</span> {<span class="ot"> out ::</span> s a (<span class="dt">Fix</span> s a) }</code></pre></div>
<p>Then we define <code>List</code> as a fixed point of <code>ListF</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">List</span> <span class="fu">=</span> <span class="dt">Fix</span> <span class="dt">ListF</span></code></pre></div>
<p>To map over an arbitrary data type defined by <code>Fix</code>, we should be able to define a <code>Functor</code> instance of <code>Fix s</code>. It seems like a hard problem at first, but with enough patience and time it is actually possible to define <code>fmap</code> in terms of <code>bimap</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Bifunctor</span> s <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Fix</span> s) <span class="kw">where</span>
<span class="ot">&gt;</span>   fmap f <span class="fu">=</span> <span class="dt">In</span> <span class="fu">.</span> bimap f (fmap f) <span class="fu">.</span> out</code></pre></div>
<p>This looks magical, but we can comprehend the definition by inspecting the types of its components.</p>
<ul>
<li>out :: Fix s a -&gt; s a (Fix s a)</li>
<li>In :: s a (Fix s a) -&gt; Fix s a</li>
<li>fmap :: (a -&gt; b) -&gt; Fix s a -&gt; Fix s b</li>
<li>bimap :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; s a c -&gt; s b d</li>
</ul>
<p>The type of <code>fmap f</code> is <code>Fix s a -&gt; Fix s b</code>, so the type of <code>bimap f (fmap f)</code> is <code>s a (Fix s a) -&gt; s b (Fix s b)</code>. Now we can compose these:</p>
<ul>
<li>out :: Fix s a -&gt; s a (Fix s a)</li>
<li>bimap f (fmap f) :: s a -&gt; s a (Fix s a) -&gt; s b (Fix s b)</li>
<li>In :: s b (Fix s b) -&gt; Fix s b</li>
</ul>
<p>Thus,</p>
<ul>
<li>In . bitmap f (fmap f) . out :: Fix s a -&gt; Fix s b</li>
</ul>
<p><code>fold</code> and <code>unfold</code> can be defined similiarly:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fold ::</span> <span class="dt">Bifunctor</span> s <span class="ot">=&gt;</span> (s a b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Fix</span> s a <span class="ot">-&gt;</span> b
<span class="ot">&gt;</span> fold f <span class="fu">=</span> f <span class="fu">.</span> bimap id (fold f) <span class="fu">.</span> out
<span class="ot">&gt;</span> 
<span class="ot">&gt; unfold ::</span> <span class="dt">Bifunctor</span> s <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> s a b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Fix</span> s a
<span class="ot">&gt;</span> unfold f <span class="fu">=</span> <span class="dt">In</span> <span class="fu">.</span> bimap id (unfold f) <span class="fu">.</span> f</code></pre></div>
<p>Here’s how we use <code>fmap</code> on <code>List</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; nil ::</span> <span class="dt">List</span> a
<span class="ot">&gt;</span> nil <span class="fu">=</span> <span class="dt">In</span> <span class="dt">Nil</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a
<span class="ot">&gt;</span> cons x xs <span class="fu">=</span> <span class="dt">In</span> (<span class="dt">Cons</span> x xs)
<span class="ot">&gt;</span> 
<span class="ot">&gt; l ::</span> <span class="dt">List</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> l <span class="fu">=</span> fmap (<span class="fu">+</span><span class="dv">1</span>) (cons <span class="dv">3</span> (cons <span class="dv">4</span> nil))</code></pre></div>
<p>Tada! These recursive operators are indeed datatype-generic because the defintion of <code>fmap</code>, <code>fold</code> and <code>unfold</code> never use the specific data type we defined. They use only <code>bimap</code> which is parameterized by the shape <code>s</code> of the data. It means we can reuse these functions for other data types without reimplementing them for each type. For example, here’s a definition of <code>Tree</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">TreeF</span> a r <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Branch</span> a r r <span class="kw">deriving</span> <span class="dt">Functor</span>
<span class="ot">&gt;</span> deriveBifunctor <span class="ch">&#39;&#39;</span><span class="dt">TreeF</span>
<span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Tree</span> <span class="fu">=</span> <span class="dt">Fix</span> <span class="dt">TreeF</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; leaf ::</span> <span class="dt">Tree</span> a
<span class="ot">&gt;</span> leaf <span class="fu">=</span> <span class="dt">In</span> <span class="dt">Leaf</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; branch ::</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a
<span class="ot">&gt;</span> branch x l r<span class="fu">=</span> <span class="dt">In</span> (<span class="dt">Branch</span> x l r)</code></pre></div>
<p>To map over a tree, we can just use the same <code>fmap</code> function we defined above!</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; t ::</span> <span class="dt">Tree</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> t <span class="fu">=</span> fmap (<span class="fu">+</span><span class="dv">1</span>) (branch <span class="dv">3</span> leaf (branch <span class="dv">4</span> leaf leaf))</code></pre></div>
<p>This technique of using <em>bifunctors</em> to implement datatype-generic recursive functions is mostly superseded by <code>Applicative</code> and <code>Traversable</code> in Haskell, but I think it is still a good example which shows the real power of <em>bifunctors</em>!</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Fri, 16 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-16-datatype-generic-programming-with-bifunctors.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Golden tests are tasty</title>
    <link>http://kseo.github.io//posts/2016-12-15-golden-tests-are-tasty.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 15, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/tasty.html">tasty</a>, <a href="/tags/golden.html">golden</a>, <a href="/tags/test.html">test</a>
      
  </div>

<p>Haskell programmers love property based testing thanks to glorious <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a> library. Once we specify the program behavior in terms of properties, <em>QuickCheck</em> generates random test cases and checks if the given properties hold for these test cases. Once it finds a failing test case, it automatically shrinks the test case to the minimal value which still violates the property.</p>
<p>However, we, Haskell programmers, often forget that there are other test methodologies. In this post, I am going to introduce <em>gold testing</em> provided by <a href="https://hackage.haskell.org/package/tasty-golden">tasty-golden</a> package.</p>
<p>The idea is simple. A golden test is just an <code>IO</code> action that writes its result to a file. To pass the test, this output file should be identical to the corresponding <em>golden</em> file, which contains the correct result for the test.</p>
<h1 id="a-cast-study-untyped-lambda-calculus">A cast study: untyped lambda calculus</h1>
<p>We have an <a href="https://github.com/kseo/untyped">untyped lambda calculus implementation</a>. It provides <code>run</code> function which evaluates the given lambda calculus script to a <code>String</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">run ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">String</span></code></pre></div>
<p>For testing, we would like to check if this function works correctly for various input scripts. To enumerate a few test scenarios:</p>
<ul>
<li><code>\x.x</code> evaluates to itself because there is no redex in the term.</li>
<li><code>(\x.x)(\x.x)</code> evaluates to <code>(\x.x)</code> by substitution.</li>
<li><code>\x.y</code> throws an error because <code>y</code> is an unbound variable.</li>
</ul>
<p>Of course, we can manually create a test case for each scenario, but this is boring and repetitive. Instead of writing test cases in Haskell, let’s create a script file and its expected output file for each input:</p>
<ul>
<li><p>t1.lc</p>
<pre><code>\x.x</code></pre></li>
<li><p>t1.golden</p>
<pre><code>\x.x</code></pre></li>
<li><p>t2.lc</p>
<pre><code>(\x.x)(\x.x)</code></pre></li>
<li><p>t2.golden</p>
<pre><code>(\x.x)</code></pre></li>
<li><p>t3.lc</p>
<pre><code>(\x.y)</code></pre></li>
<li><p>t3.golden</p>
<pre><code>&quot;untyped lambda-calculus&quot; (line 2, column 1):
unexpected end of input
The variable y has not been bound</code></pre></li>
</ul>
<p>Once we have these files ready, what golden tests do is to read each script file and evaluates the script, and compares the output with the expected output contained in the expected file. If the actual output and the expected output are different, the test fails. We call the expected output file as the <em>golden file</em>.</p>
<p>For convenience, tasty-golden generates the golden files if they are not available. So you don’t need to create golden files initially. You also can regenerate the golden files using the <code>--accept</code> flag. This is useful when you know that your change is valid and want to rebase all the golden files accordingly.</p>
<h1 id="implementation">Implementation</h1>
<p>Here’s the actual code which performs golden tests as described above. <code>listTestFiles</code> enumerates all the script files under <code>test/tests</code> directory and <code>mkGoldenTest</code> creates a golden test from the script file using <code>goldenVsString</code> function provided by tasty-golden.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Language.LambdaCalculus</span>

<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">as</span> <span class="dt">BS</span>
<span class="kw">import </span><span class="dt">System.FilePath</span>
<span class="kw">import </span><span class="dt">System.FilePath.Glob</span>

<span class="kw">import </span><span class="dt">Test.Tasty</span>
<span class="kw">import </span><span class="dt">Test.Tasty.Golden</span> <span class="kw">as</span> <span class="dt">G</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  paths <span class="ot">&lt;-</span> listTestFiles
  goldens <span class="ot">&lt;-</span> mapM mkGoldenTest paths
  defaultMain (testGroup <span class="st">&quot;Tests&quot;</span> goldens)

<span class="ot">listTestFiles ::</span> <span class="dt">IO</span> [FilePath]
listTestFiles <span class="fu">=</span> globDir1 pat <span class="st">&quot;test/tests&quot;</span>
  <span class="kw">where</span> pat <span class="fu">=</span> compile <span class="st">&quot;*.lc&quot;</span>

<span class="ot">mkGoldenTest ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">TestTree</span>
mkGoldenTest path <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> testName <span class="fu">=</span> takeBaseName path
  <span class="kw">let</span> goldenPath <span class="fu">=</span> replaceExtension path <span class="st">&quot;.golden&quot;</span>
  return (goldenVsString testName goldenPath action)
  <span class="kw">where</span>
<span class="ot">    action ::</span> <span class="dt">IO</span> <span class="dt">BS.ByteString</span>
    action <span class="fu">=</span> <span class="kw">do</span>
      script <span class="ot">&lt;-</span> readFile path
      <span class="kw">let</span> actual <span class="fu">=</span> either id id (run script)
      return (BS.pack actual)</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Thu, 15 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-15-golden-tests-are-tasty.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>How QuickCheck generates random functions</title>
    <link>http://kseo.github.io//posts/2016-12-14-how-quick-check-generate-random-functions.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 14, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/QuickCheck.html">QuickCheck</a>, <a href="/tags/test.html">test</a>
      
  </div>

<p>In <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a>, test data is produced by <em>test generators</em> whose types are of the form <code>Gen a</code>. <code>Gen a</code> is a generator for values of type <code>a</code>. A type can define a default test data generator by defining an instance of the class <code>Arbitrary</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Arbitrary</span> a <span class="kw">where</span>
<span class="ot">  arbitrary   ::</span> <span class="dt">Gen</span> a
  <span class="fu">...</span></code></pre></div>
<p>We can define instances of <code>Arbitrary</code> using the combinators provided by <em>QuickCheck</em>. For example, the instances of <code>Bool</code> and <code>Ordering</code> are defined using <code>choose</code> and <code>elements</code> respectively. <code>choose</code> generates a random element in the given inclusive range and <code>elements xs</code> generates an arbitrary element of the list <code>xs</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Bool</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span> choose (<span class="dt">False</span>,<span class="dt">True</span>)
  shrink <span class="dt">True</span> <span class="fu">=</span> [<span class="dt">False</span>]
  shrink <span class="dt">False</span> <span class="fu">=</span> []

<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Ordering</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span> elements [<span class="dt">LT</span>, <span class="dt">EQ</span>, <span class="dt">GT</span>]
  shrink <span class="dt">GT</span> <span class="fu">=</span> [<span class="dt">EQ</span>, <span class="dt">LT</span>]
  shrink <span class="dt">LT</span> <span class="fu">=</span> [<span class="dt">EQ</span>]
  shrink <span class="dt">EQ</span> <span class="fu">=</span> []</code></pre></div>
<p>Simple and easy! But how about a function? Can we generate a function in the same way? The answer is surprisingly yes, but you need another type class named <code>CoArbitrary</code>.</p>
<p>Before explaining how <code>CoArbitrary</code> works, we need to check how <code>Gen</code> is defined:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | A generator for values of type @a@.</span>
<span class="kw">newtype</span> <span class="dt">Gen</span> a <span class="fu">=</span> <span class="dt">MkGen</span>{
<span class="ot">  unGen ::</span> <span class="dt">QCGen</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="co">-- ^ Run the generator on a particular seed.</span>
                             <span class="co">-- If you just want to get a random value out, consider using &#39;generate&#39;.</span>
  }</code></pre></div>
<p>Internally, <code>Gen a</code> is a function which takes 2 arguments (<code>QCGen</code> and <code>Int</code>) and returns <code>a</code>. Here <code>QCGen</code> is a newtype wrapper around either <code>StdGen</code> or <code>TFGen</code>.</p>
<p>So <code>Gen (a -&gt; b)</code> expands to <code>QCGen -&gt; Int -&gt; a -&gt; b</code>. By reordering parameters, this is equivalent to <code>a -&gt; Int -&gt; QCGen -&gt; b</code>, which represents <code>a -&gt; Gen b</code>. Thus by defining</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">promote ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Gen</span> b) <span class="ot">-&gt;</span> <span class="dt">Gen</span> (a<span class="ot">-&gt;</span>b)</code></pre></div>
<p>we can produce a generator for a <em>function type</em>, provided that we can construct a generator for the <em>result type</em> which somehow depends on the argument value.</p>
<p>So we need <code>coarbitrary</code> which modifies a generator in a way depending on its first parameter.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">CoArbitrary</span> a <span class="kw">where</span>
<span class="ot">  coarbitrary ::</span> a <span class="ot">-&gt;</span> <span class="dt">Gen</span> b <span class="ot">-&gt;</span> <span class="dt">Gen</span> b</code></pre></div>
<p>To actually define an instance of <code>CoArbitrary</code>, we need a helper function <code>variant</code>, which perturbs the generator. It creates a new generator that produces different pseudo-random results than the original.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Modifies a generator using an integer seed.</span>
<span class="ot">variant ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</code></pre></div>
<p>Now we can define instances of <code>CoArbitrary</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">CoArbitrary</span> <span class="dt">Bool</span> <span class="kw">where</span>
  coarbitrary <span class="dt">False</span> <span class="fu">=</span> variant <span class="dv">0</span>
  coarbitrary <span class="dt">True</span> <span class="fu">=</span> variant <span class="dv">1</span>

<span class="kw">instance</span> <span class="dt">CoArbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">CoArbitrary</span> (<span class="dt">Maybe</span> a) <span class="kw">where</span>
  coarbitrary <span class="dt">Nothing</span>  <span class="fu">=</span> variant <span class="dv">0</span>
  coarbitrary (<span class="dt">Just</span> x) <span class="fu">=</span> variant <span class="dv">1</span> <span class="fu">.</span> coarbitrary x</code></pre></div>
<p>With all the pieces in place, we can finally define an <code>Arbitrary</code> for the function type <code>a -&gt; b</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Coarbitrary</span> a, <span class="dt">Arbitrary</span> b) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (a <span class="ot">-&gt;</span> b) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> promote (\a <span class="ot">-&gt;</span> coarbitrary a arbitrary)</code></pre></div>
<p>To see how this works:</p>
<ol style="list-style-type: decimal">
<li><code>\a -&gt; coarbitrary a arbitrary</code> has type <code>a -&gt; Gen b</code></li>
<li><code>promote</code> has type <code>(a -&gt; Gen b) -&gt; Gen (a-&gt;b)</code></li>
<li>So, the entire expression has type <code>Gen (a-&gt;b)</code></li>
</ol>
<p>The current implementation of <em>QuickCheck</em> is a bit different as it is generalized to <code>Monad</code>, but When <code>m</code> is the function instance of <code>Monad</code>, <code>promote</code> is the same as we derived here.</p>
<pre><code>promote :: Monad m =&gt; m (Gen a) -&gt; Gen (m a)</code></pre>
<h1 id="references">References</h1>
<ul>
<li><a href="http://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf">QuickCheck: A Lightweight Tool for Random Testing of Haskell Programs</a> by Koen Claessen and John Hughes</li>
<li><a href="http://stackoverflow.com/a/16220336/2028189">StackOverflow: How to generate random, typed functions</a></li>
</ul>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Wed, 14 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-14-how-quick-check-generate-random-functions.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Scott encoding of Algebraic Data Types</title>
    <link>http://kseo.github.io//posts/2016-12-13-scott-encoding.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 13, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/scott%20encoding.html">scott encoding</a>, <a href="/tags/algebraic%20data%20type.html">algebraic data type</a>
      
  </div>

<p>This article is written in literate Haskell.</p>
<p>It is well known that algebraic data types can be encoded in a functional programming language by higher order functions. The Church encoding is the most famous one, but there is a lesser known encoding, called Scott encoding. The Scott encoding is generally considered as <a href="https://ifl2014.github.io/submissions/ifl2014_submission_13.pdf">better</a>.</p>
<p>In this article, I will show you some examples of Scott-encoded algebraic data types. Here I will use named functions intead of anonymous functions because the named function makes the notation of recursive algorithms easier.</p>
<p>Before move on, we need to turn on GHC extension <code>RankNTypes</code>. If you want to know how Rank-N types are related to the Scott encoding, see <a href="https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html">24 Days of GHC Extensions: Rank N Types</a>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE RankNTypes #-}</span></code></pre></div>
<h1 id="pair">Pair</h1>
<p><code>Pair</code> is a simplest example of a container type. Because it is a non-recursive type, the Church and Scott encoding overlap in this case. This is the standard encoding used for pairs in λ-calculus courses.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">PairS</span> a b <span class="fu">=</span> <span class="dt">PairS</span> {<span class="ot"> unpairS ::</span> forall r<span class="fu">.</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r }</code></pre></div>
<p>Containers can be expressed by using closures (partial applications). <code>pairS</code> takes 3 arguments. We have a closure by applying only 2 arguments.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; pairS ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">PairS</span> a b
<span class="ot">&gt;</span> pairS a b <span class="fu">=</span> <span class="dt">PairS</span> (\p <span class="ot">-&gt;</span> p a b)</code></pre></div>
<p>Now it is time to define selection functions. <code>fstS</code> and <code>sndS</code> are implemented by passing a continuation (the function in which the continuation continues). It is a 2 argument function which returns either the first or the second argument. <code>fstS</code> returns the first argument and <code>sndS</code> returns the second argument.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fstS ::</span> <span class="dt">PairS</span> a b <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> fstS (<span class="dt">PairS</span> p) <span class="fu">=</span> p (\x _ <span class="ot">-&gt;</span> x)
<span class="ot">&gt;</span> 
<span class="ot">&gt; sndS ::</span> <span class="dt">PairS</span> a b <span class="ot">-&gt;</span> b
<span class="ot">&gt;</span> sndS (<span class="dt">PairS</span> p) <span class="fu">=</span> p (\_ y <span class="ot">-&gt;</span> y)</code></pre></div>
<p>Other functions such as <code>swapS</code> can be implemented in terms of <code>pairS</code>, <code>fstS</code> and <code>sndS</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; swapS ::</span> <span class="dt">PairS</span> a b <span class="ot">-&gt;</span> <span class="dt">PairS</span> b a
<span class="ot">&gt;</span> swapS p <span class="fu">=</span> pairS (sndS p) (fstS p)</code></pre></div>
<h1 id="peano-numbers">Peano numbers</h1>
<p><code>NumS</code> is the simplest recursive data type which represents Peano numbers.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">NumS</span> <span class="fu">=</span> <span class="dt">NumS</span> {<span class="ot"> unnumS ::</span> forall r<span class="fu">.</span> (<span class="dt">NumS</span> <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r }</code></pre></div>
<p><code>NumS</code> has two constructors. <code>zeroS</code> is the non recursive constructor that represents the value zero. <code>succS</code> is the recursive constructor which yields the successor of such a Peano number.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; zeroS ::</span> <span class="dt">NumS</span>
<span class="ot">&gt;</span> zeroS <span class="fu">=</span> <span class="dt">NumS</span> (\s z <span class="ot">-&gt;</span> z)
<span class="ot">&gt;</span> 
<span class="ot">&gt; succS ::</span> <span class="dt">NumS</span> <span class="ot">-&gt;</span> <span class="dt">NumS</span>
<span class="ot">&gt;</span> succS n <span class="fu">=</span> <span class="dt">NumS</span> (\s z <span class="ot">-&gt;</span> s n)</code></pre></div>
<p><code>unnumS</code> is the deconstructor which takes 2 continuations and a <code>NumS</code>. The continuations determine what we reduce the <code>NumS</code> into depending on which constructor is found.</p>
<p>For convinence, <code>unnumS'</code> is defined to have the <code>NumS</code> argument be the last arugment to the <code>unnumS</code> function.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; unnumS&#39; ::</span> (<span class="dt">NumS</span> <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> <span class="dt">NumS</span> <span class="ot">-&gt;</span> r
<span class="ot">&gt;</span> unnumS&#39; s z (<span class="dt">NumS</span> f) <span class="fu">=</span> f s z</code></pre></div>
<p>When we find the num is a successor, then we know that the num is not empty, so we reduce it to <code>False</code>. When we find it is the zero, we reduce it to <code>True</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; isZero ::</span> <span class="dt">NumS</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> isZero <span class="fu">=</span> unnumS&#39; (\_ <span class="ot">-&gt;</span> <span class="dt">False</span>) <span class="dt">True</span></code></pre></div>
<p><code>addS</code> is slightly more complex, but it can also be defined using the same techinque. You can recognize that it is a pattern mathcing in disguse.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; addS ::</span> <span class="dt">NumS</span> <span class="ot">-&gt;</span> <span class="dt">NumS</span> <span class="ot">-&gt;</span> <span class="dt">NumS</span>
<span class="ot">&gt;</span> addS n m <span class="fu">=</span>
<span class="ot">&gt;</span>     unnumS&#39; (\s <span class="ot">-&gt;</span> succS (addS s m))
<span class="ot">&gt;</span>             m n</code></pre></div>
<h1 id="list">List</h1>
<p>We can apply the same transformation to <code>ListS</code> type.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">ListS</span> a <span class="fu">=</span>
<span class="ot">&gt;</span>    <span class="dt">ListS</span> {
<span class="ot">&gt;      unconsS ::</span> forall r<span class="fu">.</span> (a <span class="ot">-&gt;</span> <span class="dt">ListS</span> a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r
<span class="ot">&gt;</span>    }
<span class="ot">&gt;</span> 
<span class="ot">&gt; nilS ::</span> <span class="dt">ListS</span> a
<span class="ot">&gt;</span> nilS <span class="fu">=</span> <span class="dt">ListS</span> (\co ni <span class="ot">-&gt;</span> ni)
<span class="ot">&gt;</span> 
<span class="ot">&gt; consS ::</span> a <span class="ot">-&gt;</span> <span class="dt">ListS</span> a <span class="ot">-&gt;</span> <span class="dt">ListS</span> a
<span class="ot">&gt;</span> consS x xs <span class="fu">=</span> <span class="dt">ListS</span> (\co ni <span class="ot">-&gt;</span> co x xs)
<span class="ot">&gt;</span> 
<span class="ot">&gt; unconsS&#39; ::</span> (a <span class="ot">-&gt;</span> <span class="dt">ListS</span> a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> <span class="dt">ListS</span> a <span class="ot">-&gt;</span> r
<span class="ot">&gt;</span> unconsS&#39; co ni (<span class="dt">ListS</span> f) <span class="fu">=</span> f co ni
<span class="ot">&gt;</span> 
<span class="ot">&gt; isNullS ::</span> <span class="dt">ListS</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> isNullS <span class="fu">=</span> unconsS&#39; (\_ _ <span class="ot">-&gt;</span> <span class="dt">False</span>) <span class="dt">True</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; mapS ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">ListS</span> a <span class="ot">-&gt;</span> <span class="dt">ListS</span> b
<span class="ot">&gt;</span> mapS f <span class="fu">=</span>
<span class="ot">&gt;</span>   unconsS&#39; (\x xs <span class="ot">-&gt;</span> consS (f x) (mapS f xs))
<span class="ot">&gt;</span>            nilS</code></pre></div>
<h1 id="references">References</h1>
<p>Interested readers might like to take a look at the following papers for more information:</p>
<ul>
<li><a href="http://www.nlda-tw.nl/janmartin/papers/jmjansenLambdapaper.pdf">Comprehensive Encoding of Data Types and Algorithms in the λ-Calculus (Functional Pearl)</a> by JAN MARTIN JANSEN</li>
<li><a href="https://ifl2014.github.io/submissions/ifl2014_submission_13.pdf">Church Encoding of Data Types Considered Harmful for Implementations (Functional Pearl)</a> by Pieter Koopman, Rinus Plasmeijer and Jan Martin Jansen</li>
</ul>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Tue, 13 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-13-scott-encoding.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>unfold and fold</title>
    <link>http://kseo.github.io//posts/2016-12-12-unfold-and-fold.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 12, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/unfold.html">unfold</a>, <a href="/tags/fold.html">fold</a>, <a href="/tags/category%20theory.html">category theory</a>
      
  </div>

<h1 id="unfold">unfold</h1>
<p>Every functional programmer loves <em>fold</em>. fold is <a href="http://www.cs.nott.ac.uk/~pszgmh/fold.pdf">universal and expressive</a>. But <em>fold</em> has a secret twin brother named <em>unfold</em> which undoes what <em>fold</em> does. In this post, we will see what <em>unfold</em> is and how it is related to <em>fold</em>.</p>
<p><code>unfoldr</code> builds a list from a seed value while <code>foldr</code> reduces a list to a summary value.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unfoldr ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, b)) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a]</code></pre></div>
<p><code>unfoldr</code> takes the element and returns <code>Nothing</code> if it is done producing the list or returns <code>Just (a, b)</code>, in which case, <code>a</code> is a prepended to the list and <code>b</code> is used as the next element in a recursive call.</p>
<p>For example, we can define <code>iterate</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">iterate f <span class="fu">==</span> unfoldr (\x <span class="ot">-&gt;</span> <span class="dt">Just</span> (x, f x))</code></pre></div>
<p>Another simple use of <code>unfoldr</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> unfoldr (\b <span class="ot">-&gt;</span> <span class="kw">if</span> b <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Nothing</span> <span class="kw">else</span> <span class="dt">Just</span> (b, b<span class="fu">-</span><span class="dv">1</span>)) <span class="dv">10</span>
[<span class="dv">10</span>,<span class="dv">9</span>,<span class="dv">8</span>,<span class="dv">7</span>,<span class="dv">6</span>,<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]</code></pre></div>
<p>As the name suggests, <em>unfold</em> is the categorical dual of <em>fold</em>. (Maybe it should be <em>cofold</em> instead of <em>unfold</em>.) It means we can get the signature of <code>foldr</code> by reversing the arrows of <code>unfoldr</code>, and vice versa.</p>
<p>Let’s try this.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unfoldr ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, b)) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> [a])
foldr<span class="ot">   ::</span> (<span class="dt">Maybe</span> (a, b) <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> ([a] <span class="ot">-&gt;</span> b)</code></pre></div>
<p>Oops! It is not our beloved <code>foldr</code> function whose signature is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</code></pre></div>
<h1 id="type-isomorphisms">Type isomorphisms</h1>
<p>But don’t be disappointed! We can show that they represent the same thing by using type isomorphisms:</p>
<pre><code>(a → b → b) → b → ([a] → b)</code></pre>
<blockquote>
<p>by a -&gt; b -&gt; c ~= (a, b) -&gt; c</p>
</blockquote>
<pre><code>((a, b) → b) → b → ([a] → b)</code></pre>
<blockquote>
<p>by a ~= () -&gt; a</p>
</blockquote>
<pre><code>((a, b) → b) → (() -&gt; b) → ([a] → b)</code></pre>
<blockquote>
<p>by a -&gt; b -&gt; c ~= (a, b) -&gt; c</p>
</blockquote>
<pre><code>(((a, b) → b), (() -&gt; b)) → ([a] → b)</code></pre>
<blockquote>
<p>by ((a -&gt; c), (b -&gt; c)) ~= Either a b -&gt; c</p>
</blockquote>
<pre><code>((Either (a, b) ()) → b) → ([a] → b)</code></pre>
<blockquote>
<p>by Either a () ~= Maybe a</p>
</blockquote>
<pre><code>(Maybe (a, b) -&gt; b) → ([a] → b)</code></pre>
<p>Now we can clearly see that <em>unfold</em> is the dual of <em>fold</em>. If you want to learn more on the relationship between <em>fold</em> and <em>unfold</em>, see Conal Elliott’s <a href="http://conal.net/talks/folds-and-unfolds.pdf">Folds and unfolds all around us</a>.</p>
<h1 id="implementation">Implementation</h1>
<p>Here’s an implementation of <code>unfoldr</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unfoldr ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, b)) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> [a])
unfoldr f b <span class="fu">=</span> <span class="kw">case</span> f b <span class="kw">of</span>
                <span class="dt">Just</span> (a, b&#39;) <span class="ot">-&gt;</span> a <span class="fu">:</span> unfoldr f b&#39;
                <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Mon, 12 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-12-unfold-and-fold.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>How to read arrow combinators</title>
    <link>http://kseo.github.io//posts/2016-12-11-how-to-read-arrow-combinators.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 11, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Arrow.html">Arrow</a>
      
  </div>

<p>Arrows, like monads and applicative functors, express computations that happen within a context. In Haskell, arrows are represented with a constructor class <code>Arrow</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Arrow</span> a <span class="kw">where</span>
<span class="ot">  arr ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a b c
  <span class="co">-- Each function may be treated as a computation.</span>

<span class="ot">  (&gt;&gt;&gt;) ::</span> a b c <span class="ot">-&gt;</span> a c d <span class="ot">-&gt;</span> a b d
  <span class="co">-- Computations may be composed, by connecting the output of the first to the input of the second.</span>

<span class="ot">  first ::</span> a b c <span class="ot">-&gt;</span> a (b,d) (c,d)
  <span class="co">-- A computation may be applied to part of the input, with the rest copied through to the output.</span>
  <span class="fu">...</span></code></pre></div>
<p>As usual, it takes some time to comprehend what arrow is and why and how it is useful. If you are looking for a good arrow tutorial, I strongly recommend John Hughes’s <a href="http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf">Programming with Arrows</a>.</p>
<p>However, it is not necessary to understand arrow just to read some code written with arrow combinators because arrows are often used even when there is no compelling reason to do so. <code>(-&gt;)</code> is an instance of <code>Arrow</code> and some Haskell programmers just prefer arrow style even though combinators of <code>Data.Bifunctor</code> are often more readable.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Arrow</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span>
    arr f <span class="fu">=</span> f
    (<span class="fu">***</span>) f g <span class="fu">~</span>(x,y) <span class="fu">=</span> (f x, g y)</code></pre></div>
<p>So here is my tip. If you encounter code written with arrow combinators in the context of <code>(-&gt;)</code>, use the following <a href="https://en.wikibooks.org/wiki/Haskell/Understanding_arrows#Arrow_combinators_crop_up_in_unexpected_places">translation table</a> to decode what the code means.</p>
<table>
<thead>
<tr class="header">
<th>Combinator</th>
<th>Meaning</th>
<th>Alternatives</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(&gt;&gt;&gt;)</td>
<td>flip (.)</td>
<td></td>
</tr>
<tr class="even">
<td>first</td>
<td>(x, y) -&gt; (f x, y)</td>
<td>first (Data.Bifunctor)</td>
</tr>
<tr class="odd">
<td>second</td>
<td>(x, y) -&gt; (x, f y)</td>
<td>second (Data.Bifunctor)</td>
</tr>
<tr class="even">
<td>(***)</td>
<td>g (x, y) -&gt; (f x, g y)</td>
<td>bimap (Data.Bifunctor)</td>
</tr>
<tr class="odd">
<td>(&amp;&amp;&amp;)</td>
<td>g x -&gt; (f x, g x)</td>
<td>liftA2 (,) (Control.Applicative)</td>
</tr>
<tr class="even">
<td>left</td>
<td>Maps over Left case</td>
<td>first (Data.Bifunctor)</td>
</tr>
<tr class="odd">
<td>right</td>
<td>Maps over Right case</td>
<td>second (Data.Bifunctor)</td>
</tr>
<tr class="even">
<td>(+++)</td>
<td>Maps over both cases</td>
<td>bimap (Data.Bifunctor)</td>
</tr>
<tr class="odd">
<td>(|||)</td>
<td>Eliminates Either</td>
<td>either (Data.Either)</td>
</tr>
<tr class="even">
<td>app</td>
<td>(f, x) -&gt; f x</td>
<td>uncurry ($)</td>
</tr>
</tbody>
</table>
<p>In case of <code>second</code> and <code>right</code>, we can also use <code>fmap</code> because both <code>(,)</code> and <code>Either</code> is functorial on the second type. But I personally don’t recommend <code>fmap</code> in this case because these types arbitrarily map the second type instead of the first one.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Sun, 11 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-11-how-to-read-arrow-combinators.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Encodings of lens</title>
    <link>http://kseo.github.io//posts/2016-12-10-encodings-of-lense.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 10, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Lens.html">Lens</a>
      
  </div>

<p>There are variety of libraries offering lens on the hackage. These include <a href="https://hackage.haskell.org/package/data-accessor">data-accessor</a>, <a href="https://hackage.haskell.org/package/fclabels">fclabels</a>, <a href="https://hackage.haskell.org/package/lenses">lenses</a>, <a href="https://hackage.haskell.org/package/data-lens">data-lens</a> and <a href="https://www.stackage.org/haddock/lts-7.12/lens-4.14/Control-Lens.html">lens</a>. Though they represent the same idea, their encodings of lens are not compatible. This article is an attempt to understand various encodings used to represent the idea of lens.</p>
<h1 id="lens-as-a-getter-and-a-setter">Lens as a getter and a setter</h1>
<p>The most intuitive way to encode lens is to represent it as a collection of a <em>getter</em> and a <em>setter</em>. <code>Lens s a</code> represents a <em>focus</em> to an <code>a</code> inside an <code>s</code> structure.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Lens</span> s a <span class="fu">=</span> <span class="dt">Lens</span>
  {<span class="ot"> get ::</span> s <span class="ot">-&gt;</span> a
  ,<span class="ot"> set ::</span> a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
  }</code></pre></div>
<p>We can define a lens to the first element of a pair as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fstL ::</span> <span class="dt">Lens</span> (a,b) a
fstL <span class="fu">=</span> <span class="dt">Lens</span> {
    get <span class="fu">=</span> \(x,y) <span class="ot">-&gt;</span> x
  , set <span class="fu">=</span> \x (_,y) <span class="ot">-&gt;</span> (x,y)
  }</code></pre></div>
<p>Similarly, we can define <code>snd</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sndL ::</span> <span class="dt">Lens</span> (a,b) b
sndL <span class="fu">=</span> <span class="dt">Lens</span> {
    get <span class="fu">=</span> \(x,y) <span class="ot">-&gt;</span> y
  , set <span class="fu">=</span> \y (x,_) <span class="ot">-&gt;</span> (x,y)
  }</code></pre></div>
<p>Having defined this, it is easy to access and modify a pair:</p>
<pre><code>&gt; get fstL (1,2)
1
&gt; set fstL 3 (1,2)
(3,2)</code></pre>
<p>We can also implement <code>update</code> in terms of <code>get</code> and <code>set</code> by getting the value, applying a function and setting it again.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">update ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
update l f s <span class="fu">=</span> set l (f (get l s)) s</code></pre></div>
<p>This <code>update</code> function works fine for a small data structure such as pairs, but becomes expensive for large data structures as it needs to visit all the way down to the <em>focus</em> twice every time it updates.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> update fstL (<span class="fu">+</span><span class="dv">1</span>) (<span class="dv">1</span>,<span class="dv">2</span>)
(<span class="dv">2</span>,<span class="dv">2</span>)</code></pre></div>
<p>Lenses are composable with <code>compose</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">compose ::</span> <span class="dt">Lens</span> b c <span class="ot">-&gt;</span> <span class="dt">Lens</span> a b <span class="ot">-&gt;</span> <span class="dt">Lens</span> a c
compose bc ab <span class="fu">=</span> <span class="dt">Lens</span>
  { get <span class="fu">=</span> get bc <span class="fu">.</span> get ab
  , set <span class="fu">=</span> update ab <span class="fu">.</span> set bc
  }</code></pre></div>
<p>We can now modify nested pairs:</p>
<pre><code>&gt; update (sndL `compose` fstL) (*2) ((3,4),5)
((3,8),5)</code></pre>
<h1 id="lens-as-a-getter-and-an-updater">Lens as a getter and an updater</h1>
<p>A slight variation to the previous lens encoding is to represent a lens with a <em>getter</em> and an <em>updater</em> instead of a <em>getter</em> and a <em>setter</em>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Lens</span> s a <span class="fu">=</span> <span class="dt">Lens</span>
  {<span class="ot"> get ::</span> s <span class="ot">-&gt;</span> a
  ,<span class="ot"> update ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
  }</code></pre></div>
<p>The performance of this encoding is better than the previous one because we no longer need to visit the <em>focus</em> twice for an single update. <code>fstL</code> and <code>sndL</code> directly implement <code>update</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fstL ::</span> <span class="dt">Lens</span> (a,b) a
fstL <span class="fu">=</span> <span class="dt">Lens</span> {
    get <span class="fu">=</span> \(x,y) <span class="ot">-&gt;</span> x
  , update <span class="fu">=</span> \f (x,y) <span class="ot">-&gt;</span> (f x,y)
  }

<span class="ot">sndL ::</span> <span class="dt">Lens</span> (a,b) b
sndL <span class="fu">=</span> <span class="dt">Lens</span> {
    get <span class="fu">=</span> \(x,y) <span class="ot">-&gt;</span> y
  , update <span class="fu">=</span> \f (x,y) <span class="ot">-&gt;</span> (x, f y)
  }</code></pre></div>
<p>But what about <code>set</code>? We can easily define <code>set</code> in terms of <code>update</code> using <code>const</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">set ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
set l a s <span class="fu">=</span> update l (const a) s</code></pre></div>
<p>Composition of two lenses are similarly defined:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">compose ::</span> <span class="dt">Lens</span> b c <span class="ot">-&gt;</span> <span class="dt">Lens</span> a b <span class="ot">-&gt;</span> <span class="dt">Lens</span> a c
compose bc ab <span class="fu">=</span> <span class="dt">Lens</span>
  { get <span class="fu">=</span> get bc <span class="fu">.</span> get ab
  , update <span class="fu">=</span> update ab <span class="fu">.</span> update bc
  }</code></pre></div>
<h1 id="cps-based-lens-aka-van-laarhoven-lens">CPS based lens (aka van Laarhoven lens)</h1>
<p>This encoding is called <em>a CPS based lens</em> as the type looks like a continuation passing style function, which would be <code>(b -&gt; r) -&gt; (a -&gt; r)</code> though the return type is <code>f a</code> instead of any <code>r</code>. It is also called <a href="http://www.twanvl.nl/blog/haskell/cps-functional-references">van Laarhoven lens</a> named after <strong>Twan van Laarhoven</strong> who first discovered this encoding.</p>
<p>This is the most popular lens encoding as it is used by the famous Edward Kmett’s <a href="https://www.stackage.org/haddock/lts-7.12/lens-4.14/Control-Lens.html">lens</a> library.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE Rank2Types #-}</span>

<span class="kw">type</span> <span class="dt">Lens</span> s a <span class="fu">=</span> forall f<span class="fu">.</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> f s)</code></pre></div>
<p>It is hard to understand the type at first sight. There are no longer identifiable setter or getter in the type signature. Instead, we have a functor <code>f</code> in the signature.</p>
<p>As expected from the clue, we can derive <code>get</code> and <code>update</code> by applying different functors to the type.</p>
<p>First, we derive <code>get</code> by applying <code>Const</code> functor:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Applicative</span>

<span class="ot">get ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a
get l <span class="fu">=</span> getConst <span class="fu">.</span> l <span class="dt">Const</span></code></pre></div>
<p>Also we can derive <code>update</code> by applying <code>Identity</code> functor:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Identity</span>

<span class="ot">update ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
update l m <span class="fu">=</span> runIdentity <span class="fu">.</span> l (<span class="dt">Identity</span> <span class="fu">.</span> m)</code></pre></div>
<p><code>set</code> function can be implemented in terms of <code>get</code> and <code>update</code> as usual:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">set ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
set l b a <span class="fu">=</span> update l (const b) a</code></pre></div>
<p>Fortunately, defining a lens in var Laarhoven lens encoding is not hard. For example, we can define <code>fstL</code> using <code>fmap</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fstL ::</span> <span class="dt">Lens</span> (a,b) a
fstL f (x,y) <span class="fu">=</span> fmap (\a <span class="ot">-&gt;</span> (a, y)) (f x)</code></pre></div>
<p>Or we can define <code>sndL</code> more succinctly using <code>TupleSections</code> and <code>(&lt;$&gt;)</code> operator:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sndL ::</span> <span class="dt">Lens</span> (a,b) b
sndL x (a,b) <span class="fu">=</span> (a,) <span class="fu">&lt;$&gt;</span> x b</code></pre></div>
<p>As this job of defining a lens is so mechanical, lens library provides a <a href="https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-TH.html#v:makeLenses">TemplateHaskell macro</a> to generate lenses from a record.</p>
<p>Let’s see how <code>get</code> works by actually evaluating <code>get fstL (1,2)</code>:</p>
<pre><code>get fstL (1,2)
=&gt; getConst . (fstL Const) (1,2)
=&gt; getConst . (\x (a,b) -&gt; (,b) &lt;$&gt; x a) (1,2)
=&gt; getConst . (\(a,b) -&gt; (,b) &lt;$&gt; Const a) (1,2)
=&gt; getConst . ((,2) &lt;$&gt; Const 1)
=&gt; getConst . (Const 1)
=&gt; 1</code></pre>
<p>One particularly nice property of var Laarhoven lens is that composition of two lens is just the function composition operator <code>(.)</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">compose ::</span> <span class="dt">Lens</span> b c <span class="ot">-&gt;</span> <span class="dt">Lens</span> a b <span class="ot">-&gt;</span> <span class="dt">Lens</span> a c
compose r s <span class="fu">=</span> s <span class="fu">.</span> r</code></pre></div>
<p>So we can simply use the <code>(.)</code> to compose two lenses instead of custom <code>compose</code> function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> update (fstL <span class="fu">.</span> sndL) (<span class="fu">*</span><span class="dv">2</span>) ((<span class="dv">3</span>,<span class="dv">4</span>),<span class="dv">5</span>)
((<span class="dv">3</span>,<span class="dv">8</span>),<span class="dv">5</span>)</code></pre></div>
<p>However, the order of composition is reversed due to the nature of CPS based encoding. This is a bit confusing at first, but it makes sense when we think of it as a property referencing in an OO language.</p>
<pre><code>pair.(fstL.sndL) *= 2</code></pre>
<p>This style of composition is also possible with previous two encodings if we use Haskell’s type classes to overload <code>(.)</code> and <code>id</code> as described in <a href="http://www.twanvl.nl/blog/haskell/overloading-functional-references">Overloading functional references</a>. But van Laarhoven lens is still simpler as we don’t need to hide the <code>(.)</code> operator of the <code>Prelude</code>.</p>
<h1 id="isomorphism-lens">Isomorphism lens</h1>
<p>There is a yet another encoding of lens called <a href="http://www.twanvl.nl/blog/haskell/isomorphism-lenses">Isomorphism lens</a> which was also discovered by van Laarhoven.</p>
<blockquote>
<p>A lens from type s to a is a bijection between s and a pair of a and some residual r.</p>
</blockquote>
<p>To put it more succinctly,</p>
<pre><code>type Lens s a = exists r. s &lt;-&gt; (a,r)</code></pre>
<p>Because Haskell has no <code>exists</code> keyword, we can represent the encoding with a <code>newtype</code> wrapper:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE Rank2Types #-}</span>
<span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span>

<span class="co">-- Isomorphisms/bijections between type @a@ and @b@</span>
<span class="kw">data</span> <span class="dt">Iso</span> a b <span class="fu">=</span> <span class="dt">Iso</span> {<span class="ot"> fw ::</span> a <span class="ot">-&gt;</span> b,<span class="ot"> bw ::</span> b <span class="ot">-&gt;</span> a }

<span class="co">-- Lenses with a data wrapper, in practice you might want to unpack the Iso type</span>
<span class="kw">data</span> <span class="dt">Lens</span> s a <span class="fu">=</span> forall r<span class="fu">.</span> <span class="dt">Lens</span> (<span class="dt">Iso</span> s (a,r))</code></pre></div>
<p>This encoding captures the intuition of what lens does extremely well. Suppose we have a record type <code>s</code>, and want to take out a field of type <code>a</code>. When we do that, there is some residual, which is <code>s - a</code>. So <code>s</code> and <code>(a, s - a)</code> is must be isomorphic.</p>
<p>We can define <code>get</code> and <code>update</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Bifunctor</span>

<span class="ot">get ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a
get (<span class="dt">Lens</span> l) <span class="fu">=</span> fst <span class="fu">.</span> fw l

<span class="ot">update ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> s)
update (<span class="dt">Lens</span> l) f <span class="fu">=</span> bw l <span class="fu">.</span> first f <span class="fu">.</span> fw l</code></pre></div>
<p><code>set</code> function is the same as before:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">set ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
set l b a <span class="fu">=</span> update l (const b) a</code></pre></div>
<p>Isomorphism lens has the nice property that we can derive lens laws directly from the isomorphism law.</p>
<blockquote>
<p>fw i . bw i = bw i . fw i = id</p>
</blockquote>
<p>See <a href="http://www.twanvl.nl/blog/haskell/isomorphism-lenses">van Laarhoven’s article</a> to see how we can derive three lens law.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Sat, 10 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-10-encodings-of-lense.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Objects versus Abstract Data Types</title>
    <link>http://kseo.github.io//posts/2016-06-14-objects-vs-abstract-data-types.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on June 14, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/objects.html">objects</a>, <a href="/tags/abstract%20data%20types.html">abstract data types</a>
      
  </div>

<p>William R. Cook’s essay titled <a href="http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf">On Understanding Data Abstraction, Revisited</a> explains the differences between two forms of data abstraction, <em>objects</em> and <em>abstract data types</em>. His another paper, <a href="https://www.cs.utexas.edu/users/wcook/papers/OOPvsADT/CookOOPvsADT90.pdf">Object-Oriented Programming Versus Abstract Data Types</a> shows why distinguishing these two data abstractions are important:</p>
<blockquote>
<p>Object-oriented programming and abstract data types can also be viewed as complementary implementation techniques: objects are centered around the constructors of a data abstraction, while abstract data types are organized around the operations. These differences have consequences relating to extensibility, efficiency, typing, and verification; in many cases the strengths of one paradigm are the weaknesses of the other. Most object-oriented programming languages support aspects of both techniques, not a unification of them, so an understanding of their relative merits is useful in designing programs.</p>
</blockquote>
<p>Haskell type classes are also discussed in Cook’s essay. He described Haskell type classes as a powerful mechanism for parameterization and extensibility because type classes are unique in that they have properties of both objects and abstract data types:</p>
<ul>
<li>Type classes do not allow different instances to interoperate, but they allow multiple type class instances within a single program.</li>
<li>Type classes are similar to object interfaces in allowing a method to operate on any value that has the necessary operations.</li>
<li>Type classes are based on algebraic signatures as in abstract data types, but they do not enforce any hiding of representations.</li>
</ul>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Tue, 14 Jun 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-06-14-objects-vs-abstract-data-types.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>

    </channel>
</rss>
