<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Haskell for Pragmatic Programmers</title>
        <link>http://kseo.github.io/</link>
        <description><![CDATA[Kwang Yul Seo's Haskell Blog]]></description>
        <atom:link href="http://kseo.github.io//rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Thu, 19 Jan 2017 00:00:00 UT</lastBuildDate>
        <item>
    <title>Fun with hint</title>
    <link>http://kseo.github.io//posts/2017-01-19-fun-with-hint.html</link>
    <description><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January 19, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/hint.html">hint</a>, <a href="/tags/dynamic%20evaluation.html">dynamic evaluation</a>, <a href="/tags/interpreter.html">interpreter</a>
      
  </div>

<p>If you are a Haskell convert from Lisp, JavaScript or any other dynamic programming language, you might miss <a href="https://en.wikipedia.org/wiki/Eval">eval</a> function of those languages. <code>eval</code> lets us load code dynamically and execute it on the fly. It is commonly used to provide user-defined plugins and is a very handy tool for software extension.</p>
<p>Dynamic evaluation is not limited to dynamic languages. Even Java supports dynamic class loading through class loaders. It seems Haskell does not support dynamic evaluation as it is a strictly defined language. But GHC allows us to compile and execute Haskell code dynamically through GHC API.</p>
<p><a href="https://hackage.haskell.org/package/hint">hint</a> library provides a Haskell interpreter built on top of GHC API. It allows to load and execute Haskell expressions and even coerce them into values.</p>
<p><em>hint</em> provides a bunch of monadic actions based on <code>InterpreterT</code> monad transformer. <code>runInterpreter</code> is used to execute the action.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runInterpreter ::</span> (<span class="dt">MonadIO</span> m, <span class="dt">MonadMask</span> m) <span class="ot">=&gt;</span> <span class="dt">InterpreterT</span> m a <span class="ot">-&gt;</span> m (<span class="dt">Either</span> <span class="dt">InterpreterError</span> a)</code></pre></div>
<h1 id="type-check">Type check</h1>
<p>We can check the type of a Haskell expression using <code>typeOf</code>.</p>
<pre><code>λ&gt; import Language.Haskell.Interpreter
λ&gt; runInterpreter $ typeOf &quot;\&quot;foo\&quot;&quot;
Right &quot;[GHC.Types.Char]&quot;
λ&gt; runInterpreter $ typeOf &quot;3.14&quot;
Right &quot;GHC.Real.Fractional t =&gt; t&quot;</code></pre>
<h1 id="import-modules">Import modules</h1>
<p><em>hint</em> does not import prelude implicitly. We need import modules explicitly using <code>setImport</code>. For qualified imports, use <code>setImportQ</code> instead.</p>
<pre><code>λ&gt; runInterpreter $ do { setImports [&quot;Prelude&quot;]; typeOf &quot;head [True, False]&quot; }
Right &quot;Bool&quot;
λ&gt; runInterpreter $ do { setImportsQ [(&quot;Prelude&quot;, Nothing), (&quot;Data.Map&quot;, Just &quot;M&quot;) ]; typeOf &quot;M.empty&quot; }
Right &quot;M.Map k a&quot;</code></pre>
<h1 id="evaluate-expressions">Evaluate expressions</h1>
<p><code>eval</code> function lets us evaluate Haskell expressions dynamically.</p>
<pre><code>λ&gt; runInterpreter $ do { setImports [&quot;Prelude&quot;]; eval &quot;head [True, False]&quot; }
Right &quot;True&quot;
λ&gt; runInterpreter $ do { setImports [&quot;Prelude&quot;]; eval &quot;1 + 2 * 3&quot; }
Right &quot;7&quot;</code></pre>
<p>The result type of evaluation is <code>String</code>. To convert the result into the type we want, use <code>interpret</code> with <code>as</code>. Here <code>as</code> provides a witness for its monomorphic type.</p>
<pre><code>λ&gt; runInterpreter $ do { setImports [&quot;Prelude&quot;]; interpret &quot;head [True, False]&quot; (as :: Bool) }
Right True
λ&gt; runInterpreter $ do { setImports [&quot;Prelude&quot;]; interpret &quot;1 + 2 * 3&quot; (as :: Int) }
Right 7</code></pre>
<h1 id="load-modules">Load modules</h1>
<p>It is also possible to load modules dynamically.</p>
<p>Here’s a small module <code>Foo</code> stored in <code>Foo.hs</code> file.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Foo</span> <span class="kw">where</span>

f <span class="fu">=</span> head
g <span class="fu">=</span> tail</code></pre></div>
<p>We can load <code>Foo</code> using <code>loadModules</code> function. <code>setTopLevelModules</code> ensures that all bindings of the module are in scope.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Language.Haskell.Interpreter</span>

<span class="ot">ex ::</span> <span class="dt">Interpreter</span> ()
ex <span class="fu">=</span> <span class="kw">do</span>
  loadModules [<span class="st">&quot;Foo.hs&quot;</span>]
  setTopLevelModules [<span class="st">&quot;Foo&quot;</span>]
  setImportsQ [(<span class="st">&quot;Prelude&quot;</span>, <span class="dt">Nothing</span>)]

  <span class="kw">let</span> expr1 <span class="fu">=</span> <span class="st">&quot;f [1, 2, 3]&quot;</span>
  a <span class="ot">&lt;-</span> eval expr1
  liftIO <span class="fu">$</span> print a

  <span class="kw">let</span> expr2 <span class="fu">=</span> <span class="st">&quot;g [1, 2, 3]&quot;</span>
  a <span class="ot">&lt;-</span> eval expr2
  liftIO <span class="fu">$</span> print a

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  r <span class="ot">&lt;-</span> runInterpreter ex
  <span class="kw">case</span> r <span class="kw">of</span>
    <span class="dt">Left</span> err <span class="ot">-&gt;</span> print err
    <span class="dt">Right</span> () <span class="ot">-&gt;</span> return ()</code></pre></div>
<p>Executing this program prints</p>
<pre><code>&quot;1&quot;
&quot;[2,3]&quot;</code></pre>
<p>because <code>f</code> is <code>head</code> and <code>g</code> is <code>tail</code>.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-19-fun-with-hint.html";
    this.page.identifier = "/posts/2017-01-19-fun-with-hint.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Thu, 19 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-19-fun-with-hint.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Natural transformations in Servant</title>
    <link>http://kseo.github.io//posts/2017-01-18-natural-transformations-in-servant.html</link>
    <description><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January 18, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/servant.html">servant</a>, <a href="/tags/natural%20transformation.html">natural transformation</a>, <a href="/tags/monad%20morphism.html">monad morphism</a>
      
  </div>

<p>I’ve recently started using <a href="http://haskell-servant.readthedocs.io/en/stable/">servant</a> at work. Servant lets us declare web APIs at the type-level once and use those APIs to write servers, obtains client functions and generate documentation. It’s a real world example which shows the power of Haskell type system.</p>
<p>The most interesting part of Servant is its <em>extensible type-level DSL</em> for describing web APIs. However, I found another interesting application of theory into practice in <a href="https://hackage.haskell.org/package/servant-server">servant-server</a> library. It is the use of <em>natural transformation</em> to convert one handler type into another handler type.</p>
<p>In Servant, <code>Handler</code> is a type alias for <code>ExceptT ServantErr IO</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Handler</span> <span class="fu">=</span> <span class="dt">ExceptT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span></code></pre></div>
<p>Thus <code>Handler</code> monad allows us to do:</p>
<ul>
<li>Perform IO operations such as database query through the base monad <code>IO</code>.</li>
<li>Throw a <code>ServantErr</code> if something went wrong.</li>
</ul>
<p>Here’s an example of a Servant handler.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">ItemApi</span> <span class="fu">=</span>
    <span class="st">&quot;item&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;itemId&quot;</span> <span class="dt">Integer</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">&#39;[JSON] Item</span>

<span class="ot">queryItemFirst ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">Item</span>)
queryItemFirst itemId <span class="fu">=</span> <span class="fu">...</span>

<span class="ot">getItemById ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Item</span>
getItemById itemId <span class="fu">=</span> <span class="kw">do</span>
  mItem <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> queryItemFirst itemId
  <span class="kw">case</span> mItem <span class="kw">of</span>
    <span class="dt">Just</span> item <span class="ot">-&gt;</span> return item
    <span class="dt">Nothing</span>   <span class="ot">-&gt;</span> throwError err404</code></pre></div>
<p>So far so good, but what if <code>queryItemFirst</code> needs a database connection to retrieve the item? Ideally, we would like to create a custom monad for our application such as</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">AppEnv</span> <span class="fu">=</span> <span class="dt">AppEnv</span> {<span class="ot"> db ::</span> <span class="dt">ConnectionPool</span> }
<span class="kw">type</span> <span class="dt">MyHandler</span> <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="dt">AppEnv</span> (<span class="dt">ExceptT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>)

<span class="ot">queryItemFirst ::</span> <span class="dt">ConnectionPool</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">Item</span>)
queryItemFirst cp itemId <span class="fu">=</span> <span class="fu">...</span>

<span class="ot">getItemById ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">MyHandler</span> <span class="dt">Item</span>
getItemById itemId <span class="fu">=</span> <span class="kw">do</span>
  cp <span class="ot">&lt;-</span> db <span class="fu">&lt;$&gt;</span> ask
  mItem <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> queryItemFirst cp itemId
  <span class="kw">case</span> mItem <span class="kw">of</span>
    <span class="dt">Just</span> item <span class="ot">-&gt;</span> return item
    <span class="dt">Nothing</span>   <span class="ot">-&gt;</span> throwError err404</code></pre></div>
<p>Unfortunately, this does not work because <a href="https://www.stackage.org/haddock/lts-7.12/servant-server-0.8.1/Servant-Server.html#v:serve">serve</a> wants <code>Handler</code> type. We need a way to transform <code>MyHandler</code> into <code>Handler</code> so that Servant can happily serve our handlers. Because both <code>MyHandler</code> and <code>Handler</code> are monads, we need a monad morphism. Or more generally, we need a <em>natural transformation</em> from <code>MyHandler</code> to <code>Handler</code>.</p>
<p>Servant provides a newtype wrapper <code>Nat</code> which represents a natural transformation from <code>m a</code> to <code>n a</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> m <span class="fu">:~&gt;</span> n <span class="fu">=</span> <span class="dt">Nat</span> {<span class="ot"> unNat ::</span> forall a<span class="fu">.</span> m a <span class="ot">-&gt;</span> n a}</code></pre></div>
<p>So what we want is <code>MyHandler :~&gt; Handler</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myHandlerToHandler ::</span> <span class="dt">AppEnv</span> <span class="ot">-&gt;</span> <span class="dt">MyHandler</span> <span class="fu">:~&gt;</span> <span class="dt">Handler</span>
myHandlerToHandler env <span class="fu">=</span> <span class="dt">Nat</span> myHandlerToHandler&#39;
  <span class="kw">where</span>
<span class="ot">  myHandlerToHandler&#39; ::</span> <span class="dt">MyHandler</span> a <span class="ot">-&gt;</span> <span class="dt">Handler</span> a
  myHandlerToHandler&#39; h <span class="fu">=</span> runReaderT h env</code></pre></div>
<p>Okay, now we can get a natural transformation <code>MyHandler :~&gt; Handler</code> by applying an <code>AppEnv</code> to <code>myHandlerToHandler</code>. How can I tell the Servant to use this natural transformation to serve our handlers? That’s what <a href="https://www.stackage.org/haddock/lts-7.12/servant-server-0.8.1/Servant-Server.html#v:enter">enter</a> does!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">server ::</span> <span class="dt">AppEnv</span> <span class="ot">-&gt;</span> <span class="dt">Server</span> <span class="dt">ItemApi</span>
server env <span class="fu">=</span>
  enter (myHandlerToHandler env) getItemById</code></pre></div>
<p>Wrapping <code>Handler</code> with <code>ReaderT</code> is a common idiom, so Servant provides a convenient function <code>runReaderTNat</code> which is exactly the same to <code>myHandlerToHandler</code>. So we can rewrite <code>server</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">server ::</span> <span class="dt">AppEnv</span> <span class="ot">-&gt;</span> <span class="dt">Server</span> <span class="dt">ItemApi</span>
server env <span class="fu">=</span>
  enter (runReaderTNat env) getItemById</code></pre></div>
<p>Servant also provides a lot of monad morphisms such as <code>hoistNat</code>, <code>embedNat</code>, <code>squashNat</code> and <code>generalizeNat</code>. Sounds familiar? These are just wrappers around <a href="https://hackage.haskell.org/package/mmorph">mmorph</a> library functions. Interested readers are referred to Gabriel Gonzalez’s article <a href="http://www.haskellforall.com/2013/03/mmorph-100-monad-morphisms.html">mmorph-1.0.0: Monad morphisms</a>.</p>
<p>In object-oriented programming, we use <em>Adapter pattern</em> to allow the interface of an existing class to be used as another interface. In functional programming, we use <em>natural transformations</em> (or more generally, <em>functors</em>) to do so!</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-18-natural-transformations-in-servant.html";
    this.page.identifier = "/posts/2017-01-18-natural-transformations-in-servant.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Wed, 18 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-18-natural-transformations-in-servant.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Type-level functions using closed type families</title>
    <link>http://kseo.github.io//posts/2017-01-16-type-level-functions-using-closed-type-families.html</link>
    <description><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January 16, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/dependent%20type.html">dependent type</a>, <a href="/tags/type-level.html">type-level</a>, <a href="/tags/list.html">list</a>
      
  </div>

<p>In this post, we will see how to write basic type-level functions using <a href="https://github.com/ghc/ghc/commit/569b26526403df4d88fe2a6d64c7dade09d003ad">closed type families</a>.</p>
<p>Before we start, let’s declare a bunch of GHC language extensions required to use type-level functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></code></pre></div>
<p>Also import required modules. <code>GHC.TypeLits</code> provides type-level natural numbers and symbols.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">GHC.TypeLits</span>
<span class="kw">import </span><span class="dt">Data.Proxy</span></code></pre></div>
<h1 id="literals">Literals</h1>
<p>Datatype promotion allows us to use <code>True</code> and <code>False</code> as type constructors whose kind is <code>Bool</code>. The quotes are used to emphasize the promotion, but can be omitted when syntactically unambiguous.</p>
<pre><code>λ&gt; :set -XDataKinds
λ&gt; :kind &#39;True
&#39;True :: Bool
λ&gt; :kind &#39;False
&#39;False :: Bool</code></pre>
<p>We can also use numbers such as <code>1</code> and <code>2</code> as types. The kind of these numbers is <code>Nat</code>.</p>
<pre><code>λ&gt; :kind 1
1 :: Nat</code></pre>
<h1 id="type-level-function">Type-level Function</h1>
<p><code>If</code> takes three arguments <code>c</code>, <code>t</code> and <code>e</code> and returns <code>t</code> if <code>c</code> is <code>True</code>, returns <code>e</code> otherwise. The kind of <code>If</code> is <code>Bool -&gt; * -&gt; * -&gt; *</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">If</span> c t e <span class="kw">where</span>
  <span class="dt">If</span> <span class="ch">&#39;True  t e = t</span>
  <span class="dt">If</span> <span class="ch">&#39;False t e = e</span></code></pre></div>
<p>We can use GHCi’s <code>kind!</code> command to evaluate type functions.</p>
<pre><code>λ&gt; :kind! If &#39;True Bool Char
If &#39;True Bool Char :: *
= Bool
λ&gt; :kind! If &#39;False Int Double
If &#39;False Int Double :: *
= Double</code></pre>
<p>Note that type-level function <code>If</code> is strict in its type arugments.</p>
<h1 id="type-level-list">Type-level List</h1>
<p>As we can promote types like <code>Bool</code>, we can also promote lists and treat <code>[]</code> as a <em>kind constructor</em>, and <code>[]</code> and <code>(:)</code> as <em>types</em>.</p>
<p>When <code>(:)</code> is seen as a type constructor, it has kind</p>
<pre><code>λ&gt; :kind (:)
(:) :: a -&gt; [a] -&gt; [a]</code></pre>
<p>It means <code>(:)</code> is <em>kind-polymorphic</em>.</p>
<p>So we can create a type-level list of booleans as well as naturals.</p>
<pre><code>λ&gt; :kind [True, False]
[True, False] :: [Bool]
λ&gt; :kind [1, 2]
[1,2] :: [Nat]</code></pre>
<h1 id="type-level-list-function">Type-level List Function</h1>
<p>The definition of type-level function <code>Length</code> is the same as the value level <code>length</code> function. If it an empty list returns 0. If it not empty, add 1 to the length of the tail.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Length</span> xs <span class="kw">where</span>
   <span class="dt">Length</span> <span class="ch">&#39;[]       = 0</span>
   <span class="dt">Length</span> (x <span class="ch">&#39;: xs) = 1 + Length xs</span></code></pre></div>
<p><code>0</code> and <code>1</code> are types of <code>Nat</code> kind and <code>(+)</code> is a type-level add function defined in <code>GHC.TypeLits</code>. We can even use <code>(:)</code> as a pattern here.</p>
<pre><code>λ&gt; :kind! Length [Char,Bool,Int]
Length [Char,Bool,Int] :: Nat
= 3</code></pre>
<p>It seems <code>Length</code> is almost identical to the value level function <code>length</code>, but <code>Length</code> function is not kind-polymorphic by default. Thus passing <code>[1, 2, 3]</code> to <code>Length</code> causes an error.</p>
<pre><code>λ&gt; :kind! Length [1,2,3]

&lt;interactive&gt;:1:8: error:
    • Expected kind ‘[*]’, but ‘&#39;[1, 2, 3]’ has kind ‘[Nat]’
    • In the first argument of ‘Length’, namely ‘&#39;[1, 2, 3]’
      In the type ‘Length &#39;[1, 2, 3]’</code></pre>
<p>To make it poly-kinded, we need to turn on <code>PolyKind</code> extension. The kind is inferred automatically, but we can also specify the kind with <code>k</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Length</span> (<span class="ot">xs ::</span> [k]) <span class="kw">where</span>
   <span class="dt">Length</span> <span class="ch">&#39;[]       = 0</span>
   <span class="dt">Length</span> (x <span class="ch">&#39;: xs) = 1 + Length xs</span></code></pre></div>
<p><code>Head</code> and <code>Tail</code> are defined in a similar manner. Note that the kind of <code>xs</code> is explicitly annotated with <code>[*]</code> because they only work on type-level lists.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Head</span> (<span class="ot">xs ::</span> [<span class="fu">*</span>]) <span class="kw">where</span>
   <span class="dt">Head</span> (x <span class="ch">&#39;: xs) = x</span>

<span class="kw">type</span> family <span class="dt">Tail</span> (<span class="ot">xs ::</span> [<span class="fu">*</span>]) <span class="kw">where</span>
  <span class="dt">Tail</span> (x <span class="ch">&#39;: xs) = xs</span></code></pre></div>
<p>We can see <code>Head</code> and <code>Tail</code> work as expected.</p>
<pre><code>λ&gt; :kind! Head [Char, Bool, Int]
Head [Char, Bool, Int] :: *
= Char
*Main
λ&gt; :kind! Tail [Char, Bool, Int]
Tail [Char, Bool, Int] :: [*]
= &#39;[Bool, Int]</code></pre>
<p>One notable thing here is that both <code>Head</code> and <code>Tail</code> are partially defined. What if we pass <code>'[]</code> to <code>Head</code> or <code>Tail</code>?</p>
<pre><code>λ&gt; :kind! Head &#39;[]
Head &#39;[] :: GHC.Types.*
= Head &#39;[]</code></pre>
<p>It seems GHC treats <code>Head '[]</code> as a valid type instead of emitting a type error. It is a bit mysterious, but at least we can see that type-level functions in Haskell can be partial and the behavior is not intuitive. Interested readers are referred to Richard Eisenberg’s <a href="https://typesandkinds.wordpress.com/2015/09/09/what-are-type-families/">What are type families?</a> which discusses this issue in details.</p>
<h1 id="higher-order-type-level-list-function">Higher-order Type-level List Function</h1>
<p>It is even possible to define type-level <em>map</em> function. <code>Map</code> takes a type-level function <code>f</code> and a type-level list <code>xs</code>. It applies <code>f</code> to every element of <code>xs</code> and returns a new type-level list containing the results.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Map</span> (<span class="ot">f ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) (<span class="ot">xs ::</span> [<span class="fu">*</span>]) <span class="kw">where</span>
   <span class="dt">Map</span> f <span class="ch">&#39;[]       = &#39;</span>[]
   <span class="dt">Map</span> f (x <span class="ch">&#39;: xs) = f x &#39;</span><span class="fu">:</span> <span class="dt">Map</span> f xs</code></pre></div>
<pre><code>λ&gt; :kind! Map MakePair [Char,Bool,Int]
Map MakePair [Char,Bool,Int] :: [GHC.Types.*]
= &#39;[(Char, Char), (Bool, Bool), (Int, Int)]</code></pre>
<p>where the definition of <code>MakePair</code> is</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">MakePair</span> (<span class="ot">x ::</span> <span class="fu">*</span>) <span class="kw">where</span>
  <span class="dt">MakePair</span> x <span class="fu">=</span> (x, x)</code></pre></div>
<h1 id="wrap-up">Wrap-up</h1>
<p>So far we’ve covered only the basics of type-level datatypes and functions. Recent additions to GHC make it possible to explore the whole new world of dependent type programming in Haskell. Interested readers might want to take a look at the publications of <a href="http://cs.brynmawr.edu/~rae/">Richard A. Eisenberg</a> whose current work is to add dependent types to Haskell.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-16-type-level-functions-using-closed-type-families.html";
    this.page.identifier = "/posts/2017-01-16-type-level-functions-using-closed-type-families.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Mon, 16 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-16-type-level-functions-using-closed-type-families.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Data.Proxy</title>
    <link>http://kseo.github.io//posts/2017-01-15-data-proxy.html</link>
    <description><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January 15, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Proxy.html">Proxy</a>
      
  </div>

<p><a href="https://www.stackage.org/haddock/lts-7.12/base-4.9.0.0/Data-Proxy.html">Proxy</a> is a mysterious type residing in <code>Data.Proxy</code> module. The definition of <code>Proxy</code> tells nothing about its nature.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | A concrete, poly-kinded proxy type</span>
<span class="kw">data</span> <span class="dt">Proxy</span> t <span class="fu">=</span> <span class="dt">Proxy</span></code></pre></div>
<p>The documentation of <code>Proxy</code> says two hints. It is a (1) <em>concrete</em> and (2) <em>poly-kinded</em> proxy type.</p>
<h1 id="poly-kinded">Poly-kinded</h1>
<p>The kind of <code>Proxy</code> is <code>forall k. k -&gt; *</code>.</p>
<pre><code>λ&gt; :k Proxy
Proxy :: k -&gt; *</code></pre>
<p>Here <code>k</code> is <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XPolyKinds">poly-kinded</a> so we can pass types of any kind to <code>Proxy</code>.</p>
<ul>
<li><code>Proxy Char</code> where <code>k</code> is <code>*</code>.</li>
<li><code>Proxy (,)</code> where <code>k</code> is <code>* -&gt; *</code></li>
<li><code>Proxy Show</code> where <code>k</code> is <code>* -&gt; Constraint</code></li>
<li><code>Proxy Monad</code> where <code>k</code> is <code>(* -&gt; *) -&gt; Constraint</code></li>
</ul>
<h1 id="concrete-value">Concrete value</h1>
<p>In Haskell, we can create a value of any type we want by annotating <code>undefined</code> with the type.</p>
<pre><code>λ&gt; let p = undefined :: Int</code></pre>
<p>However, we can’t use this trick if the kind of the type is not <code>*</code>, For example, we can’t annotate <code>undefined</code> with type <code>(,)</code> because its kind is <code>* -&gt; * -&gt; *</code>.</p>
<pre><code>λ&gt; let q = undefined :: (,)

&lt;interactive&gt;:4:22: error:
    • Expecting two more arguments to ‘(,)’
      Expected a type, but ‘(,)’ has kind ‘* -&gt; * -&gt; *’
    • In an expression type signature: (,)
      In the expression: undefined :: (,)
      In an equation for ‘q’: q = undefined :: (,)</code></pre>
<p><code>Proxy</code> lets us to overcome this limitation. We can create a proxy value representing the type by annotating <code>Proxy</code> data constructor.</p>
<pre><code>λ&gt; import Data.Proxy
λ&gt; let p = Proxy :: Proxy (,)
λ&gt; :t p
p :: Proxy (,)</code></pre>
<p>We can think of <code>Proxy :: Proxy (,)</code> as a reified value of the type <code>(,)</code>.</p>
<h1 id="type-application">Type Application</h1>
<p>The read/show problem below is ill-typed because of ambiguity.</p>
<pre><code>f :: String -&gt; String
f s = show (read s)</code></pre>
<p>We can fix this issue by explicitly passing the type as a value argument. As you can see the wild card pattern <code>_</code>, the value is not used anywhere in the definition of <code>f</code>. Only its type is used.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> forall proxy a<span class="fu">.</span> (<span class="dt">Read</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> proxy a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
f _ <span class="fu">=</span> (show<span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>) <span class="fu">.</span> read</code></pre></div>
<pre><code>λ&gt; f (Proxy :: Proxy Int) &quot;3&quot;
&quot;3&quot;</code></pre>
<p>As a side note, <a href="https://kseo.github.io/posts/2017-01-08-visible-type-application-ghc8.html">TypeApplications</a> extension introduced in GHC 8 provides an alternative way to fix this.</p>
<h1 id="typeable">Typeable</h1>
<p>Another application of <code>Proxy</code> is <code>Typeable</code>. Before kind polymorphism was introduced in GHC, there was a lot of code duplication in the way <code>Typeable</code> is implemented because <code>t</code> can represent only a specific kind.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Typeable</span> (<span class="ot">t ::</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">  typeOf ::</span> t <span class="ot">-&gt;</span> <span class="dt">TypeRep</span>

<span class="kw">class</span> <span class="dt">Typeable1</span> (<span class="ot">t ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">  typeOf1 ::</span> t a <span class="ot">-&gt;</span> <span class="dt">TypeRep</span>

<span class="kw">class</span> <span class="dt">Typeable2</span> (<span class="ot">t ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">  typeOf2 ::</span> t a b <span class="ot">-&gt;</span> <span class="dt">TypeRep</span></code></pre></div>
<p><code>Proxy</code> allows us to merge all these classes into one:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Typeable</span> t <span class="kw">where</span>
<span class="ot">  typeOf ::</span> <span class="dt">Proxy</span> t <span class="ot">-&gt;</span> <span class="dt">TypeRep</span>

<span class="kw">instance</span> <span class="dt">Typeable</span> <span class="dt">Int</span>  <span class="kw">where</span> typeOf _ <span class="fu">=</span> <span class="dt">TypeRep</span>
<span class="kw">instance</span> <span class="dt">Typeable</span> []   <span class="kw">where</span> typeOf _ <span class="fu">=</span> <span class="dt">TypeRep</span></code></pre></div>
<h1 id="other-use-cases-of-proxy">Other use cases of Proxy</h1>
<ul>
<li><a href="https://www.stackage.org/lts-7.12/package/json-schema-0.7.4.1">json-schema</a> uses <code>Proxy</code> to obtain the JSON representation for the given type.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">JSONSchema</span> a <span class="kw">where</span>
<span class="ot">  schema ::</span> <span class="dt">Proxy</span> a <span class="ot">-&gt;</span> <span class="dt">Schema</span></code></pre></div>
<ul>
<li>Edward Kmett’s <a href="https://www.stackage.org/lts-7.12/package/reflection-2.1.2">reflection</a> package shows an advanced usage of <code>Proxy</code>. Austin Seipp’s <a href="https://www.schoolofhaskell.com/user/thoughtpolice/using-reflection">Reflecting values to types and back</a> explains how to reify arbitrary terms into types that can be reflected back into terms.</li>
</ul>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-15-data-proxy.html";
    this.page.identifier = "/posts/2017-01-15-data-proxy.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Sun, 15 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-15-data-proxy.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Memoization in Haskell</title>
    <link>http://kseo.github.io//posts/2017-01-14-memoization-in-hasekll.html</link>
    <description><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January 14, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/memoization.html">memoization</a>
      
  </div>

<p><em>Memoization</em> is an optimization technique used to speed up a function by caching its previously computed results. In impure programming languages, a mutable map is used to cache computed results.</p>
<p>For example, <code>fib</code> function in Python</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> fib(n):
    <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">2</span>: <span class="cf">return</span> <span class="dv">1</span>
    <span class="cf">return</span> fib(n<span class="dv">-1</span>) <span class="op">+</span> fib(n<span class="dv">-2</span>)</code></pre></div>
<p>can be speed up by memoization:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">fib_memo <span class="op">=</span> {}
<span class="kw">def</span> fib(n):
    <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">2</span>: <span class="cf">return</span> <span class="dv">1</span>
    <span class="cf">if</span> <span class="kw">not</span> fib_memo.has_key(n):
        fib_memo[n] <span class="op">=</span> fib(n<span class="dv">-1</span>) <span class="op">+</span> fib(n<span class="dv">-2</span>)
    <span class="cf">return</span> fib_memo[n]</code></pre></div>
<p><code>fib_memo</code> dictionary caches the previous computed results, so <code>fib(n)</code> does not need to repeat the same calculation again for the same <code>n</code>.</p>
<p>This implementation technique of memoization is used widely in many programming languages, but it can’t be applied directly to Haskell because Haskell is pure and we don’t want to introduce impurity just to memoize a function. Fortunately, it is possible to memoize a function without side effects thanks to Haskell’s nature of <em>lazy evaluation</em>.</p>
<p>The following <code>memoize</code> function takes a function of type <code>Int -&gt; a</code> and returns a memoized version of the same function. The trick is to turn a function into a value because, in Haskell, <em>functions</em> are not memoized but <em>values</em> are. <code>memoize</code> converts a function <code>f :: Int -&gt; a</code> into an infinite list <code>[a]</code> whose <code>n</code>th element contains the value of <code>f n</code>. Thus each element of the list is evaluated when it is first accessed and cached automatically by the Haskell runtime thanks to lazy evaluation.</p>
<pre><code>memoize :: (Int -&gt; a) -&gt; (Int -&gt; a)
memoize f = (map f [0 ..] !!)</code></pre>
<p>Let’s define a memoized version of <code>fib</code> using <code>memoize</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
fib <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
fib <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span>
fib n <span class="fu">=</span> fib (n <span class="fu">-</span> <span class="dv">1</span>) <span class="fu">+</span> fib (n <span class="fu">-</span> <span class="dv">2</span>)

fibMemo <span class="fu">=</span> memoize fib</code></pre></div>
<p>Does <code>fibMemo</code> work properly? Sadly no, because <code>fib</code> is a recursive function which calls itself. When we call <code>fibMemo 10</code> twice, the second call is returned immediately because the first result is cached. However, intermediate <code>fib</code> calls used to evaluate <code>fib 10</code> are not cached at all because the body of <code>fib</code> calls itself directly without using <code>fibMemo</code>.</p>
<p>We can fix this issue by factoring out recursion from <code>fib</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Function</span> (fix)

<span class="ot">fib ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
fib f <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
fib f <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span>
fib f n <span class="fu">=</span> f (n <span class="fu">-</span> <span class="dv">1</span>) <span class="fu">+</span> f (n <span class="fu">-</span> <span class="dv">2</span>)

<span class="ot">fibMemo ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
fibMemo <span class="fu">=</span> fix (memoize <span class="fu">.</span> fib)</code></pre></div>
<p>Now every call to <code>fib</code> is memoized because <code>memoize . fib</code> is used every time <code>fib</code> recursively calls itself.</p>
<p>So far, I explained how to memoize a function whose domain is <code>Int</code>. Of course, we can generalize this technique so that an arbitrary function can be memoized. The basic idea is the same. A function is converted into a large data structure which contains the same information so that memoization is performed by lazy evaluation.</p>
<p>Interested readers are referred to</p>
<ul>
<li>Section 3 of <a href="https://wiki.haskell.org/Simonpj/Talk:FunWithTypeFuns">Fun with type functions</a> explains the type-directed memoization technique using type families.</li>
<li>Ralf Hinze’s <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.43.3272&amp;rep=rep1&amp;type=pdf">Memo funtions, polytypially!</a></li>
</ul>
<p>Conal Elliott’s articles on memoization:</p>
<ul>
<li><a href="http://conal.net/blog/posts/memoizing-polymorphic-functions-part-one">Memoizing polymorphic functions – part one</a></li>
<li><a href="http://conal.net/blog/posts/memoizing-polymorphic-functions-part-two">Memoizing polymorphic functions – part two</a></li>
<li><a href="http://conal.net/blog/posts/memoizing-polymorphic-functions-via-unmemoization">Memoizing polymorphic functions via unmemoization</a></li>
<li><a href="http://conal.net/blog/posts/elegant-memoization-with-functional-memo-tries">Elegant memoization with functional memo tries</a></li>
</ul>
<p><a href="https://hackage.haskell.org/package/MemoTrie-0.6.7">MemoTrie</a> provides a basis for memoized functions over some domains, using tries.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-14-memoization-in-hasekll.html";
    this.page.identifier = "/posts/2017-01-14-memoization-in-hasekll.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Sat, 14 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-14-memoization-in-hasekll.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Constraint Kinds</title>
    <link>http://kseo.github.io//posts/2017-01-13-constraint-kinds.html</link>
    <description><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January 13, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/constraints.html">constraints</a>, <a href="/tags/kinds.html">kinds</a>
      
  </div>

<p>In this blog post, I will show some examples of using the <a href="https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/glasgow_exts.html#the-constraint-kind">ConstraintKinds</a> GHC extension.</p>
<h1 id="constraints">Constraints</h1>
<p>Constraints in Haskell mean one of the following things:</p>
<ul>
<li>Class constraints, e.g. <code>Show a</code></li>
<li><em>Implicit parameter constraints</em>, e.g. <code>?x::Int</code> (with the <code>-XImplicitParams</code> flag)</li>
<li><em>Equality constraints</em>, e.g. <code>a ~ Int</code> (with the <code>-XTypeFamilies</code> or <code>-XGADTs</code> flag)</li>
<li>Tuples of any of the above, e.g., <code>(Show a, a ~ Int)</code></li>
</ul>
<p>These constraints can only occur to the left of =&gt; arrow in standard Haskell.</p>
<h1 id="kinds">Kinds</h1>
<p>In Haskell, types have types which are called <em>kinds</em>.</p>
<ul>
<li>The kind <code>*</code> is for types that have terms (even though not every type of kind <code>*</code> needs be inhabited if we exclude ⊥).</li>
<li><code>k -&gt; l</code> forms a function kind to indicate types of kind <code>l</code> that are parameterized over types of kind <code>k</code>.</li>
</ul>
<p>Examples:</p>
<ul>
<li>kind <code>*</code>: <code>Char</code>, <code>Bool</code>, <code>Char -&gt; Bool</code>, <code>Maybe Int</code>, <code>[Int]</code></li>
<li>kind <code>* -&gt; *</code>: <code>Maybe</code>, <code>[]</code></li>
<li>kind <code>* -&gt; * -&gt; *</code>: <code>Either</code>, <code>(,)</code></li>
</ul>
<p>While <em>data</em> introduces types of kind <code>*</code>, <em>classes</em> introduce types of kind <code>Constraint</code>.</p>
<ul>
<li>Classes such as <code>Show</code>, <code>Eq</code> or <code>Ord</code> are of kind <code>* -&gt; Constraint</code>. They form a class constraint when applied to types of kind <code>*</code>.</li>
<li>Classes such as <code>Functor</code> or <code>Monad</code> are of kind <code>(* -&gt; *) -&gt; Constraint</code>. They form a class constraint when applied to type constructors of kind <code>* -&gt; *</code>.</li>
</ul>
<p>We can use tuple syntax to create empty constraints and combine constraints.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">NoConstraint</span> <span class="fu">=</span> (<span class="ot">() ::</span> <span class="dt">Constraint</span>)
<span class="kw">type</span> <span class="dt">Text</span> a <span class="fu">=</span> (<span class="dt">Read</span> a, <span class="dt">Show</span> a)</code></pre></div>
<h1 id="constraintkinds">ConstraintKinds</h1>
<p>Classes and contexts were not first-class citizens in Haskell, but the introduction of the <em>Constraint kind</em> has changed this and allows them to be used as parameters of types.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ConstraintKinds #-}</span></code></pre></div>
<p>With this extension, constraints can be used in new ways:</p>
<ul>
<li>Aliases of classes, partially applied classes, and contexts can be defined using type declarations</li>
<li>Families of classes, partially applied classes, and contexts can be defined using type synonym families</li>
</ul>
<p>Let’s visit each use case with concrete examples.</p>
<h1 id="constraint-synonyms">Constraint synonyms</h1>
<p>Since constraints are now just types, type synonyms can be reused on constraints.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Text</span> a <span class="fu">=</span> (<span class="dt">Show</span> a, <span class="dt">Read</span> a)</code></pre></div>
<p>Here is a real world example of constraint synonyms defined in the <a href="https://github.com/commercialhaskell/stack/blob/master/src/Stack/Types/StackT.hs#L67">Haskell Tool Stack</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Constraint synonym for all of the common environment instances</span>
<span class="kw">type</span> <span class="dt">HasEnv</span> r <span class="fu">=</span> (<span class="dt">HasLogOptions</span> r, <span class="dt">HasTerminal</span> r, <span class="dt">HasReExec</span> r, <span class="dt">HasSticky</span> r)

<span class="co">-- | Constraint synonym for constraints commonly satisifed by monads used in stack.</span>
<span class="kw">type</span> <span class="dt">StackM</span> r m <span class="fu">=</span>
    (<span class="dt">MonadReader</span> r m, <span class="dt">MonadIO</span> m, <span class="dt">MonadBaseControl</span> <span class="dt">IO</span> m, <span class="dt">MonadLoggerIO</span> m, <span class="dt">MonadMask</span> m, <span class="dt">HasEnv</span> r)</code></pre></div>
<p>Or we can define <code>Func</code> in terms of two type arguments <code>ctx</code> and <code>a</code> where <code>ctx</code> is a context of kind <code>* -&gt; Constraint</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Func</span> cxt a <span class="fu">=</span> cxt a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a

<span class="ot">inc ::</span> <span class="dt">Func</span> <span class="dt">Num</span> a
inc <span class="fu">=</span> (<span class="fu">+</span><span class="dv">1</span>)</code></pre></div>
<h1 id="constraint-families">Constraint families</h1>
<p>Constraint families allow constraints to be indexed by a type in the same way that type families and data families allow types to be indexed by types.</p>
<p>For example, constraint families let us define a generalized version of the <code>Monad</code> class where we can impose some constraints on the element it can contain. Wolfgang Jeltsch’s <a href="https://jeltsch.wordpress.com/2013/02/14/the-constraint-kind/">The Constraint kind</a> and Max Bolingbroke’s <a href="http://blog.omega-prime.co.uk/?p=127">Constraint Kinds for GHC</a> explain this classic example in details.</p>
<p><a href="https://hackage.haskell.org/package/rmonad">rmonad</a> provides a collection of restricted monads based on associated datatypes.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">RMonad</span> m <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">RMonadCtxt</span> m<span class="ot"> a ::</span> <span class="dt">Constraint</span>
  <span class="kw">type</span> <span class="dt">RMonadCtxt</span> m a <span class="fu">=</span> ()

<span class="ot">  return ::</span> <span class="dt">RMonadCtxt</span> m a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m a
<span class="ot">  (&gt;&gt;=) ::</span> (<span class="dt">RMonadCtxt</span> m a, <span class="dt">RMonadCtxt</span> m b) <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b

<span class="kw">instance</span> <span class="dt">RMonad</span> <span class="dt">S.Set</span> <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">RMonadCtxt</span> <span class="dt">S.Set</span> a <span class="fu">=</span> <span class="dt">Ord</span> a
  return <span class="fu">=</span> S.singleton
  mx <span class="fu">&gt;&gt;=</span> fxmy <span class="fu">=</span> S.fromList [y <span class="fu">|</span> x <span class="ot">&lt;-</span> S.toList mx, y <span class="ot">&lt;-</span> S.toList (fxmy x)]      

<span class="kw">instance</span> <span class="dt">RMonad</span> [] <span class="kw">where</span>
  return x <span class="fu">=</span> [x]
  (<span class="fu">&gt;&gt;=</span>) <span class="fu">=</span> flip concatMap</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-13-constraint-kinds.html";
    this.page.identifier = "/posts/2017-01-13-constraint-kinds.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Fri, 13 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-13-constraint-kinds.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Indexed Monads</title>
    <link>http://kseo.github.io//posts/2017-01-12-indexed-monads.html</link>
    <description><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January 12, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/indexed.html">indexed</a>, <a href="/tags/monad.html">monad</a>
      
  </div>

<p>In this post, I am going to introduce <em>indexed monads</em>, which generalize monads with additional type parameters carrying the information about the computational effects.</p>
<h1 id="motivation">Motivation</h1>
<p>The State monad represents computations with a state that can be queried and updated. For example, an <code>Int</code> state is queried and updated during the computation of <code>c</code> in the following example. While the value of the state is changed from <code>0</code> to <code>1</code>, the type of the state remains the same during the entire computation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.State</span>

test1 <span class="fu">=</span> runState c (<span class="dv">0</span><span class="ot">::</span><span class="dt">Int</span>) <span class="kw">where</span>
         c <span class="fu">=</span> <span class="kw">do</span>
             v <span class="ot">&lt;-</span> get
             put (succ v)
             return v
<span class="co">-- (0, 1)</span></code></pre></div>
<p>This is okay in most cases, but we sometimes want to express a computation where not only the value but also the type of the state can be changed. The vanilla State monad is not general enough to express this requirement.</p>
<h1 id="indexed-monads">Indexed Monads</h1>
<p>Indexed monads are a generalization of monads that index each monadic type by an initial (type)state and a final (type)state. <code>m</code> is a type constructor for three type arguments, <code>p</code>, <code>q</code> and <code>a</code>. The argument <code>a</code> is the type of values produced by the monadic computation. <code>p</code> and <code>q</code> represent the types of the state before and after the computation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">IxMonad</span> m <span class="kw">where</span>
<span class="ot">    ireturn ::</span> a <span class="ot">-&gt;</span> m p p a
<span class="ot">    ibind ::</span> m p q a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m q r b) <span class="ot">-&gt;</span> m p r b</code></pre></div>
<p><code>ireturn</code> and <code>ibind</code> must meet the monad laws as the ordinary monads do. <code>ibind</code> is required to be associative and <code>ireturn</code> to be the left and the right unit of <code>ibind</code>.</p>
<p>All ordinary monads can be injected into <code>IxMonad</code> with a newtype wrapper <code>MW</code>. It is a <em>phantom type</em> as the type parameters <code>p</code> and <code>q</code> are not used on the right hand-side of <code>MW</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">MW</span> m p q a <span class="fu">=</span> <span class="dt">MW</span> {<span class="ot"> unMW::</span> m a }

<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">IxMonad</span> (<span class="dt">MW</span> m) <span class="kw">where</span>
    ireturn <span class="fu">=</span> <span class="dt">MW</span> <span class="fu">.</span> return
    ibind (<span class="dt">MW</span> m) f <span class="fu">=</span> <span class="dt">MW</span> (m <span class="fu">&gt;&gt;=</span> unMW <span class="fu">.</span> f)</code></pre></div>
<p>Here is an example of using the ordinary <code>State</code> monad wrapped with <code>MW</code>. <code>iget</code> and <code>iput</code> wraps the result with <code>MW</code> newtype wrapper.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">iget ::</span> (<span class="dt">MonadState</span> s m) <span class="ot">=&gt;</span> <span class="dt">MW</span> m s s s
iget <span class="fu">=</span> <span class="dt">MW</span> get

<span class="ot">iput ::</span> (<span class="dt">MonadState</span> s m) <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">MW</span> m s s ()
iput <span class="fu">=</span> <span class="dt">MW</span> <span class="fu">.</span> put

test2 <span class="fu">=</span> runState (unMW c) (<span class="dv">0</span><span class="ot">::</span><span class="dt">Int</span>) <span class="kw">where</span>
         c <span class="fu">=</span> iget <span class="ot">`ibind`</span> (
               \v <span class="ot">-&gt;</span> iput (succ v) <span class="ot">`ibind`</span> (
                 \_ <span class="ot">-&gt;</span> ireturn v))
<span class="co">-- (0, 1)</span></code></pre></div>
<h1 id="indexed-state-monad">Indexed State Monad</h1>
<p><code>IxStateT</code> defines an indexed state monad where <code>si</code> and <code>so</code> represents the input and the output state type respectively. The definition of <code>IxStateT</code> is similar to that of <code>StateT</code> except that the type of the state can be changed during the computation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">IxStateT</span> m si so v <span class="fu">=</span> <span class="dt">IxStateT</span> {<span class="ot"> runIxStateT::</span> si <span class="ot">-&gt;</span> m (so,v) }

<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">IxMonad</span> (<span class="dt">IxStateT</span> m) <span class="kw">where</span>
  ireturn x <span class="fu">=</span> <span class="dt">IxStateT</span> (\si <span class="ot">-&gt;</span> return (si,x))
  ibind (<span class="dt">IxStateT</span> m) f <span class="fu">=</span> <span class="dt">IxStateT</span> (\si <span class="ot">-&gt;</span> m si <span class="fu">&gt;&gt;=</span> (\ (sm,x) <span class="ot">-&gt;</span> runIxStateT (f x) sm))

<span class="ot">vsget ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">IxStateT</span> m si si si
vsget <span class="fu">=</span> <span class="dt">IxStateT</span> (\si <span class="ot">-&gt;</span> return (si,si))

<span class="ot">vsput ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> so <span class="ot">-&gt;</span> <span class="dt">IxStateT</span> m si so ()
vsput x <span class="fu">=</span> <span class="dt">IxStateT</span> (\si <span class="ot">-&gt;</span> return (x,()))</code></pre></div>
<p>The following example gets an <code>Int</code> from the state and puts a <code>String</code> into the state. We can see that the type of the state is changed from <code>Int</code> to <code>String</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">test3 <span class="fu">=</span> runIxStateT c (<span class="dv">0</span><span class="ot">::</span><span class="dt">Int</span>) <span class="fu">&gt;&gt;=</span> print <span class="kw">where</span>
         c <span class="fu">=</span> vsget <span class="ot">`ibind`</span> (
               \v <span class="ot">-&gt;</span> vsput (show v) <span class="ot">`ibind`</span> (
                 \_ <span class="ot">-&gt;</span> vsget <span class="ot">`ibind`</span> (
                   \v&#39; <span class="ot">-&gt;</span> ireturn (v,v&#39;))))
<span class="co">-- (&quot;0&quot;,(0,&quot;0&quot;))</span></code></pre></div>
<h1 id="do-notation">Do notation</h1>
<p>The <code>IxMonad</code> examples above looks ugly as we couldn’t use the do notation. Fortunately, <code>-XRebindableSyntax</code> extension allows us to overload the do-notation by providing alternative definitions that are local to the module.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RebindableSyntax #-}</span>

<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> ((&gt;&gt;=), (&gt;&gt;), return)
<span class="kw">import </span><span class="dt">IxState</span>

return<span class="ot"> ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IxStateT</span> m si si a
return <span class="fu">=</span> ireturn

<span class="ot">(&gt;&gt;=) ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">IxStateT</span> m p q a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IxStateT</span> m q r b) <span class="ot">-&gt;</span> <span class="dt">IxStateT</span> m p r b
(<span class="fu">&gt;&gt;=</span>) <span class="fu">=</span> ibind

<span class="ot">(&gt;&gt;) ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">IxStateT</span> m p q a <span class="ot">-&gt;</span> <span class="dt">IxStateT</span> m q r b <span class="ot">-&gt;</span> <span class="dt">IxStateT</span> m p r b
v <span class="fu">&gt;&gt;</span> w <span class="fu">=</span> v <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> w

<span class="ot">c ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">IxStateT</span> m <span class="dt">Int</span> <span class="dt">String</span> (<span class="dt">Int</span>, <span class="dt">String</span>)
c <span class="fu">=</span> <span class="kw">do</span>
  v <span class="ot">&lt;-</span> vsget
  vsput (show v)
  v&#39; <span class="ot">&lt;-</span> vsget
  return (v, v&#39;)</code></pre></div>
<h1 id="other-definitions">Other definitions</h1>
<p>There are multiple ways to define indexed monads. The one used here is from Robert Atkey’s <a href="http://bentnib.org/paramnotions-jfp.pdf">Parameterised Notions of Computation</a>.</p>
<p>Other definitions include:</p>
<ul>
<li>McBride: <a href="https://personal.cis.strath.ac.uk/conor.mcbride/Kleisli.pdf">Kleisli Arrows of Outrageous Fortune</a></li>
<li>Orchard: <a href="http://www.cl.cam.ac.uk/~dao29/ixmonad/ixmonad-fita14.pdf">Fun with indexed monads</a></li>
</ul>
<h1 id="references">References</h1>
<ol style="list-style-type: decimal">
<li>Oleg Kiselyov’s <a href="http://okmij.org/ftp/Computation/monads.html#param-monad">Parameterized `monad’</a></li>
<li><a href="http://dev.stephendiehl.com/hask/#indexed-monads">Indexed Monad section</a> of Stephen Diehl’s What I Wish I Knew When Learning Haskell</li>
</ol>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-12-indexed-monads.html";
    this.page.identifier = "/posts/2017-01-12-indexed-monads.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Thu, 12 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-12-indexed-monads.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Double-barrelled Continuation Passing Style Interpreter</title>
    <link>http://kseo.github.io//posts/2017-01-10-double-barrelled-continuation-passing-style-interpreter.html</link>
    <description><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January 10, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/double-barrelled.html">double-barrelled</a>, <a href="/tags/CPS.html">CPS</a>, <a href="/tags/interpreter.html">interpreter</a>
      
  </div>

<p>In the <a href="https://kseo.github.io/posts/2017-01-09-continuation-passing-style-interpreter.html">Continuation Passing Style Interpreter</a>, we wrote a continuation-passing style interpreter for a small functional language and implemented the <em>escape expression</em> which is the binder form of Scheme’s <em>call/cc</em>.</p>
<p>Though <em>call/cc</em> is a powerful control operator, it is generally considered as a <a href="http://okmij.org/ftp/continuations/against-callcc.html">bad abstraction</a> as a core language feature. So, in this post, we will drop escape expressions and add ML-style exceptions.</p>
<p>Exceptions can be used to effect non-local transfers of control. By using an <em>exception handler</em> we may “catch” a raised exception and continue evaluation. For example,</p>
<pre><code>1 + (raise 2)
handle \x -&gt; x + 3</code></pre>
<p>evaluates to <code>5</code> because <code>2</code> raised by <code>raise 2</code> is passed to the exception handler <code>\x -&gt; x + 3</code>.</p>
<p>To support exceptions in our interpreter, <code>eval</code> function is modified to take two continuations: an exception-handler continuation, and a return continuation. This is the so-called <em>double-barrelled continuation-passing style</em> introduced in <a href="http://www.cs.bham.ac.uk/~hxt/research/HOSC-double-barrel.pdf">Comparing Control Constructs by Double-barrelled CPS</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eval ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
eval env term h k <span class="fu">=</span> <span class="kw">case</span> term <span class="kw">of</span>
  <span class="dt">Var</span> n <span class="ot">-&gt;</span> k <span class="fu">$</span> env <span class="fu">!!</span> n
  <span class="dt">Lam</span> a <span class="ot">-&gt;</span> k <span class="fu">$</span> <span class="dt">VClosure</span> (\v k&#39; <span class="ot">-&gt;</span> eval (v <span class="fu">:</span> env) a h k&#39;)
  <span class="dt">App</span> a b <span class="ot">-&gt;</span>
    eval env a h <span class="fu">$</span> \(<span class="dt">VClosure</span> c) <span class="ot">-&gt;</span>
    eval env b h <span class="fu">$</span> \v <span class="ot">-&gt;</span>
    c v k

  <span class="dt">Lit</span> n <span class="ot">-&gt;</span> k <span class="fu">$</span> <span class="dt">VInt</span> n
  <span class="dt">Prim</span> p a b <span class="ot">-&gt;</span> eval env a h <span class="fu">$</span> \v1 <span class="ot">-&gt;</span>
                eval env b h <span class="fu">$</span> \v2 <span class="ot">-&gt;</span>
                k <span class="fu">$</span> evalPrim p v1 v2

<span class="ot">evalExpr ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
evalExpr e <span class="fu">=</span> eval emptyEnv e (\x <span class="ot">-&gt;</span> error <span class="st">&quot;uncaught exception&quot;</span>) id</code></pre></div>
<p><code>h</code> is the exception-handler continuation and it is simply passed along the application of <code>eval</code>. <code>evalExpr</code> is also modified to handle an uncaught exception.</p>
<p>Once our interpreter is transformed into a double-barrelled continuation-passing style, it is easy to add handle and raise expressions. First, let’s extend <code>Expr</code> with <code>Handle</code> and <code>Raise</code> nodes.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="fu">...</span>
  <span class="fu">|</span> <span class="dt">Handle</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Raise</span> <span class="dt">Expr</span>
  <span class="fu">...</span></code></pre></div>
<p>Then extend <code>eval</code> function with two additional AST nodes.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eval ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
eval env term h k <span class="fu">=</span> <span class="kw">case</span> term <span class="kw">of</span>
  <span class="fu">...</span>
  <span class="dt">Raise</span> a <span class="ot">-&gt;</span> eval env a h h
  <span class="dt">Handle</span> a b <span class="ot">-&gt;</span>
    <span class="kw">let</span> h&#39; x <span class="fu">=</span> eval (x <span class="fu">:</span> env) b h k
    <span class="kw">in</span> eval env a h&#39; k</code></pre></div>
<p><code>Raise</code> evaluates <code>a</code> with both continuations set to the error-handler continuation <code>h</code>. So the value is passed to the current error-handler.</p>
<p><code>Handle</code> sets up a new error-handler <code>h'</code> which evaluates <code>b</code> with the environment extended with the raised value <code>x</code>. Note that <code>a</code> is evaluated with the error-handler set to <code>h'</code> so that any exception raised while evaluating <code>a</code> is passed to <code>h'</code>.</p>
<p>Let’s run the example above!</p>
<pre><code>λ&gt; evalExpr $ (Prim Add (Lit 1) (Raise (Lit 2))) `Handle` (Prim Add (Var 0) (Lit 3))
5</code></pre>
<p>Yay, it works again!</p>
<p>If you would like to know why we can’t implement exceptions using <em>call/cc</em> alone, please read Oleg Kiselyov’s article <a href="http://okmij.org/ftp/continuations/undelimited.html#delim-vs-undelim">Vast difference between delimited and undelimited continuations</a>.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-10-double-barrelled-continuation-passing-style-interpreter.html";
    this.page.identifier = "/posts/2017-01-10-double-barrelled-continuation-passing-style-interpreter.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Tue, 10 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-10-double-barrelled-continuation-passing-style-interpreter.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Continuation Passing Style Interpreter</title>
    <link>http://kseo.github.io//posts/2017-01-09-continuation-passing-style-interpreter.html</link>
    <description><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January  9, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/CPS.html">CPS</a>, <a href="/tags/interpreter.html">interpreter</a>
      
  </div>

<p>Lisp programmers learn Lisp by writing various flavors of Lisp interpreters. Two famous Lisp books, <a href="https://www.amazon.com/Lisp-Small-Pieces-Christian-Queinnec/dp/0521545668">Lisp in Small Pieces</a> and <a href="http://www.eopl3.com/">Essentials of Programming Languages</a>, teach us how to write Lisp interpreters in Lisp. Both books start with a direct style interpreter which is easy to implement. But they soon rewrite the interpreter in a continuation passing style because advanced control structures such as <em>abort</em> and <em>call/cc</em> can be implemented more easily in this style.</p>
<p>In this post, we will follow the tradition of Lisp and will write a continuation passing style interpreter for a small functional language in Haskell. Then we will see how easily we can add <em>escape expression</em> to the language by extending the interpreter.</p>
<h1 id="direct-style-interpreter">Direct-style Interpreter</h1>
<p>Our first interpreter is a straightforward implementation of the enriched lambda calculus <code>Expr</code>. It extends the lambda calculus with integer literals and primitive operators.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Lam</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Lit</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Prim</span> <span class="dt">PrimOp</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">data</span> <span class="dt">PrimOp</span> <span class="fu">=</span> <span class="dt">Add</span> <span class="fu">|</span> <span class="dt">Mul</span>
  <span class="kw">deriving</span> <span class="dt">Show</span></code></pre></div>
<p>The central component of our interpreter is a function <code>eval</code> that produces the value of an expression <code>term</code> in an environment <code>env</code>. <code>n</code> in <code>Var n</code> is the <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">De Bruijn index</a>. The <a href="http://dev.stephendiehl.com/fun/005_evaluation.html">Evaluation</a> chapter of Stephen Diehl’s <a href="http://dev.stephendiehl.com/fun/index.html">Write You a Haskell</a> explains the details of this direct-style interpreter. There is one difference here. Our version uses a higher-order function to represent lambda expression (<code>VClosure</code>).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Value</span>
  <span class="fu">=</span> <span class="dt">VInt</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">VClosure</span> (<span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>)

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Value</span> <span class="kw">where</span>
  show (<span class="dt">VInt</span> i) <span class="fu">=</span> show i
  show <span class="dt">VClosure</span>{} <span class="fu">=</span> <span class="st">&quot;&lt;&lt;closure&gt;&gt;&quot;</span>

<span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> [<span class="dt">Value</span>]

<span class="ot">eval ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
eval env term <span class="fu">=</span> <span class="kw">case</span> term <span class="kw">of</span>
  <span class="dt">Var</span> n <span class="ot">-&gt;</span> env <span class="fu">!!</span> n
  <span class="dt">Lam</span> a <span class="ot">-&gt;</span> <span class="dt">VClosure</span> (\v <span class="ot">-&gt;</span> eval (v <span class="fu">:</span> env) a)
  <span class="dt">App</span> a b <span class="ot">-&gt;</span>
    <span class="kw">let</span> <span class="dt">VClosure</span> c <span class="fu">=</span> eval env a <span class="kw">in</span>
    <span class="kw">let</span> v <span class="fu">=</span> eval env b <span class="kw">in</span>
    c v

  <span class="dt">Lit</span> n <span class="ot">-&gt;</span> <span class="dt">VInt</span> n
  <span class="dt">Prim</span> p a b <span class="ot">-&gt;</span> (evalPrim p) (eval env a) (eval env b)

<span class="ot">evalPrim ::</span> <span class="dt">PrimOp</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
evalPrim <span class="dt">Add</span> (<span class="dt">VInt</span> a) (<span class="dt">VInt</span> b) <span class="fu">=</span> <span class="dt">VInt</span> (a <span class="fu">+</span> b)
evalPrim <span class="dt">Mul</span> (<span class="dt">VInt</span> a) (<span class="dt">VInt</span> b) <span class="fu">=</span> <span class="dt">VInt</span> (a <span class="fu">*</span> b)

<span class="ot">emptyEnv ::</span> <span class="dt">Env</span>
emptyEnv <span class="fu">=</span> []

<span class="ot">evalExpr ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
evalExpr <span class="fu">=</span> eval emptyEnv</code></pre></div>
<h1 id="continuation-passing-style-interpreter">Continuation-passing-style Interpreter</h1>
<p>We can think of a continuation as what to do next in a program. In direct-style, a callee returns a value to the caller. Thus the caller of the function determines what to do next and the continuation is implicitly present in the caller. In continuation-passing-style, the continuation is passed as an argument of a function and the callee determines what to do next by invoking the continuation. A function in continuation-passing-style never returns.</p>
<p>We can transform our interpreter into a continuation-passing-style by adding a continuation argument <code>Cont</code> to <code>eval</code> and <code>VClosure</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Cont</span> <span class="fu">=</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>

<span class="kw">data</span> <span class="dt">Value</span>
  <span class="fu">=</span> <span class="fu">...</span>
  <span class="fu">|</span> <span class="dt">VClosure</span> (<span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>)

<span class="ot">eval ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
eval env term k <span class="fu">=</span> <span class="kw">case</span> term <span class="kw">of</span>
  <span class="dt">Var</span> n <span class="ot">-&gt;</span> k <span class="fu">$</span> env <span class="fu">!!</span> n
  <span class="dt">Lam</span> a <span class="ot">-&gt;</span> k <span class="fu">$</span> <span class="dt">VClosure</span> (\v k&#39; <span class="ot">-&gt;</span> eval (v <span class="fu">:</span> env) a k&#39;)
  <span class="dt">App</span> a b <span class="ot">-&gt;</span>
    eval env a <span class="fu">$</span> \(<span class="dt">VClosure</span> c) <span class="ot">-&gt;</span>
    eval env b <span class="fu">$</span> \v <span class="ot">-&gt;</span>
    c v k

  <span class="dt">Lit</span> n <span class="ot">-&gt;</span> k <span class="fu">$</span> <span class="dt">VInt</span> n
  <span class="dt">Prim</span> p a b <span class="ot">-&gt;</span> eval env a <span class="fu">$</span> \v1 <span class="ot">-&gt;</span>
                eval env b <span class="fu">$</span> \v2 <span class="ot">-&gt;</span>
                k <span class="fu">$</span> evalPrim p v1 v2

<span class="ot">evalExpr ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
evalExpr e <span class="fu">=</span> eval emptyEnv e id</code></pre></div>
<p>In <code>Var</code>, <code>Lit</code> and <code>Lam</code> cases, <code>eval</code> simply applies the value to the continuation. In <code>App</code> case, <code>eval</code> evaluates the function first and then subsequently evaluates the argument. The evaluation order is enforced as only one value can be passed to the continuation. <code>c v</code> applies the argument to the function and its result is passed to the original continuation <code>k</code>. <code>Prim</code> case similarly enforces the left-to-right evaluation order.</p>
<p><code>evalExpr</code> passes <code>id</code> as the initial continuation which merely returns the value back.</p>
<h1 id="escape-expression">Escape Expression</h1>
<p>Because all the control paths are explicit in continuation-passing-style, we can easily add control operators to our interpreter. Let’s extend our interpreter with <em>escape expressions</em> that was first introduced in <a href="http://surface.syr.edu/cgi/viewcontent.cgi?article=1012&amp;context=lcsmith_other">Definitional interpreters for higher-order programming languages</a>.</p>
<pre><code>escape x in r</code></pre>
<p>is an escape expression, whose <em>escape variable</em> is <code>x</code> and whose <em>body</em> is <code>r</code>. If <code>x</code> is applied to <code>a</code> in <code>r</code>, the body is aborted and <code>a</code> is returned. Otherwise, the evaluation of <code>r</code> proceeds normally.</p>
<pre><code>escape x in (1 + 3) * (4 + x 10)</code></pre>
<p>evaluates to <code>10</code> because <code>x</code> is applied to <code>10</code> inside the escape expression.</p>
<p>The implementation of the escape expression is one-liner. <code>eval</code> of <code>Escape a</code> adds a closure to the environment and then evaluates the expression. This closure is a reified continuation which ignores the current continuation and passes the argument as a value to the saved continuation of the escape expression.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="fu">...</span>
  <span class="fu">|</span> <span class="dt">Escape</span> <span class="dt">Expr</span>
  <span class="fu">...</span>

<span class="ot">eval ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
eval env term k <span class="fu">=</span> <span class="kw">case</span> term <span class="kw">of</span>
  <span class="fu">...</span>
  <span class="dt">Escape</span> a <span class="ot">-&gt;</span> eval (<span class="dt">VClosure</span> (\v _ <span class="ot">-&gt;</span> k v) <span class="fu">:</span> env) a k</code></pre></div>
<pre><code>λ&gt; evalExpr $ Escape (Prim Mul (Prim Add (Lit 1) (Lit 3)) (Prim Add (Lit 4) (App (Var 0) (Lit 10))))
10</code></pre>
<p>Yay, it works!</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-09-continuation-passing-style-interpreter.html";
    this.page.identifier = "/posts/2017-01-09-continuation-passing-style-interpreter.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Mon, 09 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-09-continuation-passing-style-interpreter.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Visible Type Application in GHC 8</title>
    <link>http://kseo.github.io//posts/2017-01-08-visible-type-application-ghc8.html</link>
    <description><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January  8, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/TypeApplications.html">TypeApplications</a>
      
  </div>

<p>GHC 8.0 introduced a new GHC extension named <a href="https://ghc.haskell.org/trac/ghc/wiki/TypeApplication">TypeApplications</a> which allows us to give explicit type arguments to a polymorphic function.</p>
<p>To see what <code>TypeApplications</code> does, we need to understand how polymorphism in Haskell is implemented under the hood. In Haskell, a polymorphic function is translated into a function which takes both type arguments and value arguments. For example,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">id<span class="ot"> ::</span> a <span class="ot">-&gt;</span> a
id x <span class="fu">=</span> x</code></pre></div>
<p>is translated into</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">id<span class="ot"> ::</span> forall a <span class="fu">.</span> a <span class="ot">-&gt;</span> a
id <span class="fu">@</span>a x <span class="fu">=</span> x</code></pre></div>
<p>Here <code>@a</code> is the type argument. The specialization of <code>id</code> to <code>idString</code> is represented by passing <code>@String</code> type argument to <code>id</code> function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">idString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
idString <span class="fu">=</span> id <span class="fu">@</span><span class="dt">String</span></code></pre></div>
<p>This is not an ad-hoc way to implement polymorphism. The trick of passing around type parameters as ordinary function arguments was devised by <em>System F</em> (as known as the <em>polymorphic lambda calculus</em>) and GHC uses System F as its internal representation. An interested reader might want to take a look at Gabriel Gonzalez’s <a href="http://www.haskellforall.com/2015/10/polymorphism-for-dummies.html">Polymorphism for dummies</a> for other examples.</p>
<p>Before GHC 8.0, the type application was invisible. There was no way to pass the type parameter such as <code>@String</code> and <code>@Int</code> explicitly. GHC infers the type from the argument type, or we had to specify the type using type annotations.</p>
<pre><code>λ&gt; id &quot;a&quot;
&quot;a&quot;
λ&gt; id (3 :: Int)
3</code></pre>
<p><code>TypeApplications</code> extension allows us to give explicit type arguments.</p>
<pre><code>λ&gt; :set -XTypeApplications
λ&gt; id @String &quot;a&quot;
&quot;a&quot;
λ&gt; id @Int 3
3</code></pre>
<p>This is useful in resolving ambiguity in type classes or type families. The show/read problem from <a href="https://kseo.github.io/posts/2017-01-04-type-defaulting-in-haskell.html">Type defaulting in Haskell</a> was not typeable due to ambiguity, but we can easily remove ambiguity by giving an explicit type argument.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeApplications #-}</span>

<span class="ot">f ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
f s <span class="fu">=</span> show (read <span class="fu">@</span><span class="dt">Int</span> s)</code></pre></div>
<p>The type argument is not limited to concrete types. As we can pass a variable to a function as an argument, it is possible to pass a type variable to a function as a type argument if it is explicitly quantified with <code>ExplicitForAll</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ExplicitForAll      #-}</span>
<span class="ot">{-# LANGUAGE TypeApplications    #-}</span>

<span class="ot">incShow ::</span> forall a <span class="fu">.</span> (<span class="dt">Read</span> a, <span class="dt">Show</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
incShow <span class="fu">=</span> show <span class="fu">.</span> (<span class="fu">+</span><span class="dv">1</span>) <span class="fu">.</span> read <span class="fu">@</span>a</code></pre></div>
<pre><code>λ&gt; incShow @Double &quot;3.0&quot;
&quot;4.0&quot;`</code></pre>
<p>In the following example, <code>g False</code> would be ill-typed because GHC can’t infer the proper type. Adding the explicit type <code>@Char</code> resolves the problem.</p>
<pre><code>type family F a
type instance F Char = Bool

g :: F a -&gt; a
g _ = undefined

f :: Char
f = g True

h = g False -- will cause an error
h&#39; = g @Char False</code></pre>
<p>Some of these cases can be solved with type annotations, but it can be cumbersome in complicated examples. Visible type applications generally provide a more succinct way to resolve ambiguity.</p>
<p>If you would like to know the technical details of <code>TypeApplications</code>, please refer to <a href="https://www.seas.upenn.edu/~sweirich/papers/type-app-extended.pdf">Visible Type Application (Extended version)</a>.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-08-visible-type-application-ghc8.html";
    this.page.identifier = "/posts/2017-01-08-visible-type-application-ghc8.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Sun, 08 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-08-visible-type-application-ghc8.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>

    </channel>
</rss>
