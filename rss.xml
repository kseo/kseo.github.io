<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Haskell for Pragmatic Programmers</title>
        <link>http://kseo.github.io/</link>
        <description><![CDATA[Kwang Yul Seo's Haskell Blog]]></description>
        <atom:link href="http://kseo.github.io//rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sun, 05 Feb 2017 00:00:00 UT</lastBuildDate>
        <item>
    <title>Avoid overlapping instances with closed type families</title>
    <link>http://kseo.github.io//posts/2017-02-05-avoid-overlapping-instances-with-closed-type-families.html</link>
    <description><![CDATA[<p><em>Overlapping instances</em> are one of the most controversial features in Haskell. Fortunately, there are many tricks that let us avoid overlapping instances. In this post, I will introduce one such trick which uses closed type families.</p>
<!--more-->
<h1 id="why-overlapping-instances-are-bad">Why overlapping instances are bad</h1>
<p>In Haskell, we expect adding an extra instance in one module does not cause any other modules that depend on the given module to fail to compile or have different behaviors as long as the dependent modules use explicit import lists.</p>
<p>Unfortunately, <em>OverlappingInstances</em> breaks this expectation.</p>
<ul>
<li>Module A</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="ot">{-# LANGUAGE FunctionalDependencies #-}</span>

<span class="kw">module</span> <span class="dt">A</span> <span class="kw">where</span>

<span class="kw">class</span> <span class="dt">C</span> a b c <span class="fu">|</span> a b <span class="ot">-&gt;</span> c <span class="kw">where</span>
<span class="ot">  f ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c

<span class="kw">instance</span> <span class="dt">C</span> <span class="dt">String</span> a <span class="dt">String</span> <span class="kw">where</span>
  f s _ <span class="fu">=</span> s</code></pre></div>
<ul>
<li>Module B</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">B</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">A</span>(<span class="dt">C</span>(..))

<span class="ot">func ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
func <span class="fu">=</span> f</code></pre></div>
<p><code>func &quot;foo&quot; 3</code> evaluates to <code>&quot;foo&quot;</code>.</p>
<p>Let’s add a new instance declaration in <code>A</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="ot">{-# OVERLAPPING #-}</span> <span class="dt">C</span> <span class="dt">String</span> <span class="dt">Int</span> <span class="dt">String</span> <span class="kw">where</span>
  f s i <span class="fu">=</span> concat <span class="fu">$</span> replicate i s</code></pre></div>
<p>Module <code>B</code> still compiles, but <code>func &quot;foo&quot; 3</code> now evaluates to <code>&quot;foofoofoo&quot;</code> because <code>C String Int String</code> is more specific than <code>C String a String</code>.</p>
<p>Wen can see that adding an extra instance silently broke the backward compatibility. To make the matters worse, there is no way to go back to the old behavior. GHC automatically chooses a more specific instance. In this case, <code>C String Int String</code> is chosen because it is more specific than <code>C String a String</code>.</p>
<h1 id="use-cases-of-overlapping-instances">Use cases of overlapping instances</h1>
<p>Overlapping instances are controversial because they are too useful to remove. Overlapping instances are appealing because they express the common pattern of adding a special case to an existing set of overloaded functions.</p>
<p>Let’s check how <code>show</code> method from Prelude handles a list.</p>
<pre><code>λ&gt; show [1,2,3]
&quot;[1,2,3]&quot;
λ&gt; show [False, True, False]
&quot;[False,True,False]&quot;</code></pre>
<p>It converts a given list to a string by putting a comma between elements. According to the rule, it must show <code>&quot;foo&quot;</code> as <code>['f', 'o', 'o']</code>. But <code>show</code> handles a string (a list of characters) in a different manner.</p>
<pre><code>λ&gt; show &quot;abc&quot;
&quot;\&quot;abc\&quot;&quot;</code></pre>
<p>This requires overlapping instances because <code>[a]</code> overlaps with <code>[Char]</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> [a] <span class="kw">where</span>
  <span class="fu">...</span>

<span class="kw">instance</span> <span class="ot">{-# OVERLAPPING #-}</span> <span class="dt">Show</span> [<span class="dt">Char</span>] <span class="kw">where</span>
  <span class="fu">...</span></code></pre></div>
<h1 id="haskell-98-solution">Haskell 98 solution</h1>
<p>Haskell Prelude avoided overlapping instances by using the extra-method trick. The trick does not require any GHC extensions, but class definitions become more complicated. Interested readers are referred to Brandon Simmons’s <a href="http://brandon.si/code/how-the-haskell-prelude-avoids-overlapping-types-in-show/">How the Haskell Prelude Avoids Overlapping Instances in Show</a> for the details.</p>
<h1 id="another-solution-with-closed-type-families">Another solution with closed type families</h1>
<p>This solution is a variation of the solution introduced in Overcoming Overlapping section of Oleg Kiselyov’s <a href="http://okmij.org/ftp/Haskell/typeEQ.html#without-over">Type equality predicates: from OverlappingInstances to overcoming them</a>.</p>
<p>Here’s the list of GHC extensions and imports we need.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>

<span class="kw">import </span><span class="dt">Data.Proxy</span></code></pre></div>
<p><code>F</code> is a type-level function which returns <code>'True</code> for <code>Char</code> and <code>'False</code> for any other types. This does not require overlapping instances because the set of special cases are closed.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family (<span class="dt">F</span> a)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span>
  <span class="dt">F</span> <span class="dt">Char</span>  <span class="fu">=</span> <span class="ch">&#39;True</span>
  <span class="dt">F</span> a     <span class="fu">=</span> <span class="ch">&#39;False</span></code></pre></div>
<p><code>ShowList</code> class defines <code>showl</code> method.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">ShowList</span> a <span class="kw">where</span>
<span class="ot">  showl ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre></div>
<p>The type checker computes the type of <code>flag</code> by evaluating <code>F a</code> and dispatches the method based on the type of <code>flag</code>. If it is <code>'True</code>, it searches the special case instances. Otherwise, it searches the generic case instance.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">F</span> a <span class="fu">~</span> flag, <span class="dt">ShowList&#39;</span> flag a) <span class="ot">=&gt;</span> <span class="dt">ShowList</span> a <span class="kw">where</span>
  showl <span class="fu">=</span> showl&#39; (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> flag)

<span class="kw">class</span> <span class="dt">ShowList&#39;</span> (<span class="ot">flag ::</span> <span class="dt">Bool</span>) a <span class="kw">where</span>
<span class="ot">  showl&#39; ::</span> <span class="dt">Proxy</span> flag <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">String</span>

<span class="kw">instance</span> <span class="dt">ShowList&#39;</span> <span class="ch">&#39;True Char where</span>
  showl&#39; _ x <span class="fu">=</span> x

<span class="kw">instance</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">ShowList&#39;</span> <span class="ch">&#39;False a where</span>
  showl&#39; _ x <span class="fu">=</span> show x</code></pre></div>
<p>We can add another special case for <code>Bool</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family (<span class="dt">F</span> a)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span>
  <span class="dt">F</span> <span class="dt">Char</span>  <span class="fu">=</span> <span class="ch">&#39;True</span>
  <span class="dt">F</span> <span class="dt">Bool</span>  <span class="fu">=</span> <span class="ch">&#39;True</span>
  <span class="dt">F</span> a     <span class="fu">=</span> <span class="ch">&#39;False</span>

<span class="kw">instance</span> <span class="dt">ShowList&#39;</span> <span class="ch">&#39;True Bool where</span>
  showl&#39; _ x <span class="fu">=</span> map toBinaryDigit x
    <span class="kw">where</span> toBinaryDigit <span class="dt">False</span> <span class="fu">=</span> <span class="ch">&#39;0&#39;</span>
          toBinaryDigit <span class="dt">True</span>  <span class="fu">=</span> <span class="ch">&#39;1&#39;</span></code></pre></div>
<p>Now <code>showList [True,False,True]</code> evaluates to <code>101</code> instead of <code>[True,False,True]</code>.</p>
<h1 id="other-solutions">Other solutions</h1>
<p>Oleg Grenrus’s <a href="https://gist.github.com/phadej/cae76444548b9cffa10d9675e013847b">gist</a> contains other workarounds for <em>OverlappingInstances</em>.</p>]]></description>
    <pubDate>Sun, 05 Feb 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-02-05-avoid-overlapping-instances-with-closed-type-families.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Context reduction</title>
    <link>http://kseo.github.io//posts/2017-02-02-context-reduction.html</link>
    <description><![CDATA[<p>Hello, Haskellers! Today I am going to explain what <em>context reduction</em> is and why it is necessary.</p>
<!--more-->
<h1 id="quiz">Quiz</h1>
<p>Let’s start with a quick quiz. What’s the type of <code>f</code>?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f xs y  <span class="fu">=</span>  xs <span class="fu">==</span> [y]</code></pre></div>
<p>The return type <code>f</code> must be <code>Bool</code> because the type of <code>==</code> is <code>Eq a =&gt; a -&gt; a -&gt; Bool</code>. If we assume the type of <code>y</code> is <code>t</code>, the type of <code>xs</code> must be <code>[t]</code> because two operands of <code>==</code> must have the same type. The type constraint must be <code>Eq [t]</code> because two lists are compared for equality. So we expect the type of <code>f</code> should be <code>Eq [t] =&gt; [t] -&gt; t -&gt; Bool</code>.</p>
<p>Let’s check the type in GHCi.</p>
<pre><code>λ&gt; f xs y  =  xs == [y]
f :: Eq t =&gt; [t] -&gt; t -&gt; Bool</code></pre>
<p>Surprisingly, the context is <code>Eq t</code> instead of <code>Eq [t]</code>. Even though the equality is taken at the list type, the context must be simplified. This is called <em>context reduction</em> and is specified in <a href="https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-620004">Haskell 2010 Language Report</a> (also in Haskell 98).</p>
<h1 id="context-reduction">Context reduction</h1>
<p><a href="https://arxiv.org/pdf/cs/0006034.pdf">Type Classes and Constraint Handling Rules</a> mentions two reasons why context reduction in Haskell is important.</p>
<ol style="list-style-type: decimal">
<li>Syntactically, context reduction allows the type checker to present type class constraints to the programmer in a more readable form.</li>
<li>Operationally, context reduction allows the type checker to put type class constraints into a more efficient form. Type class constraints are translated into dictionaries. Hence, simplifying type class constraints may allow a more efficient translation.</li>
</ol>
<p>Let’s visit each reason with concrete examples.</p>
<h1 id="readability">Readability</h1>
<p>What’s the type of <code>g</code>?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">g a b <span class="fu">=</span> [show (a,a), show (a,b), show (b,a), show(b,b)]</code></pre></div>
<p>If the type checker infers the type without simplification, it will be</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">g ::</span> (<span class="dt">Show</span> (a,a), <span class="dt">Show</span>(b,b), <span class="dt">Show</span> (a,b), <span class="dt">Show</span> (b, a)) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [<span class="dt">String</span>]</code></pre></div>
<p>But Haskell simplifies the context to</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">g ::</span> (<span class="dt">Show</span> b, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [<span class="dt">String</span>]</code></pre></div>
<p>The inferred type looks simpler to programmers.</p>
<p>Surprisingly, GHCi reports the simplified type even though I explicitly annotate the type with the former.</p>
<pre><code>λ&gt; :type g
g :: (Show b, Show a) =&gt; a -&gt; b -&gt; [String]</code></pre>
<h1 id="efficient-translation">Efficient translation</h1>
<p>GHC implements type classes as dictionary passing. Readers are referred to Section 4 of <a href="http://people.csail.mit.edu/dnj/teaching/6898/papers/wadler88.pdf">How to make ad-hoc polymorphism less ad hoc</a> for the details.</p>
<p>Let’s see how type classes are actually translated by dumping the GHC simplifier output.</p>
<pre><code>ghc -ddump-simpl -ddump-to-file -c a.hs</code></pre>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# NOINLINE f #-}</span>
<span class="ot">f ::</span> (<span class="dt">Eq</span> a, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
f x y <span class="fu">=</span> x <span class="fu">&gt;</span> y

main <span class="fu">=</span> print <span class="fu">$</span> f <span class="dv">1</span> <span class="dv">2</span></code></pre></div>
<p><code>g_rn6</code> takes two dictionary arguments though the first one is never used (marked as <code>Dead</code>).</p>
<pre><code>f_rn6
  :: forall a_aoY. (Eq a_aoY, Ord a_aoY) =&gt; a_aoY -&gt; a_aoY -&gt; Bool
[GblId, Arity=4, Caf=NoCafRefs, Str=DmdType]
f_rn6 =
  \ (@ a_a1vN)
    _ [Occ=Dead]
    ($dOrd_a1vP :: Ord a_a1vN)
    (x_a1rc :: a_a1vN)
    (y_a1rd :: a_a1vN) -&gt;
    &gt; @ a_a1vN $dOrd_a1vP x_a1rc y_a1rd</code></pre>
<p>Call sites of <code>g</code> must create and pass these dictionary arguments when they call <code>g</code>.</p>
<pre><code>main :: IO ()
[GblId, Str=DmdType]
main =
  print
    @ Bool
    GHC.Show.$fShowBool
    (f_rn6
       @ Integer
       integer-gmp-1.0.0.1:GHC.Integer.Type.$fEqInteger
       integer-gmp-1.0.0.1:GHC.Integer.Type.$fOrdInteger
       1
       2)</code></pre>
<p>Simplifying type class constraints allow a more efficient translation because it removes redundant dictionary arguments.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# NOINLINE f #-}</span>
f x y <span class="fu">=</span> x <span class="fu">&gt;</span> y

main <span class="fu">=</span> print <span class="fu">$</span> f <span class="dv">1</span> <span class="dv">2</span></code></pre></div>
<p>is translated to</p>
<pre><code>f_rn6 :: forall a_a1vz. Ord a_a1vz =&gt; a_a1vz -&gt; a_a1vz -&gt; Bool
[GblId, Arity=3, Caf=NoCafRefs, Str=DmdType]
f_rn6 =
  \ (@ a_a1vz)
    ($dOrd_a1zP :: Ord a_a1vz)
    (x_aoY :: a_a1vz)
    (y_aoZ :: a_a1vz) -&gt;
    &gt; @ a_a1vz $dOrd_a1zP x_aoY y_aoZ</code></pre>
<p><code>g_rn6</code> takes only one dictionary argument <code>$dOrd_a1zP</code> because context reduction merged <code>(Eq a, Ord a)</code> into <code>Ord a</code>. This is a valid simplification because <code>Ord a</code> implies <code>Eq a</code>.</p>
<h1 id="formal-semantics">Formal semantics</h1>
<p>The Haskell report provides only informal hints about context reduction.</p>
<p>Fortunately, Section 7.4 of Mark P. Jones’ <a href="http://web.cecs.pdx.edu/~mpj/thih/thih.pdf">Typing Haskell in Haskell</a> gives us the formal semantics of context reduction in Haskell. Section 3.2 of <a href="https://research.microsoft.com/en-us/um/people/simonpj/Papers/type-class-design-space/">Type classes: exploring the design space</a> also discusses context reduction. Interested readers are referred to both papers.</p>]]></description>
    <pubDate>Thu, 02 Feb 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-02-02-context-reduction.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Simple benchmarking with GHCi</title>
    <link>http://kseo.github.io//posts/2017-02-01-simple-benchmarking-with-ghci.html</link>
    <description><![CDATA[<p>GHCi has a lesser known option <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#ghci-cmd-:set%20+s">:set +s</a>. When turned on, GHCi displays some stats for each expression evaluated.</p>
<!--more-->
<p>Let’s experiment with the option.</p>
<pre><code>λ&gt; :set +s</code></pre>
<p><code>:set +s</code> displays the elapsed time and number of bytes allocated after evaluating each expression.</p>
<pre><code>λ&gt; fibs = 0 : scanl (+) 1 fibs
(0.00 secs, 0 bytes)</code></pre>
<p>The number of bytes allocated is zero for <code>fibs</code> because no GC has occurred.</p>
<blockquote>
<p>NOTE: the allocation figure is only accurate to the size of the storage manager’s allocation area, because it is calculated at every GC. Hence, you might see values of zero if no GC has occurred.</p>
</blockquote>
<pre><code>λ&gt; fibs !! 100
354224848179261915075
(0.01 secs, 110,440 bytes)</code></pre>
<p><code>fibs !! 100</code> took 0.01 seconds and allocated 110,440 bytes of memory.</p>
<p>This is a quick-and-dirty way to get a feel for the performance of a function. If you need a serious benchmark, please use <a href="http://www.serpentine.com/criterion/tutorial.html">criterion</a> instead.</p>]]></description>
    <pubDate>Wed, 01 Feb 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-02-01-simple-benchmarking-with-ghci.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Type-level insertion sort</title>
    <link>http://kseo.github.io//posts/2017-01-30-type-level-insertion-sort.html</link>
    <description><![CDATA[<p><em>Multi-parameter type classes</em> and <em>functional dependencies</em> made type-level programming possible. Back in 2000, Thomas Hallgren showed <a href="http://www.cse.chalmers.se/~hallgren/Papers/wm01.html">an implementation of insertion sort</a> as an example of static computation using functional dependencies. The code has a strong resemblance to logic programming which looks bizarre to most functional programmers. In this post, I will show you a more “functional-style” implementation of insertion sort using <em>closed type families</em>.</p>
<!--more-->
<h1 id="term-level-insertion-sort">Term-level insertion sort</h1>
<p>Here’s an implementation of insertion sort we all know.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sort<span class="ot"> ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]
sort [] <span class="fu">=</span> []
sort (x <span class="fu">:</span> xs) <span class="fu">=</span> insert x (sort xs)

<span class="ot">insert ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
insert x [] <span class="fu">=</span> x <span class="fu">:</span> []
insert x (y <span class="fu">:</span> ys) <span class="fu">=</span> insert&#39; (compare x y) x y ys

<span class="ot">insert&#39; ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Ordering</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]
insert&#39; <span class="dt">LT</span>  x y ys <span class="fu">=</span> x <span class="fu">:</span> (y <span class="fu">:</span> ys)
insert&#39; _   x y ys <span class="fu">=</span> y <span class="fu">:</span> insert x ys

l <span class="fu">=</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">9</span>, <span class="dv">5</span>]</code></pre></div>
<p><code>sort l</code> sorts the given list.</p>
<pre><code>λ&gt; sort l
[1,2,3,4,5,7,9]</code></pre>
<p>To implement insertion sort in type-level, we must be able to define</p>
<ol style="list-style-type: decimal">
<li>naturals, booleans and lists</li>
<li>functions</li>
</ol>
<p>in type-level. For the basics of type-level programming, readers are referred to <a href="https://kseo.github.io/posts/2017-01-16-type-level-functions-using-closed-type-families.html">Type-level functions using closed type families</a>.</p>
<h1 id="insertion-sort">Insertion sort</h1>
<p>Here’s an implementation of type-level insertion sort. One can see the strong similarity with the term-level insertion sort.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span>

<span class="kw">type</span> family <span class="dt">Sort</span> xs <span class="kw">where</span>
  <span class="dt">Sort</span> <span class="ch">&#39;[] = &#39;</span>[]
  <span class="dt">Sort</span> (x <span class="ch">&#39;: xs) = Insert x (Sort xs)</span>

<span class="kw">type</span> family <span class="dt">Insert</span> x xs <span class="kw">where</span>
  <span class="dt">Insert</span> x <span class="ch">&#39;[] = x &#39;</span><span class="fu">:</span> <span class="ch">&#39;[]</span>
  <span class="dt">Insert</span> x (y <span class="ch">&#39;: ys) = Insert&#39;</span> (<span class="dt">CmpNat</span> x y) x y ys

<span class="kw">type</span> family <span class="dt">Insert&#39;</span> b x y ys <span class="kw">where</span>
  <span class="dt">Insert&#39;</span> <span class="ch">&#39;LT  x y ys = x &#39;</span><span class="fu">:</span> (y <span class="ch">&#39;: ys)</span>
  <span class="dt">Insert&#39;</span> _    x y ys <span class="fu">=</span> y <span class="ch">&#39;: Insert x ys</span>

<span class="kw">type</span> <span class="dt">L</span> <span class="fu">=</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">7</span>, <span class="dv">9</span>, <span class="dv">5</span>]</code></pre></div>
<p>In this simple scenario, converting a term-level function into a type-level function is almost mechanical. Just a few rules suffice.</p>
<ul>
<li>sort -&gt; type family Sort</li>
<li>[] -&gt; ’[]</li>
<li>(x : xs) -&gt; (x ’: xs)</li>
<li>compare -&gt; CmpNat</li>
</ul>
<p>We can evaluate <code>Sort L</code> using GHCi’s <code>kind!</code> command.</p>
<pre><code>λ&gt; :kind! Sort L
Sort L :: [Nat]
= &#39;[1, 2, 3, 4, 5, 7, 9]</code></pre>]]></description>
    <pubDate>Mon, 30 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-30-type-level-insertion-sort.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Build your Haskell project continuously</title>
    <link>http://kseo.github.io//posts/2017-01-28-build-your-haskell-project-continuously.html</link>
    <description><![CDATA[<p>Today I am going to introduce handy tools which help you build your Haskell project continuously so that you can see the list of errors and warnings quickly as you program.</p>
<!--more-->
<h1 id="stack">Stack</h1>
<p><code>stack build</code> command has <code>--file-watch</code> option. When turned on, <em>stack</em> watches for changes in local files and automatically rebuild.</p>
<pre><code>stack build --file-watch</code></pre>
<p>Use <code>--fast</code> option if you want fast build which turns off optimizations (<code>-O0</code>). Also use <code>--pedantic</code> flag if you want to fix all warnings(<code>-Wall</code> and <code>-Werror</code>).</p>
<pre><code>stack build --file-watch --fast --pedantic</code></pre>
<h1 id="ghcid">ghcid</h1>
<p>Neil Mitchell’s <a href="https://github.com/ndmitchell/ghcid">ghcid</a> provides a similar functionality in a different way. It runs <em>GHCi</em> as a daemon and runs <code>:reload</code> whenever your source code changes.</p>
<p><code>ghcid</code> executes <code>stack ghci</code> by default if you have <code>stack.yaml</code> file and <code>.stack-work</code> directory.</p>
<pre><code>ghcid</code></pre>
<p>If you would like to give a custom command, use <code>--command</code> option.</p>
<pre><code>ghcid &quot;--command=ghci Main.hs&quot;</code></pre>
<p><code>ghcid</code> is much faster than <code>stack build</code> because it uses <em>GHCi</em>.</p>
<h1 id="steel-overseer">Steel Overseer</h1>
<p>If you want to run arbitrary commands when arbitrary files change, use <a href="https://github.com/schell/steeloverseer">Steel Overseer</a> instead. You can specify the pattern and commands in <code>.sosrc</code> file using YAML syntax. The following example has two rules.</p>
<ul>
<li>Watch <code>*.hs</code> files under <code>System</code> directory and run <code>stack build</code>.</li>
<li>Watch <code>*.hs</code> files under <code>test</code> directory and run <code>stack test</code>.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="kw">-</span> <span class="fu">pattern:</span> src/(.*)\.hs
  <span class="fu">commands:</span>
  <span class="kw">-</span> stack build
<span class="kw">-</span> <span class="fu">pattern:</span> test/(.*)\.hs
  <span class="fu">commands:</span>
  <span class="kw">-</span> stack test</code></pre></div>
<p><code>sos</code> command watches the specified files and runs the corresponding commands.</p>
<pre><code>sos</code></pre>
<h1 id="wrap-up">Wrap-up</h1>
<p>These small tools greatly increase your productivity. Please choose one and enjoy instant feedback!</p>]]></description>
    <pubDate>Sat, 28 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-28-build-your-haskell-project-continuously.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>How I learned Haskell</title>
    <link>http://kseo.github.io//posts/2017-01-27-how-i-learned-haskell.html</link>
    <description><![CDATA[<p>Happy lunar new year! Today I would like to share my experience of learning Haskell. It’s been a really long journey but a really wonderful one.</p>
<!--more-->
<h1 id="first-encounter">First Encounter</h1>
<p>Back in 2000, I was an undergraduate student majoring in computer science. At that time, I was into system programming and enjoyed learning low-level implementation details of operating systems and system applications. My primary language was C and programmed all programming assignments in C. I was proud that I understood how my code was compiled and executed on the machine.</p>
<p>One day my friend told me about <em>Haskell</em>. I wasn’t interested in functional programming at that time, but I became curious because he enthusiastically persuaded me to learn Haskell. I ended up reading two books on Haskell.</p>
<ul>
<li><a href="http://www.haskellcraft.com/craft3e/Home.html">Haskell: the Craft of Functional Programming</a></li>
<li><a href="http://www.cs.yale.edu/homes/hudak/SOE/">The Haskell School of Expression</a></li>
</ul>
<p>Both books were really nice and I learned I could program in an entirely different way. However, I wasn’t sure if Haskell could solve the real-world problems I wanted to solve. So my interest in Haskell stopped there.</p>
<h1 id="dark-age">Dark age</h1>
<p>My first job was mainly about porting and optimizing Java Virtual Machine for embedded systems. My company licensed Sun’s CDC JVM and I was responsible for maintaining it.</p>
<p>It was 2002 and Linux was still a luxury for embedded systems. RTOSes such as pSOS and VxWorks were popular on STBs and I ported JVM to these OSes. These RTOSes didn’t have distinctions between kernel and user space and an application was linked statically with the kernel and ran as a single (kernel) process application on the device.</p>
<p>The implication was profound. I had no safety guarantee provided by modern operating systems. A bug in an application could corrupt the kernel data and crash the entire system. Moreover, because there were dozens of threads competing for shared resources, race conditions and dead locks were a common place. It took hours or even days to find and fix a trivial bug.</p>
<p>The situation was much better when debugging an application written in Java. Thanks to the safety guarantee of Java, certain types of bugs were impossible. A Java program can’t corrupt memory and crash the system. Dead locks are reported systematically by the JVM. It was relatively fun to fix a bug in Java applications.</p>
<p>These experiences motivated me to find systematic ways of preventing bugs and led me to read Benjamin C. Pierce’s <a href="https://www.cis.upenn.edu/~bcpierce/tapl/">Types and Programming Languages</a>. It was the best computer science text book I’ve ever read. I understood why types were important in statically typed functional languages like Haskell! If universities had used this book as a undergraduate PL textbook, many of the confusions and misunderstandings about dynamic vs static typing would have disappeared.</p>
<h1 id="stuck-again">Stuck again</h1>
<p>By fully understanding the merits of type systems, I started to learn Haskell in a different perspective. I read <a href="https://www.haskell.org/tutorial/index.html">A Gentle Introduction To Haskell</a> and many tutorials on monads. It wasn’t very hard to understand specific instances of monads such as <em>Reader</em>, <em>Writer</em>, <em>State</em>, <em>List</em> and <em>Maybe</em>. But I couldn’t figure out how they were related. I managed to write simple applications in Haskell, but wasn’t confident that I could use Haskell productively because I couldn’t fully understand one of the core ideas of Haskell.</p>
<h1 id="the-challenges-of-multi-core-programming">The Challenges of Multi-core Programming</h1>
<p>In the meantime, I changed my career and founded a tech start-up in 2008. I built mobile web browsers for the embedded systems. I created a port of <a href="https://webkit.org/">WebKit</a> and hacked various components of WebKit to speed up the performance. The primary means for optimization was to leverage the multi-core CPU and GPU.</p>
<p>WebKit performs lots of tasks concurrently but it is mostly single-threaded. Loading a page does not benefit much from having a multi-core CPU. So I offloaded some tasks to separate threads but I only gained marginal performance benefits in exchange for largely increased complexity. I learned a lesson that I must pay very high costs of complexity to get small benefits of performance boost. Considering the already complex nature of WebKit, I ended up abandoning most of performance optimizations to keep the complexity under control.</p>
<p>While struggling to squeeze performance out of WebKit, I learned Haskell again to get some insights on parallel programming because Haskell was the only programming language which natively supported <em>STM(Software Transaction Memory)</em>. Simon Marlow’s <a href="http://chimera.labs.oreilly.com/books/1230000000929/index.html">Parallel and Concurrent Programming in Haskell</a> helped me understand how Haskell supported parallel and concurrent programming. Though I learned many valuable lessons from the book, I also felt that the lazy nature of Haskell didn’t go well with parallel programming.</p>
<h1 id="reunion">Reunion</h1>
<p>I have spent more than 10 years of my career on embedded systems and increasingly got frustrated with the tools available. So I decided to teach myself Haskell again and use it at work. This time I started to read classic papers on functional programming and Haskell.</p>
<p>Philip Wadler’s <a href="http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf">Monads for functional programming</a> clicked my mind and I finally became enlightened. The paper is really well written, but I don’t think I could understand <em>Monad</em> just because I read the paper. Years of trials and errors were necessary to understand abstract concepts like monad. It was the most exciting moment of my long journey to Haskell.</p>
<p>Once I understood how I could learn abstractions, the rest was easy. Now I don’t get discouraged just because I don’t understand abstractions at first glance. It takes time and practice to understand abstract things. I also realized that monad was just the beginning. There exist many Haskell idioms that require other abstract concepts such as <em>applicative functor</em>, <em>arrow</em>, <em>profunctor</em> and so on.</p>
<p>Here is the list of papers I found most enlightening when learning Haskell. I also recommend you read any paper with “Functional Pearl” attached to it.</p>
<ul>
<li><a href="http://www.cs.nott.ac.uk/~pszgmh/fold.pdf">A tutorial on the universality and expressiveness of fold</a></li>
<li><a href="http://www.cs.nott.ac.uk/~pszgmh/pearl.pdf">Monadic Parsing in Haskell</a></li>
<li><a href="http://haskell.cs.yale.edu/wp-content/uploads/2011/02/POPL96-Modular-interpreters.pdf">Monad Transformers and Modular Interpreters</a></li>
<li><a href="http://www.cs.ru.nl/~W.Swierstra/Publications/DataTypesALaCarte.pdf">Data types a la carte</a></li>
<li><a href="https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf">The Essence of the Iterator Pattern</a></li>
<li><a href="https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf">The Zipper</a></li>
</ul>
<h1 id="back-to-real-world">Back to Real-World</h1>
<p>I was confident that Haskell was a good programming language and I was looking for opportunities to use Haskell in production. Bryan O’Sullivan, Don Stewart, and John Goerzen’s <a href="http://book.realworldhaskell.org/">Real World Haskell</a> was a good reference in this direction. It showed how I could use Haskell to do my daily work such as networking, system programming, databases and web programming.</p>
<p>Finally, I started to read real-world Haskell code available on the hackage and realized that the <em>Haskell I know</em> was different from the <em>Haskell that is actually used</em>. Real world Haskell uses lots of GHC extensions which makes me feel it is an entirely different language. A typical Haskell module starts with:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE CPP                        #-}</span>
<span class="ot">{-# LANGUAGE FlexibleContexts           #-}</span>
<span class="ot">{-# LANGUAGE ConstraintKinds            #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances          #-}</span>
<span class="ot">{-# LANGUAGE FunctionalDependencies     #-}</span>
<span class="ot">{-# LANGUAGE OverloadedStrings          #-}</span>
<span class="ot">{-# LANGUAGE QuasiQuotes                #-}</span>
<span class="ot">{-# LANGUAGE RecordWildCards            #-}</span>
<span class="ot">{-# LANGUAGE TupleSections              #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies               #-}</span>
<span class="ot">{-# LANGUAGE RankNTypes                 #-}</span>
<span class="ot">{-# LANGUAGE DeriveDataTypeable         #-}</span></code></pre></div>
<p>It seems sticking to Haskell 98 or 2000 does not have much practical sense because many Haskell packages already use many GHC extensions. So I learned them too. <a href="https://ocharles.org.uk/blog/posts/2014-12-01-24-days-of-ghc-extensions.html">24 Days of GHC Extensions</a> was a really great way of learning this topic.</p>
<p>I like the approach of <a href="http://www.yesodweb.com/book/haskell">Yesod Web Framework Book</a> which explains the GHC extensions used in the library before explaining how to use the library. This is often the first step to learn a new library for many Haskell programmers. For example, you can’t use <a href="http://haskell-servant.readthedocs.io/en/stable/">Servant</a> unless you understand <em>DataKinds</em> and <em>TypeOperators</em>. So I encourage Haskell library authors to write more about the GHC extensions they use.</p>
<p>I also found that some packages are essential to use Haskell in practice.</p>
<ul>
<li><code>String</code> type has problems. You need either <a href="https://hackage.haskell.org/package/text">text</a> or <a href="https://hackage.haskell.org/package/bytestring">bytestring</a> for efficient string data processing.</li>
<li>Lazy IO looks nice, but does not work well in practice. To process streaming data properly you need either <a href="https://hackage.haskell.org/package/pipes-4.3.2/docs/Pipes-Tutorial.html">pipes</a> or <a href="https://github.com/snoyberg/conduit#readme">conduit</a>.</li>
<li>You will need a custom monad or monad transformer for your application sooner or later. Either <a href="https://hackage.haskell.org/package/mtl">mtl</a> or <a href="https://hackage.haskell.org/package/transformers">transformers</a> is required.</li>
<li>JSON is a really universal data exchange format these days. <a href="https://hackage.haskell.org/package/aeson-1.1.0.0/docs/Data-Aeson.html">aeson</a> will help you here.</li>
<li><a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a> is a bonus you get from using Haskell!</li>
</ul>
<h1 id="haskell-in-production">Haskell in production</h1>
<p>I founded a small Haskell shop this year and started to use Haskell in production. I realized that using Haskell in production was, surprisingly, easier than learning Haskell. It took me more than 10 years to learn Haskell, but I felt confident that I could use Haskell in production only after a few months of experiments.</p>
<p>There is one thing I would like to emphasize. Using Haskell does not mean that you must understand all the dependencies you use. Haskell programmers tend to care much about the implementation details of their dependencies because Haskell makes it so easy to understand the meaning of programs with types and equational reasoning. But in my opinion, this is a blessed curse.</p>
<p>That’s not how civilization works. You can drive a car without understanding how engines work. Python or JavaScript programmers do not care about the implementation details of their dependencies because it is simply impossible. Haskell is no exception. Time and money are limited. Please don’t spend too much time on understanding things. Spend more time on building things. Be practical.</p>
<p>Fortunately, some library authors provide a high-level overview of their library. <a href="https://www.andres-loeh.de/Servant/servant-wgp.pdf">Type-level Web APIs with Servant</a> is a great example. It explains the core concepts and the implementation techniques of the library without involving accidental complexities of implementation details. I would love to see more papers like this.</p>
<h1 id="tools-and-libraries">Tools and Libraries</h1>
<p><a href="https://www.stackage.org/">Stackage</a> and the <a href="https://docs.haskellstack.org/en/stable/README/">Stack</a> are indispensable tools for using Haskell in production. All the hard work of <a href="https://www.fpcomplete.com/">FP Complete</a> gave me confidence that Haskell was production-ready. The Haskell ecosystem is not small anymore. There are multiple competing web frameworks such as <a href="http://www.yesodweb.com/">Yesod</a>, <a href="https://hackage.haskell.org/package/scotty">Scotty</a>, <a href="http://snapframework.com/">Snap</a>, <a href="http://www.happstack.com/page/view-page-slug/1/happstack">Happstack</a> and <a href="http://haskell-servant.readthedocs.io/en/stable/">Servant</a>. Qualities of these packages are all good.</p>
<p>If you write web servers in Haskell, all the packages you need such as web servers, web frameworks, logging packages, database drivers are already available. I use <em>Servant</em>, <a href="https://hackage.haskell.org/package/persistent">persistent</a> and <a href="https://hackage.haskell.org/package/esqueleto">esqueleto</a> for my server. So far, everything works fine.</p>
<h1 id="haskell-community">Haskell Community</h1>
<p>Haskell community is relatively small compared to other major languages, but I am often surprised by the quality of feedback I get from the community. Haskell is a great language, but the community is even greater. That’s the biggest reason why I love programming in Haskell.</p>
<p>My journey to Haskell is still going on.</p>]]></description>
    <pubDate>Fri, 27 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-27-how-i-learned-haskell.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Write your own stream processing library Part1</title>
    <link>http://kseo.github.io//posts/2017-01-25-write-your-own-stream-processing-library-part1.html</link>
    <description><![CDATA[<p><a href="https://hackage.haskell.org/package/pipes">pipes</a> and <a href="https://hackage.haskell.org/package/conduit">conduit</a> are two competing libraries for handling stream data processing in Haskell. Though both libraries provide excellent tutorials on the usage of the libraries, the implementation details are impenetrable to most Haskell programmers.</p>
<p>The best way to understand how these streaming libraries work is to write a minimalistic version by ourselves. In this post, I will show you how we can write a small streaming data library with <em>coroutine</em>. Our implementation is based on Mario Blazevic’s excellent article <a href="https://themonadreader.files.wordpress.com/2011/10/issue19.pdf">Coroutine Pipelines</a>.</p>
<!--more-->
<h1 id="generator">Generator</h1>
<p><code>Generator</code> is a monad transformer which allows the base monad to pause its computation and yield a value. This corresponds to <code>Producer</code> of pipes or <code>Source</code> of conduit.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE LambdaCase #-}</span>

<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Monad.Trans.Class</span>

<span class="kw">newtype</span> <span class="dt">Generator</span> a m x <span class="fu">=</span>
  <span class="dt">Generator</span> {<span class="ot"> bounceGen ::</span> m (<span class="dt">Either</span> (a, <span class="dt">Generator</span> a m x) x) }</code></pre></div>
<p><code>Generator a m x</code> represents a computation which yields values of type <code>a</code> on top of the base monad <code>m</code> and returns a value of type <code>x</code>.</p>
<p><code>Either</code> indicates that <code>Generator</code> has two cases:</p>
<ul>
<li><code>(a, Generator a m x)</code>: A pair of a yielded value and a suspension to be resumed.</li>
<li><code>x</code>: A return value <code>x</code>.</li>
</ul>
<p>The enclosing <code>m</code> allows us to perform monadic actions while running the generator.</p>
<p>The definition of <code>Monad</code> instance for <code>Generator</code> is as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Generator</span> a m) <span class="kw">where</span>
  return  <span class="fu">=</span> <span class="dt">Generator</span> <span class="fu">.</span> return <span class="fu">.</span> <span class="dt">Right</span>
  t <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Generator</span> <span class="fu">$</span> bounceGen t
                      <span class="fu">&gt;&gt;=</span> \<span class="kw">case</span> <span class="dt">Left</span> (a, cont) <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">Left</span> (a, cont <span class="fu">&gt;&gt;=</span> f)
                                <span class="dt">Right</span> x <span class="ot">-&gt;</span> bounceGen (f x)

<span class="kw">instance</span> <span class="dt">MonadTrans</span> (<span class="dt">Generator</span> a) <span class="kw">where</span>
  lift <span class="fu">=</span> <span class="dt">Generator</span> <span class="fu">.</span> liftM <span class="dt">Right</span>

<span class="ot">yield ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Generator</span> a m ()
yield a <span class="fu">=</span> <span class="dt">Generator</span> (return <span class="fu">$</span> <span class="dt">Left</span> (a, return ()))</code></pre></div>
<p><code>&gt;&gt;=</code> operator has two cases to consider. If <code>t</code> is a suspension (<code>Left</code> case), it yields <code>a</code> and combines the remaining computation <code>cont</code> with <code>f</code>. If <code>t</code> is a value <code>x</code> (<code>Right</code> case), it continues the computation by passing the value to <code>f</code>. Once we define <code>&gt;&gt;=</code> this way, the definition of <code>yield</code> is straightforward. It yields a value and does nothing more.</p>
<p>To run a <code>Generator</code>, we need <code>runGenerator</code> function which collects the yielded values while executing the generator. <code>run'</code> uses a <a href="https://wiki.haskell.org/Difference_list">difference list</a> to collect yielded values and converts it to the normal list by applying <code>[]</code> at the end.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runGenerator ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Generator</span> a m x <span class="ot">-&gt;</span> m ([a], x)
runGenerator <span class="fu">=</span> run&#39; id <span class="kw">where</span>
  run&#39; f g <span class="fu">=</span> bounceGen g
             <span class="fu">&gt;&gt;=</span> \<span class="kw">case</span> <span class="dt">Left</span> (a, cont) <span class="ot">-&gt;</span> run&#39; (f<span class="fu">.</span>(a<span class="fu">:</span>)) cont
                       <span class="dt">Right</span> x <span class="ot">-&gt;</span> return (f [], x)</code></pre></div>
<p>Now we are ready to create generators. <code>triple</code> is a generator which yields the given value three times.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">triple ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Generator</span> a m ()
triple x <span class="fu">=</span> <span class="kw">do</span>
    yield x
    yield x
    yield x</code></pre></div>
<p>Running <code>triple 3</code> returns <code>([3, 3, 3], ())</code> as expected.</p>
<pre><code>λ&gt; runGenerator $ triple 3
([3,3,3],())</code></pre>
<p>When the base monad is <code>IO</code>, we can interleave IO actions. For example, <code>loop</code> yields the line input from the stdin until an empty string is read.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">loop ::</span> <span class="dt">Generator</span> <span class="dt">String</span> <span class="dt">IO</span> ()
loop <span class="fu">=</span> <span class="kw">do</span>
    str <span class="ot">&lt;-</span> lift getLine
    when (str <span class="fu">/=</span> <span class="st">&quot;&quot;</span>) <span class="fu">$</span> <span class="kw">do</span>
      yield str
      loop</code></pre></div>
<pre><code>λ&gt; runGenerator loop
Hello
world!

([&quot;Hello&quot;,&quot;world!&quot;],())</code></pre>
<p>It is even possible to mix two generators by alternating each generator.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">alternate ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Generator</span> a m () <span class="ot">-&gt;</span> <span class="dt">Generator</span> a m () <span class="ot">-&gt;</span> <span class="dt">Generator</span> a m ()
alternate g1 g2 <span class="fu">=</span> <span class="dt">Generator</span> <span class="fu">$</span> liftM2 go (bounceGen g1) (bounceGen g2)
  <span class="kw">where</span>
    go (<span class="dt">Left</span> (a, cont)) (<span class="dt">Left</span> (b, cont&#39;)) <span class="fu">=</span> <span class="dt">Left</span>  (a, <span class="dt">Generator</span> <span class="fu">$</span> return <span class="fu">$</span> <span class="dt">Left</span> (b, alternate cont cont&#39;))
    go (<span class="dt">Left</span> (a, cont)) (<span class="dt">Right</span> _)         <span class="fu">=</span> <span class="dt">Left</span>  (a, cont)
    go (<span class="dt">Right</span> _)        (<span class="dt">Left</span> (b, cont))  <span class="fu">=</span> <span class="dt">Left</span>  (b, cont)
    go (<span class="dt">Right</span> _)        (<span class="dt">Right</span> _)         <span class="fu">=</span> <span class="dt">Right</span> ()</code></pre></div>
<p>We can see that the outputs of <code>triple 1</code> and <code>triple 2</code> are intermingled.</p>
<pre><code>λ&gt; runGenerator $ alternate (triple 1) (triple 2)
([1,2,1,2,1,2],())</code></pre>
<p>Part 2 of this post will continue the discussion with <em>Iteratees</em>.</p>]]></description>
    <pubDate>Wed, 25 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-25-write-your-own-stream-processing-library-part1.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Generating the Docker client with servant-client</title>
    <link>http://kseo.github.io//posts/2017-01-24-generating-the-docker-client-with-servant-client.html</link>
    <description><![CDATA[<p><a href="http://haskell-servant.readthedocs.io/en/stable/">Servant</a> provides a type-level DSL for declaring web APIs. Once we write the specification with the DSL, we can do various things including:</p>
<ul>
<li>Write servers (this part of servant can be considered a web framework),</li>
<li>Obtain client functions (in Haskell),</li>
<li>Generate client functions for other programming languages,</li>
<li>Generate documentation for your web applications</li>
</ul>
<p>The primary use case of Servant is to write servers, but we can use <a href="https://hackage.haskell.org/package/servant-client">servant-client</a> to generate client functions for the pre-existing web servers too! In this post, I will show you how we can generate client functions for the <a href="https://docs.docker.com/engine/api/">Docket remote API</a> automatically with servant-client.</p>
<!--more-->
<h1 id="api-specification">API specification</h1>
<p>To make the exposition simple, we will specify only three APIs: <code>ping</code>, <code>version</code> and <code>containerList</code>.</p>
<p>The simplest API is <a href="https://docs.docker.com/engine/api/v1.25/#operation/SystemPing">Ping</a> which tests if the server is accessible. Its path is <code>/v1.25/_ping</code> and it returns <code>OK</code> as a plain text with status code 200. We can succinctly describe this endpoint with Servant’s type-level DSL.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Ping</span> <span class="fu">=</span> <span class="st">&quot;_ping&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">&#39;[PlainText] Text</span></code></pre></div>
<p><a href="https://docs.docker.com/engine/api/v1.25/#operation/SystemVersion">Version</a> is a slightly more complex API which returns the version information as JSON. <code>Version</code> data type has the required fields and it declares an instance of <code>FromJSON</code> for unmarshalling JSON data into <code>Version</code>. <code>fieldLabelModifier</code> is used to bridge JSON field names to <code>Version</code> field names.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Version</span> <span class="fu">=</span> <span class="st">&quot;version&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">&#39;[JSON] Version</span>

<span class="kw">data</span> <span class="dt">Version</span> <span class="fu">=</span> <span class="dt">Version</span>
  {<span class="ot"> versionVersion       ::</span> <span class="dt">Text</span>
  ,<span class="ot"> versionApiVersion    ::</span> <span class="dt">Text</span>
  ,<span class="ot"> versionMinAPIVersion ::</span> <span class="dt">Text</span>
  ,<span class="ot"> versionGitCommit     ::</span> <span class="dt">Text</span>
  ,<span class="ot"> versionGoVersion     ::</span> <span class="dt">Text</span>
  ,<span class="ot"> versionOs            ::</span> <span class="dt">Text</span>
  ,<span class="ot"> versionArch          ::</span> <span class="dt">Text</span>
  ,<span class="ot"> versionKernelVersion ::</span> <span class="dt">Text</span>
  ,<span class="ot"> versionExperimental  ::</span> <span class="dt">Bool</span>
  ,<span class="ot"> versionBuildTime     ::</span> <span class="dt">Text</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Generic</span>)

<span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Version</span> <span class="kw">where</span>
  parseJSON <span class="fu">=</span> genericParseJSON opts
    <span class="kw">where</span> opts <span class="fu">=</span> defaultOptions { fieldLabelModifier <span class="fu">=</span> stripPrefix <span class="st">&quot;version&quot;</span> }

<span class="ot">stripPrefix ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
stripPrefix prefix <span class="fu">=</span> fromJust <span class="fu">.</span> DL.stripPrefix prefix</code></pre></div>
<p>Finally, <a href="https://docs.docker.com/engine/api/v1.25/#operation/ContainerList">ContainerList</a> returns the list of containers. The API takes optional query parameters such as <code>all</code>, <code>limit</code>, <code>size</code> and <code>filters</code> as specified follows. We created a newtype wrapper for <code>ContainerID</code> and declared <code>FromJSON</code> instances for <code>ContainerID</code> and <code>Container</code>. Some fields are omitted for brevity.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">ContainerList</span> <span class="fu">=</span> <span class="st">&quot;containers&quot;</span> <span class="fu">:&gt;</span> <span class="st">&quot;json&quot;</span> <span class="fu">:&gt;</span> <span class="dt">QueryParam</span> <span class="st">&quot;all&quot;</span> <span class="dt">Bool</span>
                                            <span class="fu">:&gt;</span> <span class="dt">QueryParam</span> <span class="st">&quot;limit&quot;</span> <span class="dt">Int</span>
                                            <span class="fu">:&gt;</span> <span class="dt">QueryParam</span> <span class="st">&quot;size&quot;</span> <span class="dt">Bool</span>
                                            <span class="fu">:&gt;</span> <span class="dt">QueryParam</span> <span class="st">&quot;filters&quot;</span> <span class="dt">Text</span>
                                            <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">&#39;[JSON] [Container]</span>

<span class="kw">newtype</span> <span class="dt">ContainerID</span> <span class="fu">=</span> <span class="dt">ContainerID</span> <span class="dt">Text</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Generic</span>)

<span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">ContainerID</span>

<span class="kw">data</span> <span class="dt">Container</span> <span class="fu">=</span> <span class="dt">Container</span>
  {<span class="ot"> containerId               ::</span> <span class="dt">ContainerID</span>
  ,<span class="ot"> containerNames            ::</span> [<span class="dt">Text</span>]
  ,<span class="ot"> containerImage            ::</span> <span class="dt">Text</span>
  ,<span class="ot"> containerImageID          ::</span> <span class="dt">ImageID</span>
  ,<span class="ot"> containerCommand          ::</span> <span class="dt">Text</span>
  ,<span class="ot"> containerCreated          ::</span> <span class="dt">Int</span>
  <span class="co">-- FIXME: Add Ports</span>
  ,<span class="ot"> containerSizeRw           ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
  ,<span class="ot"> containerSizeRootFs       ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
  <span class="co">-- FIXME: Add Labels</span>
  ,<span class="ot"> containerState            ::</span> <span class="dt">Text</span>
  ,<span class="ot"> containerStatus           ::</span> <span class="dt">Text</span>
  <span class="co">-- FIXME: Add HostConfig</span>
  <span class="co">-- FIXME: Add NetworkSettings</span>
  <span class="co">-- FIXME: Add Mounts</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Generic</span>)</code></pre></div>
<p>Our API is just the combination of these endpoints.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Api</span> <span class="fu">=</span> <span class="dt">Ping</span> <span class="fu">:&lt;|&gt;</span> <span class="dt">Version</span> <span class="fu">:&lt;|&gt;</span> <span class="dt">ContainerList</span></code></pre></div>
<h1 id="api-versioning">API Versioning</h1>
<p>Because the Docker remote API has many versions, it adds a version prefix in the path. Servant allows us to expression this version scheme by declaring a new Api with the version prefix.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">ApiV1_25</span> <span class="fu">=</span> <span class="st">&quot;v1.25&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Api</span></code></pre></div>
<p>We can also mix-and-match many endpoints as the Docker remote API changes. Let’a assume that the docker API version v1.26 changed the specification of the Version endpoint. We can reuse unchanged endpoints by replacing only the changed endpoints with new ones.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Version1_26</span> <span class="fu">=</span> <span class="fu">...</span>
<span class="kw">type</span> <span class="dt">ApiV1_26</span> <span class="fu">=</span> <span class="st">&quot;v1.26&quot;</span> <span class="fu">:&gt;</span> (<span class="dt">Ping</span> <span class="fu">:&lt;|&gt;</span> <span class="dt">Version1_26</span> <span class="fu">:&lt;|&gt;</span> <span class="dt">ContainerList</span>)</code></pre></div>
<h1 id="generating-client-functions">Generating Client Functions</h1>
<p>Now it’s time to generate client functions from the specification. It’s super easy! We can simply pass our API to <code>client</code> function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ping ::</span> <span class="dt">ClientM</span> <span class="dt">Text</span>
<span class="ot">version ::</span> <span class="dt">ClientM</span> <span class="dt">Version</span>
<span class="ot">containerList&#39; ::</span> <span class="dt">Maybe</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">ClientM</span> [<span class="dt">Container</span>]

ping
  <span class="fu">:&lt;|&gt;</span> version
  <span class="fu">:&lt;|&gt;</span> containerList&#39; <span class="fu">=</span> client apiV1_25</code></pre></div>
<p><code>ping</code> and <code>version</code> functions are okay, but the signature <code>containerList'</code> is a bit confusing. We have to pass four <code>Maybe</code> values and two of them have the <code>Bool</code> type and it is not easy to remember the order of the arguments. We can improve the function by declaring a wrapper function <code>containerList</code>. It takes a <code>ContainerListOptions</code>, and the users of the function can pass <code>defaultContainerListOptions</code> as the default value.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ContainerListOptions</span> <span class="fu">=</span> <span class="dt">ContainerListOptions</span>
  {<span class="ot"> containerListOptionAll     ::</span> <span class="dt">Maybe</span> <span class="dt">Bool</span>
  ,<span class="ot"> containerListOptionLimit   ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
  ,<span class="ot"> containerListOptionSize    ::</span> <span class="dt">Maybe</span> <span class="dt">Bool</span>
  ,<span class="ot"> containerListOptionFilters ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="ot">defaultContainerListOptions ::</span> <span class="dt">ContainerListOptions</span>
defaultContainerListOptions <span class="fu">=</span> <span class="dt">ContainerListOptions</span>
  { containerListOptionAll     <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">False</span>
  , containerListOptionLimit   <span class="fu">=</span> <span class="dt">Nothing</span>
  , containerListOptionSize    <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">False</span>
  , containerListOptionFilters <span class="fu">=</span> <span class="dt">Nothing</span>
  }

<span class="ot">containerList ::</span> <span class="dt">ContainerListOptions</span> <span class="ot">-&gt;</span> <span class="dt">ClientM</span> [<span class="dt">Container</span>]
containerList opt <span class="fu">=</span> containerList&#39; (containerListOptionAll opt)
                                   (containerListOptionLimit opt)
                                   (containerListOptionSize opt)
                                   (containerListOptionFilters opt)</code></pre></div>
<p>Because the expressiveness of Haskell is much more powerful than that of the REST API specification, these wrappings are somewhat unavoidable to make our client functions more Haskell-friendly.</p>
<h1 id="using-client-functions">Using Client Functions</h1>
<p>Now our client functions for the Docker API is ready. We need to prepare a <code>ClientEnv</code> by passing the host, port and url prefix of the server. We also created a custom connection manager which uses the domain socket for communication because the Docker server listens on the domain socket by default. Interested readers are referred to my previous article <a href="https://kseo.github.io/posts/2017-01-23-custom-connection-manager-for-http-client.html">Custom connection manager for http-client</a> for the implementation details of <code>newUnixSocketManager</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">query ::</span> <span class="dt">ClientM</span> [<span class="dt">Container</span>]
query <span class="fu">=</span> <span class="kw">do</span>
  ok <span class="ot">&lt;-</span> ping
  liftIO <span class="fu">$</span>  print ok
  version <span class="ot">&lt;-</span> version
  liftIO <span class="fu">$</span> print (versionVersion version)
  containerList defaultContainerListOptions

<span class="ot">app ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
app host port <span class="fu">=</span> <span class="kw">do</span>
  manager <span class="ot">&lt;-</span> newUnixSocketManager <span class="st">&quot;/var/run/docker.sock&quot;</span>
  res <span class="ot">&lt;-</span> runClientM query (<span class="dt">ClientEnv</span> manager (<span class="dt">BaseUrl</span> <span class="dt">Http</span> host port <span class="st">&quot;&quot;</span>))
  <span class="kw">case</span> res <span class="kw">of</span>
    <span class="dt">Left</span> err          <span class="ot">-&gt;</span> putStrLn <span class="fu">$</span> <span class="st">&quot;Error: &quot;</span> <span class="fu">++</span> show err
    <span class="dt">Right</span> containers  <span class="ot">-&gt;</span> mapM_ print containers</code></pre></div>
<p>Because <code>ClientM</code> is a monad, we can combine multiple monadic actions into one. <code>query</code> function pings the server, queries the version information and then request the list of containers.</p>
<h1 id="swagger">Swagger</h1>
<p>So far I manually specified the API with Servant’s DSL, but if the server has the <a href="http://swagger.io/">Swagger</a> specification we can even generate the Servant DSL from the Swagger specification. <a href="https://github.com/swagger-api/swagger-codegen">swagger-codegen</a> has the <a href="https://github.com/swagger-api/swagger-codegen/blob/master/modules/swagger-codegen/src/main/java/io/swagger/codegen/languages/HaskellServantCodegen.java">HaskellServantCodegen</a>, so we can use it! (I haven’t tried it yet.)</p>
<h1 id="wrap-up">Wrap-up</h1>
<p>Writing client functions for existing servers are boring and repetitive. With <em>servant-client</em>, we no longer need to write these functions. We just specify the API and Servant writes the client functions for us. Have fun with Servant!</p>]]></description>
    <pubDate>Tue, 24 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-24-generating-the-docker-client-with-servant-client.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Custom connection manager for http-client</title>
    <link>http://kseo.github.io//posts/2017-01-23-custom-connection-manager-for-http-client.html</link>
    <description><![CDATA[<p><a href="https://www.stackage.org/haddock/lts-7.12/http-client-0.4.31.2/Network-HTTP-Client.html">http-client</a> provides the low-level API for HTTP client. In this post, I will explain how to create custom connection managers. If you want to know the basics of the library, read <a href="https://haskell-lang.org/library/http-client">Making HTTP requests</a> first.</p>
<!--more-->
<p>Every HTTP request is made via a <code>Manager</code>. It handles the details of creating connections to the server such as managing a connection pool. It also allows us to configure various settings and setup secure connections (HTTPS).</p>
<p>The easiest way to create one is to use <code>newManager defaultManagerSettings</code> as follows.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Network.HTTP.Client</span>
<span class="kw">import </span><span class="dt">Network.HTTP.Types.Status</span> (statusCode)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  manager <span class="ot">&lt;-</span> newManager defaultManagerSettings

  request <span class="ot">&lt;-</span> parseRequest <span class="st">&quot;http://httpbin.org/post&quot;</span>
  response <span class="ot">&lt;-</span> httpLbs request manager

  putStrLn <span class="fu">$</span> <span class="st">&quot;The status code was: &quot;</span> <span class="fu">++</span> (show <span class="fu">$</span> statusCode <span class="fu">$</span> responseStatus response)
  print <span class="fu">$</span> responseBody response</code></pre></div>
<p>But the default connection manager is not enough for some cases. One such case is the <a href="https://docs.docker.com/engine/api/">docker remote API</a>. Because Docker listens on the unix domain socket by default for security reasons, we can’t access to the API with the default connection manager which uses tcp.</p>
<p>But we are not out of luck. We can configure the connection manager to create a <em>unix domain socket</em> instead of a <em>tcp socket</em> by setting a custom <code>managerRawConnection</code> field.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">managerRawConnection ::</span> <span class="dt">ManagerSettings</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">HostAddress</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Connection</span>)</code></pre></div>
<p>It is used by <code>Manager</code> to create a new <code>Connection</code> from the host and port. So we can make the connection manager to create a unix socket by replacing the default implementation with <code>openUnixSocket</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Network.Socket</span> <span class="kw">as</span> <span class="dt">S</span>
<span class="kw">import qualified</span> <span class="dt">Network.Socket.ByteString</span> <span class="kw">as</span> <span class="dt">SBS</span>
<span class="kw">import </span><span class="dt">Network.HTTP.Client</span>
<span class="kw">import </span><span class="dt">Network.HTTP.Client.Internal</span> (makeConnection)
<span class="kw">import </span><span class="dt">Network.HTTP.Types.Status</span> (statusCode)

<span class="ot">newUnixDomainSocketManager ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Manager</span>
newUnixDomainSocketManager path <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> mSettings <span class="fu">=</span> defaultManagerSettings { managerRawConnection <span class="fu">=</span> return <span class="fu">$</span> openUnixSocket path }
  newManager mSettings
  <span class="kw">where</span>
    openUnixSocket filePath _ _ _ <span class="fu">=</span> <span class="kw">do</span>
      s <span class="ot">&lt;-</span> S.socket <span class="dt">S.AF_UNIX</span> <span class="dt">S.Stream</span> S.defaultProtocol
      S.connect s (<span class="dt">S.SockAddrUnix</span> filePath)
      makeConnection (SBS.recv s <span class="dv">8096</span>)
                     (SBS.sendAll s)
                     (S.close s)</code></pre></div>
<p>By creating a connection manager with “/var/run/docker.sock”, we can make a request to the docker. The code below returns the version of the docker.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  manager <span class="ot">&lt;-</span> newUnixDomainSocketManager
   <span class="st">&quot;/var/run/docker.sock&quot;</span>
  request <span class="ot">&lt;-</span> parseRequest <span class="st">&quot;http://192.168.99.100:2376/v1.25/version&quot;</span>
  response <span class="ot">&lt;-</span> httpLbs request manager

  putStrLn <span class="fu">$</span> <span class="st">&quot;The status code was: &quot;</span> <span class="fu">++</span> (show <span class="fu">$</span> statusCode <span class="fu">$</span> responseStatus response)
  print <span class="fu">$</span> responseBody response</code></pre></div>]]></description>
    <pubDate>Mon, 23 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-23-custom-connection-manager-for-http-client.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Writer monad</title>
    <link>http://kseo.github.io//posts/2017-01-21-writer-monad.html</link>
    <description><![CDATA[<p>The <em>Writer monad</em> represents computations which produce a stream of data in addition to the computed values. It is commonly used by code generators to emit code.</p>
<!--more-->
<p><a href="https://www.stackage.org/lts-7.12/package/transformers-0.5.2.0">transformers</a> provides both the strict and lazy versions of <code>WriterT</code> monad transformer. The definition of bind operator <code>&gt;&gt;=</code> reveals how the Writer monad works.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Monoid</span> w, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">WriterT</span> w m) <span class="kw">where</span>
    return a <span class="fu">=</span> writer (a, mempty)
    m <span class="fu">&gt;&gt;=</span> k  <span class="fu">=</span> <span class="dt">WriterT</span> <span class="fu">$</span> <span class="kw">do</span>
        (a, w)  <span class="ot">&lt;-</span> runWriterT m
        (b, w&#39;) <span class="ot">&lt;-</span> runWriterT (k a)
        return (b, w <span class="ot">`mappend`</span> w&#39;)</code></pre></div>
<p><code>runWriterT</code> returns a pair whose second element is the output to accumulate. Because the output value is a <code>Monoid</code> instance, we can merge two outputs <code>w</code> and <code>w'</code> using <code>mappend</code> and return the combined output.</p>
<p>Here is a simple example of the Writer monad. It accumulates <code>LogEntry</code>s in a list. (CAUTION: Do not use <code>WriterT</code> for plain logging in real world applications. It unnecessarily keeps the entire logs in memory. I recommend <a href="https://hackage.haskell.org/package/fast-logger">fast-logger</a> for logging.)</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Monad.Trans.Writer.Strict</span>

<span class="kw">data</span> <span class="dt">LogEntry</span> <span class="fu">=</span> <span class="dt">LogEntry</span> {<span class="ot"> msg::</span><span class="dt">String</span> }
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="ot">calc ::</span> <span class="dt">Writer</span> [<span class="dt">LogEntry</span>] <span class="dt">Integer</span>
calc <span class="fu">=</span> <span class="kw">do</span>
  output <span class="st">&quot;start&quot;</span>
  <span class="kw">let</span> x <span class="fu">=</span> sum [<span class="dv">1</span><span class="fu">..</span><span class="dv">10000000</span>]
  output (show x)
  output <span class="st">&quot;done&quot;</span>
  return x

<span class="ot">output ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> [<span class="dt">LogEntry</span>] ()
output x <span class="fu">=</span> tell [<span class="dt">LogEntry</span> x]

test <span class="fu">=</span> mapM_ print <span class="fu">$</span> execWriter calc</code></pre></div>
<p>The code looks innocuous, but its performance deteriorates when the accumulated log gets bigger because the <code>Monoid</code> instance of <code>[]</code> uses <code>(++)</code> to append two lists and the concatenations are left-nested.</p>
<pre><code>do { tell [1]; tell [2]; tell [3]; tell[4]; tell [5] }
=&gt;
(((([1] ++ [2]) ++ [3]) ++ [4]) ++ [5])</code></pre>
<p><code>(++)</code> is <a href="http://stackoverflow.com/a/13879693/2028189">known to perform poorly</a> when applications of <code>(++)</code> are left-nested.</p>
<h1 id="difference-list">Difference List</h1>
<p>One well-known solution is to use <em>the difference list</em> instead of an ordinary list. <code>DList</code> provides O(1) <code>append</code> and <code>snoc</code> operations on lists. <a href="http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/">Demystifying DList</a> explains how <code>DList</code> works in details.</p>
<p>The code is almost the same except we replaced <code>[LogEntry]</code> with <code>DList LogEntry</code>, but it scales well as the accumulated log gets bigger.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.DList</span>

<span class="ot">calc ::</span> <span class="dt">Writer</span> (<span class="dt">DList</span> <span class="dt">LogEntry</span>) <span class="dt">Integer</span>
calc <span class="fu">=</span> <span class="fu">...</span>

<span class="ot">output ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> (<span class="dt">DList</span> <span class="dt">LogEntry</span>) ()
output x <span class="fu">=</span> tell (singleton (<span class="dt">LogEntry</span> x))

test <span class="fu">=</span> mapM_ print <span class="fu">$</span> toList (execWriter calc)</code></pre></div>
<h1 id="endo">Endo</h1>
<p>Another option is to use <code>Endo</code> wrapper from <code>Data.Monoid</code>. It is an endomorphism from type <code>a</code> to <code>a</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Endo</span> a <span class="fu">=</span> <span class="dt">Endo</span> {<span class="ot"> appEndo ::</span> a <span class="ot">-&gt;</span> a }
               <span class="kw">deriving</span> (<span class="dt">Generic</span>)</code></pre></div>
<p>Surprisingly, it is an instance of <code>Monoid</code>. <code>mempty</code> is the <em>identity</em> function and <code>mappend</code> is the <em>composition</em> of two functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Endo</span> a) <span class="kw">where</span>
        mempty <span class="fu">=</span> <span class="dt">Endo</span> id
        <span class="dt">Endo</span> f <span class="ot">`mappend`</span> <span class="dt">Endo</span> g <span class="fu">=</span> <span class="dt">Endo</span> (f <span class="fu">.</span> g)</code></pre></div>
<p>But how can I output a log? We need a function of type <code>[LogEntry] -&gt; [LogEntry]</code> to make an <code>Endo</code> value. The trick is to create a section <code>([LogEntry x]&lt;&gt;)</code> which prepends a log entry to the list.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">calc ::</span> <span class="dt">Writer</span> (<span class="dt">Endo</span> [<span class="dt">LogEntry</span>]) <span class="dt">Integer</span>
calc <span class="fu">=</span> <span class="fu">...</span>

<span class="ot">output ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> (<span class="dt">Endo</span> [<span class="dt">LogEntry</span>]) ()
output x <span class="fu">=</span> tell <span class="fu">$</span> <span class="dt">Endo</span> ([<span class="dt">LogEntry</span> x]<span class="fu">&lt;&gt;</span>)

test <span class="fu">=</span> mapM_ print <span class="fu">$</span> appEndo (execWriter calc) []</code></pre></div>
<p>But why does this use of <code>Endo</code> perform well? To see why, we need to see how the following code is actually evaluated.</p>
<pre><code>do { tell [1]; tell [2]; tell [3]; tell[4]; tell [5] }</code></pre>
<p>is translated to</p>
<pre><code>([1]++) . ([2]++) . ([3]++) . ([4]++) . ([5]++)</code></pre>
<p>This is a composition of functions whose type is <code>[Int] -&gt; [Int]</code>. We can obtain the final result by applying <code>[]</code>.</p>
<pre><code>([1]++) . ([2]++) . ([3]++) . ([4]++) . ([5]++) $ []
=&gt;
[1] ++ ([2] ++ ([3] ++ ([4] ++ ([5] ++ []))))</code></pre>
<p>We can see that <code>(++)</code> operators are right-nested.</p>
<p>This also explains why <code>DList</code> in the previous section performs well because <code>DList</code> is just <code>Endo</code> specialized to lists.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">DList</span> a <span class="fu">=</span> <span class="dt">DL</span> {<span class="ot"> unDL ::</span> [a] <span class="ot">-&gt;</span> [a] }

<span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">DList</span> a) <span class="kw">where</span>
    mempty  <span class="fu">=</span> <span class="dt">DL</span> id
    mappend xs ys <span class="fu">=</span> <span class="dt">DL</span> (unDL xs <span class="fu">.</span> unDL ys)</code></pre></div>
<h1 id="state-monad">State Monad</h1>
<p>It is possible to implement the Writer monad in terms of the <em>State monad</em>. We can store the accumulated logs in the state and update it by appending a new log.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Trans.State</span>
<span class="kw">import </span><span class="dt">Data.Monoid</span> ((&lt;&gt;))

<span class="ot">calc ::</span> <span class="dt">State</span> [<span class="dt">LogEntry</span>] <span class="dt">Integer</span>
calc <span class="fu">=</span> <span class="fu">...</span>

<span class="ot">output ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">State</span> [<span class="dt">LogEntry</span>] ()
output x <span class="fu">=</span> modify (<span class="fu">&lt;&gt;</span> [<span class="dt">LogEntry</span> x])

test <span class="fu">=</span> mapM_ print <span class="fu">$</span> execState calc []</code></pre></div>
<p>Unfortunately, this version has the same performance issue with the initial version because applications of <code>(++)</code> are left-nested.</p>
<p>But there is a magical trick that can change this situation.</p>
<h1 id="backward-state-monad">Backward State Monad</h1>
<p>The section “2.8 Variation six: Backwards state” of Philip Wadler’s <a href="https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/the-essence-of-functional-programming.pdf">The essence of functional programming</a> briefly mentions the <em>Backwards state</em> monad (also known as <em>reverse state monad</em>). This is a strange variant of the State monad where the state is propagated backward.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">RState</span> s a <span class="fu">=</span> <span class="dt">RState</span> {<span class="ot"> runRState ::</span> s <span class="ot">-&gt;</span> (a,s) }

<span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">RState</span> s) <span class="kw">where</span>
    return x <span class="fu">=</span> <span class="dt">RState</span> <span class="fu">$</span> (,) x
    <span class="dt">RState</span> sf <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">RState</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span>
        <span class="kw">let</span> (a,s&#39;&#39;) <span class="fu">=</span> sf s&#39;
            (b,s&#39;) <span class="fu">=</span> runRState (f a) s
        <span class="kw">in</span> (b,s&#39;&#39;)

rget <span class="fu">=</span> <span class="dt">RState</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> (s,s)
rmodify f <span class="fu">=</span> <span class="dt">RState</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> ((),f s)
rput <span class="fu">=</span> rmodify <span class="fu">.</span> const

execRState f s <span class="fu">=</span> snd (runRState f s)</code></pre></div>
<p>In the definition of <code>&gt;&gt;=</code>, the state <code>s</code> is passed to the second expression and its result <code>s'</code> is passed back to the first expression. This seems impossible because two expressions are mutually recursive, but Haskell’s lazy evaluation makes it possible. In the backward state monad, <code>rget</code> reads the state from the future!</p>
<p>With this in mind, we can implement the Writer monad by prepending the log to the state. Because the state contains all the future logs, we can simply prepend our log to it.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">calc ::</span> <span class="dt">RState</span> [<span class="dt">LogEntry</span>] <span class="dt">Integer</span>
calc <span class="fu">=</span> <span class="fu">...</span>

<span class="ot">output ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">RState</span> [<span class="dt">LogEntry</span>] ()
output x <span class="fu">=</span> rmodify ([<span class="dt">LogEntry</span> x]<span class="fu">&lt;&gt;</span>)

test <span class="fu">=</span> mapM_ print <span class="fu">$</span> execRState calc []</code></pre></div>
<p>Applications of <code>(++)</code> are right-nested because logs are accumulated backward from the end.</p>
<p>Readers who would like to know more about the backward state monads are referred to:</p>
<ul>
<li><a href="https://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/">Mindfuck: The Reverse State Monad</a> shows how to compute the fibonacci number using the reverse state monad.</li>
<li><a href="https://hackage.haskell.org/package/tardis-0.4.1.0">tardis</a> package - a combination of both a forwards and a backwards state transformer.</li>
</ul>]]></description>
    <pubDate>Sat, 21 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-21-writer-monad.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>

    </channel>
</rss>
