<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Haskell for Pragmatic Programmers</title>
        <link>http://kseo.github.io/</link>
        <description><![CDATA[Kwang Yul Seo's Haskell Blog]]></description>
        <atom:link href="http://kseo.github.io//rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Sun, 08 Jan 2017 00:00:00 UT</lastBuildDate>
        <item>
    <title>Visible Type Application in GHC 8</title>
    <link>http://kseo.github.io//posts/2017-01-08-visible-type-application-ghc8.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on January  8, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/TypeApplications.html">TypeApplications</a>
      
  </div>

<p>GHC 8.0 introduced a new GHC extension named <a href="https://ghc.haskell.org/trac/ghc/wiki/TypeApplication">TypeApplications</a> which allows us to give explicit type arguments to a polymorphic function.</p>
<p>To see what <code>TypeApplications</code> does, we need to understand how polymorphism in Haskell is implemented under the hood. In Haskell, a polymorphic function is translated into a function which takes both type arguments and value arguments. For example,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">id<span class="ot"> ::</span> a <span class="ot">-&gt;</span> a
id x <span class="fu">=</span> x</code></pre></div>
<p>is translated into</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">id<span class="ot"> ::</span> forall a <span class="fu">.</span> a <span class="ot">-&gt;</span> a
id <span class="fu">@</span>a x <span class="fu">=</span> x</code></pre></div>
<p>Here <code>@a</code> is the type argument. The specialization of <code>id</code> to <code>idString</code> is represented by passing <code>@String</code> type argument to <code>id</code> function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">idString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
idString <span class="fu">=</span> id <span class="fu">@</span><span class="dt">String</span></code></pre></div>
<p>This is not an ad-hoc way to implement polymorphism. The trick of passing around type parameters as ordinary function arguments was devised by <em>System F</em> (as known as the <em>polymorphic lambda calculus</em>) and GHC uses System F as its internal representation. An interested reader might want to take a look at Gabriel Gonzalez’s <a href="http://www.haskellforall.com/2015/10/polymorphism-for-dummies.html">Polymorphism for dummies</a> for other examples.</p>
<p>Before GHC 8.0, the type application was invisible. There was no way to pass the type parameter such as <code>@String</code> and <code>@Int</code> explicitly. GHC infers the type from the argument type, or we had to specify the type using type annotations.</p>
<pre><code>λ&gt; id &quot;a&quot;
&quot;a&quot;
λ&gt; id (3 :: Int)
3</code></pre>
<p><code>TypeApplications</code> extension allows us to give explicit type arguments.</p>
<pre><code>λ&gt; :set -XTypeApplications
λ&gt; id @String &quot;a&quot;
&quot;a&quot;
λ&gt; id @Int 3
3</code></pre>
<p>This is useful in resolving ambiguity in type classes or type families. The show/read problem from <a href="http://kseo.github.io/posts/2017-01-04-type-defaulting-in-haskell.html">Type defaulting in Haskell</a> was not typeable due to ambiguity, but we can easily remove ambiguity by giving an explicit type argument.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeApplications #-}</span>

<span class="ot">f ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
f s <span class="fu">=</span> show (read <span class="fu">@</span><span class="dt">Int</span> s)</code></pre></div>
<p>The type argument is not limited to concrete types. As we can pass a variable to a function as an argument, it is possible to pass a type variable to a function as a type argument if it is explicitly quantified with <code>ExplicitForAll</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ExplicitForAll      #-}</span>
<span class="ot">{-# LANGUAGE TypeApplications    #-}</span>

<span class="ot">incShow ::</span> forall a <span class="fu">.</span> (<span class="dt">Read</span> a, <span class="dt">Show</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
incShow <span class="fu">=</span> show <span class="fu">.</span> (<span class="fu">+</span><span class="dv">1</span>) <span class="fu">.</span> read <span class="fu">@</span>a</code></pre></div>
<pre><code>λ&gt; incShow @Double &quot;3.0&quot;
&quot;4.0&quot;`</code></pre>
<p>In the following example, <code>g False</code> would be ill-typed because GHC can’t infer the proper type. Adding the explicit type <code>@Char</code> resolves the problem.</p>
<pre><code>type family F a
type instance F Char = Bool

g :: F a -&gt; a
g _ = undefined

f :: Char
f = g True

h = g False -- will cause an error
h&#39; = g @Char False</code></pre>
<p>Some of these cases can be solved with type annotations, but it can be cumbersome in complicated examples. Visible type applications generally provide a more succinct way to resolve ambiguity.</p>
<p>If you would like to know the technical details of <code>TypeApplications</code>, please refer to <a href="https://www.seas.upenn.edu/~sweirich/papers/type-app-extended.pdf">Visible Type Application (Extended version)</a>.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-08-visible-type-application-ghc8.html";
    this.page.identifier = "/posts/2017-01-08-visible-type-application-ghc8.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Sun, 08 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-08-visible-type-application-ghc8.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Strict Identity Monad</title>
    <link>http://kseo.github.io//posts/2017-01-07-strict-identity-monad.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on January  7, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/identity%20monad.html">identity monad</a>, <a href="/tags/lazy.html">lazy</a>, <a href="/tags/strict.html">strict</a>
      
  </div>

<p>In my <a href="http://kseo.github.io/posts/2016-12-28-lazy-vs-strict-state-monad.html">previous post</a>, I explained the difference between the lazy and strict state monads. What I didn’t mention in the post is that the state monad is not special in this regard. Other monads also can have both lazy and strict variants. For example, <a href="https://www.stackage.org/lts-7.12/package/transformers-0.5.2.0">transformers</a> package provides both flavors of monads for <code>RWS</code> and <code>Writer</code> monads too.</p>
<p>It is also possible to have identity monads with either lazy or strict semantics. <em>transformers</em> package provides only the lazy variant, but it is not hard to image a strict variant of the identity monad. Here’s the definition of <code>Control.Monad.StrictIdentity</code> defined in <a href="https://hackage.haskell.org/package/strict-identity">strict-identity</a> package.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">StrictIdentity</span> a <span class="fu">=</span>  <span class="dt">StrictIdentity</span> {<span class="ot">runStrictIdentity_ ::</span> a }

<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">StrictIdentity</span> <span class="kw">where</span>
    return <span class="fu">!</span>a <span class="fu">=</span> <span class="dt">StrictIdentity</span> <span class="fu">$!</span> a
    (<span class="fu">!</span>m) <span class="fu">&gt;&gt;=</span> (<span class="fu">!</span>k)  <span class="fu">=</span> k <span class="fu">$!</span> runStrictIdentity  m</code></pre></div>
<p>The strict identity monad when bound to a function always evaluate its argument. We can see that both <a href="https://ocharles.org.uk/blog/posts/2014-12-05-bang-patterns.html">BangPatterns</a> and the strict application operator <code>($!)</code> are used to enforce strict evaluation of arguments.</p>
<p>In this sense, <a href="https://www.stackage.org/haddock/lts-7.12/parallel-3.2.1.0/Control-Parallel-Strategies.html#t:Eval">Eval</a> monad from <code>Control.Parallel.Strategies</code> is also an identity monad. It enforces the strict evaluation of the argument with pattern matching.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Eval</span> a <span class="fu">=</span> <span class="dt">Done</span> a

<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Eval</span> <span class="kw">where</span>
  return x <span class="fu">=</span> <span class="dt">Done</span> x
  <span class="dt">Done</span> x <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> k x   <span class="co">-- Note: pattern &#39;Done x&#39; makes &#39;&gt;&gt;=&#39; strict</span></code></pre></div>
<p>In <a href="http://kseo.github.io/posts/2017-01-05-implementing-a-call-by-value-interpreter-in-haskell.html">Implementing a call-by-value interpreter in Haskell</a>, I mistakenly used the lazy identity monad to force the evaluation order. We need to keep in mind that transforming a program into a monadic form does not automatically guarantees the evaluation order unless the monad is strict.</p>
<p><strong>UPDATE</strong>: Calling arbitrary monads lazy or strict is not appropriate as each monad has varying degree of strictness. For example, the <code>StrictIdentity</code> is more strict than the <code>Eval</code> monad. See <a href="https://www.reddit.com/r/haskell/comments/5mp9e8/kwangs_haskell_blog_strict_identity_monad/">the Reddit discussion thread</a> for details.</p>
<pre><code>λ&gt; Control.Monad.StrictIdentity.runStrictIdentity $ do x &lt;- return undefined; return 1
*** Exception: Prelude.undefined
λ&gt; Control.Parallel.Strategies.runEval $ do x &lt;- return undefined; return 1
1</code></pre>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-07-strict-identity-monad.html";
    this.page.identifier = "/posts/2017-01-07-strict-identity-monad.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Sat, 07 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-07-strict-identity-monad.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Implementing a call-by-value interpreter in Haskell</title>
    <link>http://kseo.github.io//posts/2017-01-05-implementing-a-call-by-value-interpreter-in-haskell.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on January  5, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/call-by-value.html">call-by-value</a>, <a href="/tags/interpreter.html">interpreter</a>, <a href="/tags/Strict.html">Strict</a>
      
  </div>

<p>Call-by-value is the most commonly used evaluation strategy in which all arguments to a function are reduced to normal form before they are bound inside lambda. Languages such as Java, C++, Scala and F# all use this evaluation model. A notable exception is Haskell, which uses call-by-need evaluation in which expressions are represented as <em>thunks</em> which are passed into a function unevaluated and only evaluated when needed.</p>
<p>This difference in evaluation model poses some challenges in writing a call-by-value interpreter in Haskell. In this post, I am going to explain how we can implement a call-by-value interpreter using various methods.</p>
<p>Let’s start the discussion by writing a lambda calculus interpreter.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Lam</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Lit</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Prim</span> <span class="dt">PrimOp</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Bot</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">data</span> <span class="dt">Value</span>
  <span class="fu">=</span> <span class="dt">VInt</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">VClosure</span> <span class="dt">Expr</span> <span class="dt">Env</span>

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Value</span> <span class="kw">where</span>
  show (<span class="dt">VInt</span> i) <span class="fu">=</span> show i
  show <span class="dt">VClosure</span>{} <span class="fu">=</span> <span class="st">&quot;&lt;&lt;closure&gt;&gt;&quot;</span>

<span class="kw">data</span> <span class="dt">PrimOp</span> <span class="fu">=</span> <span class="dt">Add</span> <span class="fu">|</span> <span class="dt">Mul</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> [<span class="dt">Value</span>]

<span class="ot">eval ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
eval env term <span class="fu">=</span> <span class="kw">case</span> term <span class="kw">of</span>
  <span class="dt">Var</span> n <span class="ot">-&gt;</span> env <span class="fu">!!</span> n
  <span class="dt">Lam</span> a <span class="ot">-&gt;</span> <span class="dt">VClosure</span> a env
  <span class="dt">App</span> a b <span class="ot">-&gt;</span>
    <span class="kw">let</span> <span class="dt">VClosure</span> c env&#39; <span class="fu">=</span> eval env a <span class="kw">in</span>
    <span class="kw">let</span> v <span class="fu">=</span> eval env b <span class="kw">in</span>
    eval (v <span class="fu">:</span> env&#39;) c

  <span class="dt">Lit</span> n <span class="ot">-&gt;</span> <span class="dt">VInt</span> n
  <span class="dt">Prim</span> p a b <span class="ot">-&gt;</span> (evalPrim p) (eval env a) (eval env b)
  <span class="dt">Bot</span> <span class="ot">-&gt;</span> error <span class="st">&quot;Evaluation would not terminate&quot;</span>

<span class="ot">evalPrim ::</span> <span class="dt">PrimOp</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
evalPrim <span class="dt">Add</span> (<span class="dt">VInt</span> a) (<span class="dt">VInt</span> b) <span class="fu">=</span> <span class="dt">VInt</span> (a <span class="fu">+</span> b)
evalPrim <span class="dt">Mul</span> (<span class="dt">VInt</span> a) (<span class="dt">VInt</span> b) <span class="fu">=</span> <span class="dt">VInt</span> (a <span class="fu">*</span> b)

<span class="ot">emptyEnv ::</span> <span class="dt">Env</span>
emptyEnv <span class="fu">=</span> []

<span class="co">-- (\x y -&gt; x) 10 bot</span>
<span class="ot">test ::</span> <span class="dt">Value</span>
test <span class="fu">=</span> eval emptyEnv <span class="fu">$</span> <span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Lam</span> (<span class="dt">Lam</span> (<span class="dt">Var</span> <span class="dv">1</span>))) (<span class="dt">Lit</span> <span class="dv">10</span>)) <span class="dt">Bot</span></code></pre></div>
<p>Can you guess the evaluation order implemented by this interpreter? Because <code>test</code> is equivalent to <code>(\x y -&gt; x) 10 undefined</code>, it would be <code>undefined</code> in a call-by-value language.</p>
<p>Let’s evaluate <code>test</code> on GHCi.</p>
<pre><code>λ&gt; test
10</code></pre>
<p>The evaluation order implemented by our interpreter is call-by-need because the defining language, Haskell, uses the call-by-need evaluation order and our interpreter depends on this. Transforming our interpreter into a call-by-value interpreter is not trivial because we need to find and fix every place where lazy evaluation is used in our interpreter.</p>
<p>In his seminar paper <a href="http://surface.syr.edu/cgi/viewcontent.cgi?article=1012&amp;context=lcsmith_other">Definitional interpreters for higher-order programming languages</a>, John C. Reynolds showed how to remove this order dependence by CPS transformation. <del>But in Haskell, we can use monads to enforce the evaluation order. This is not a coincidence because there is a <a href="https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/the-essence-of-functional-programming.pdf">close relationship</a> between computational monads and generalized CPS.</del></p>
<p><strong>UPDATE: There is a technical mistake in the original article. The Identity monad does not make any difference here. I should have used either a strict variant of Identity monad or the Cont monad to force strict evaluation.</strong></p>
<p>Here’s a monadic version of our interpreter.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Identity</span>

<span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Lam</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Lit</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Prim</span> <span class="dt">PrimOp</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Bot</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">data</span> <span class="dt">Value</span>
  <span class="fu">=</span> <span class="dt">VInt</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">VClosure</span> <span class="dt">Expr</span> <span class="dt">Env</span>

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Value</span> <span class="kw">where</span>
  show (<span class="dt">VInt</span> i) <span class="fu">=</span> show i
  show <span class="dt">VClosure</span>{} <span class="fu">=</span> <span class="st">&quot;&lt;&lt;closure&gt;&gt;&quot;</span>

<span class="kw">data</span> <span class="dt">PrimOp</span> <span class="fu">=</span> <span class="dt">Add</span> <span class="fu">|</span> <span class="dt">Mul</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> [<span class="dt">Value</span>]

<span class="ot">eval ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> m <span class="dt">Value</span>
eval env term <span class="fu">=</span> <span class="kw">case</span> term <span class="kw">of</span>
  <span class="dt">Var</span> n <span class="ot">-&gt;</span> return <span class="fu">$</span> env <span class="fu">!!</span> n
  <span class="dt">Lam</span> a <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">VClosure</span> a env
  <span class="dt">App</span> a b <span class="ot">-&gt;</span> <span class="kw">do</span>
    <span class="dt">VClosure</span> c env&#39; <span class="ot">&lt;-</span> eval env a
    v <span class="ot">&lt;-</span> eval env b
    eval (v <span class="fu">:</span> env&#39;) c

  <span class="dt">Lit</span> n <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">VInt</span> n
  <span class="dt">Prim</span> p a b <span class="ot">-&gt;</span> evalPrim p <span class="fu">&lt;$&gt;</span> eval env a <span class="fu">&lt;*&gt;</span> eval env b
  <span class="dt">Bot</span> <span class="ot">-&gt;</span> error <span class="st">&quot;Evaluation would not terminate&quot;</span>

<span class="ot">evalPrim ::</span> <span class="dt">PrimOp</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
evalPrim <span class="dt">Add</span> (<span class="dt">VInt</span> a) (<span class="dt">VInt</span> b) <span class="fu">=</span> <span class="dt">VInt</span> (a <span class="fu">+</span> b)
evalPrim <span class="dt">Mul</span> (<span class="dt">VInt</span> a) (<span class="dt">VInt</span> b) <span class="fu">=</span> <span class="dt">VInt</span> (a <span class="fu">*</span> b)

<span class="ot">emptyEnv ::</span> <span class="dt">Env</span>
emptyEnv <span class="fu">=</span> []

<span class="co">-- (\x y -&gt; x) 10 bot</span>
<span class="ot">test ::</span> <span class="dt">Value</span>
test <span class="fu">=</span> runIdentity <span class="fu">$</span> eval emptyEnv <span class="fu">$</span> <span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Lam</span> (<span class="dt">Lam</span> (<span class="dt">Var</span> <span class="dv">1</span>))) (<span class="dt">Lit</span> <span class="dv">10</span>)) <span class="dt">Bot</span></code></pre></div>
<p>Let’s evaluate <code>test</code> again.</p>
<pre><code>λ&gt; test
10</code></pre>
<p>Oops. What went wrong? The problem is that our interpreter does not enforce the evaluation of the argument in <code>App a b</code> case of <code>eval</code>. <code>v &lt;- eval env b</code> just binds a thunk to <code>v</code> and it won’t be evaluated until it is actually needed. To fix the problem, we need to force the evaluation of the argument using <em>bang patterns</em>.</p>
<p><strong>UPDATE: This bang pattern is not necessary if we used a strict monad.</strong></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE BangPatterns #-}</span>

<span class="fu">...</span>

<span class="ot">eval ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> m <span class="dt">Value</span>
eval env term <span class="fu">=</span> <span class="kw">case</span> term <span class="kw">of</span>
  <span class="dt">Var</span> n <span class="ot">-&gt;</span> return <span class="fu">$</span> env <span class="fu">!!</span> n
  <span class="dt">Lam</span> a <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">VClosure</span> a env
  <span class="dt">App</span> a b <span class="ot">-&gt;</span> <span class="kw">do</span>
    <span class="dt">VClosure</span> c env&#39; <span class="ot">&lt;-</span> eval env a
    <span class="fu">!</span>v <span class="ot">&lt;-</span> eval env b
    eval (v <span class="fu">:</span> env&#39;) c

  <span class="dt">Lit</span> n <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">VInt</span> n
  <span class="dt">Prim</span> p a b <span class="ot">-&gt;</span> evalPrim p <span class="fu">&lt;$&gt;</span> eval env a <span class="fu">&lt;*&gt;</span> eval env b
  <span class="dt">Bot</span> <span class="ot">-&gt;</span> error <span class="st">&quot;Evaluation would not terminate&quot;</span>

<span class="fu">...</span></code></pre></div>
<p>Finally, we can see that evaluating <code>test</code> throws an error.</p>
<pre><code>λ&gt; test
*** Exception: Evaluation would not terminate</code></pre>
<p>The moral of this story is that it is really hard to correctly implement a call-by-value interpreter in Haskell. There is high chance of making a mistake. For example, let’s add a division operator to our interpreter.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">PrimOp</span> <span class="fu">=</span> <span class="dt">Add</span> <span class="fu">|</span> <span class="dt">Mul</span> <span class="fu">|</span> <span class="dt">Div</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="ot">evalPrim ::</span> <span class="dt">PrimOp</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
evalPrim <span class="dt">Add</span> (<span class="dt">VInt</span> a) (<span class="dt">VInt</span> b) <span class="fu">=</span> <span class="dt">VInt</span> (a <span class="fu">+</span> b)
evalPrim <span class="dt">Mul</span> (<span class="dt">VInt</span> a) (<span class="dt">VInt</span> b) <span class="fu">=</span> <span class="dt">VInt</span> (a <span class="fu">*</span> b)
evalPrim <span class="dt">Div</span> (<span class="dt">VInt</span> a) (<span class="dt">VInt</span> b) <span class="fu">=</span> <span class="dt">VInt</span> (a <span class="ot">`div`</span> b)

<span class="co">-- (\x y -&gt; x) 10 (20 / 0)</span>
<span class="ot">test ::</span> <span class="dt">Value</span>
test <span class="fu">=</span> runIdentity <span class="fu">$</span> eval emptyEnv <span class="fu">$</span> <span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Lam</span> (<span class="dt">Lam</span> (<span class="dt">Var</span> <span class="dv">1</span>))) (<span class="dt">Lit</span> <span class="dv">10</span>)) (<span class="dt">Prim</span> <span class="dt">Div</span> (<span class="dt">Lit</span> <span class="dv">20</span>) (<span class="dt">Lit</span> <span class="dv">0</span>))</code></pre></div>
<p>Evaluating <code>test</code> must throw an divide-by-zero error because its second argument is <code>20 / 0</code>. But GHCi shows that we reverted back to cal-by-need.</p>
<pre><code>λ&gt; test
10</code></pre>
<p>This happens because the data constructor <code>VInt</code> is not strict. <code>20 / 0</code> is evaluated to <code>VInt undefined</code> instead of <code>undefined</code>. To make it call-by-value again, we need to add another bang pattern to <code>VInt</code> data constructor as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Value</span>
  <span class="fu">=</span> <span class="dt">VInt</span> <span class="fu">!</span><span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">VClosure</span> <span class="dt">Expr</span> <span class="dt">Env</span></code></pre></div>
<p>Fortunately, we can avoid this tricky business and make our first interpreter call-by-value by just adding <a href="https://ghc.haskell.org/trac/ghc/wiki/StrictPragma">Strict</a> language extension introduced in GHC 8. <code>Strict</code> pragma allows us to switch the default evaluation strategy to call-by-value on a per module basis. This saves us huge efforts because writing a call-by-value interpreter in a call-by-value language is an easy task!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE Strict #-}</span></code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-05-implementing-a-call-by-value-interpreter-in-haskell.html";
    this.page.identifier = "/posts/2017-01-05-implementing-a-call-by-value-interpreter-in-haskell.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Thu, 05 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-05-implementing-a-call-by-value-interpreter-in-haskell.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Type defaulting in Haskell</title>
    <link>http://kseo.github.io//posts/2017-01-04-type-defaulting-in-haskell.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on January  4, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/type%20defaulting.html">type defaulting</a>
      
  </div>

<p>Type defaulting is introduced to solve the ambiguous type problems caused by type classes.</p>
<p>Consider the following classic example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">show<span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>
read<span class="ot"> ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a

<span class="ot">f ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
f s <span class="fu">=</span> show (read s)</code></pre></div>
<p><code>f</code> appears to be well-typed, but GHC complains about the ambiguous type variable. The problem is that there is nothing to specify the type of the intermediate subexpression <code>(read s)</code>. <code>read</code> can parse an <code>Int</code>, a <code>String</code> or any other type that is an instance of <code>Read</code>. The compiler can’t arbitrarily choose a type because the choice of the type affects the program behavior. We can avoid the ambiguity by specifying the type explicitly:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
f s <span class="fu">=</span> show (read<span class="ot"> s ::</span> <span class="dt">Int</span>)</code></pre></div>
<p>However, the restriction above becomes quite cumbersome when we need to handle numeric types. For example,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">negate<span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
show<span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>

(show (negate <span class="dv">4</span>))</code></pre></div>
<p>The expression <code>(show (negate 4))</code> is ambiguous because the literal <code>4</code> is of <code>Num a =&gt; a</code> type in Haskell. <code>4</code> can be an <code>Int</code>, a <code>Float</code> or any other type that is an instance of <code>Num</code>, so the compiler can’t choose any particular type for the same reason above. But the Haskell Committee thought that this is too much restriction. After much debates, they compromised and added an ad-hoc rule for choosing a particular default type. <a href="https://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf">A History of Haskell</a> mentions the rationale behind this decision:</p>
<blockquote>
<p>Performing numerical calculations on constants is one of the very first things a Haskell programmer does, and furthermore there is more reason to expect numeric operations to behave in similar ways for different types than there is for non-numeric operations.</p>
</blockquote>
<p>The default type of <code>Num</code> is <code>Integer</code>, so the Haskell compiler infers the type of <code>(negate 4)</code> as <code>Integer</code> instead of rejecting it as an invalid program.</p>
<p>Haskell default rule can be summarized as:</p>
<pre><code>default Num Integer
default Real Integer
default Enum Integer
default Integral Integer
default Fractional Double
default RealFrac Double
default Floating Double
default RealFloat Double</code></pre>
<p>The type defaulting rule is very conservative. Defaults are limited to Prelude numeric classes and cannot be applied to user-defined classes. Our first example <code>f</code> is invalid because <code>Read</code> is not a numeric type class. But, sometimes, we would like to change the default type for the type classes. So Haskell lets us specify a list of types in a special top-level <em>default</em> declaration.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">default (<span class="dt">Int</span>, <span class="dt">Float</span>)</code></pre></div>
<p>The restriction is still too tight. According to the rule, even innocuously looking <code>show []</code> is not typeable because GHC can’t decide the type of <code>[a]</code>. So compiling the following program causes an ambiguous type error.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class="fu">=</span> show []</code></pre></div>
<p>But every Haskell programmer knows that <code>show []</code> works fine in GHCi from experience. We don’t know the exact type chosen because the output is always <code>&quot;[]&quot;</code> regardless of the type. But it works anyway. What happened here?</p>
<pre><code>λ&gt; show []
&quot;[]&quot;</code></pre>
<p>In fact, GHCi extends Haskell’s type-defaulting rules by including <code>Show</code>, <code>Eq</code> and <code>Ord</code> in addition to numeric type classes. <a href="https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/interactive-evaluation.html">Type defaulting in GHCi</a> explains the details. It also adds the unit type <code>()</code> to the standard list of types which are tried when doing type defaulting. So the type of <code>[]</code> in <code>show []</code> becomes <code>[()]</code> according to the extended type defaulting rules in GHCi.</p>
<p>Type defaulting in Haskell is one of the controversial language features. It is confusing to novice Haskell programmers because the defaulting rule is very ad-hoc. Interested readers might want to take a look several enhancement <a href="https://prime.haskell.org/wiki/Defaulting">proposals</a> being discussed in Haskell Prime Wiki.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-04-type-defaulting-in-haskell.html";
    this.page.identifier = "/posts/2017-01-04-type-defaulting-in-haskell.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Wed, 04 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-04-type-defaulting-in-haskell.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Writing an interpreter using fold</title>
    <link>http://kseo.github.io//posts/2017-01-03-writing-an-interpreter-using-fold.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on January  3, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/fold.html">fold</a>, <a href="/tags/interpreter.html">interpreter</a>, <a href="/tags/catamorphism.html">catamorphism</a>
      
  </div>

<p><em>fold</em> is a Swiss Army knife in functional programming. It is <a href="http://www.cs.nott.ac.uk/~pszgmh/fold.pdf">expressive</a> enough to write an interpreter for a simple functional programming language.</p>
<p>Let’s start with a simple arithmetic language.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">Const</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>           <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
<span class="ot">&gt;</span>           <span class="fu">|</span> <span class="dt">Mul</span> <span class="dt">Expr</span> <span class="dt">Expr</span></code></pre></div>
<p>Writing an interpreter for this language is trivial.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; interp ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> interp (<span class="dt">Const</span> x) <span class="fu">=</span> x
<span class="ot">&gt;</span> interp (<span class="dt">Add</span> e1 e2) <span class="fu">=</span> interp e1 <span class="fu">+</span> interp e2
<span class="ot">&gt;</span> interp (<span class="dt">Mul</span> e1 e2) <span class="fu">=</span> interp e1 <span class="fu">*</span> interp e2</code></pre></div>
<p>Writing a pretty printer is also easy.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; pretty ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="ot">&gt;</span> pretty (<span class="dt">Const</span> x) <span class="fu">=</span> show x
<span class="ot">&gt;</span> pretty (<span class="dt">Add</span> e1 e2) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> pretty e1 <span class="fu">++</span> <span class="st">&quot; + &quot;</span> <span class="fu">++</span> pretty e2 <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
<span class="ot">&gt;</span> pretty (<span class="dt">Mul</span> e1 e2) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> pretty e1 <span class="fu">++</span> <span class="st">&quot; * &quot;</span> <span class="fu">++</span> pretty e2 <span class="fu">++</span> <span class="st">&quot;)&quot;</span></code></pre></div>
<p>Sensitive readers might have noticed the duplication of code in <code>interp</code> and <code>pretty</code>. Yes, recursion on the structure of <code>Expr</code> is repeated.</p>
<p>We can extract recursion as <code>foldExpr</code> and algorithms as <code>ExprA</code>. <code>foldExpr</code> does recursion on the structure of <code>Expr</code> regardless of the algorithm being used.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">ExprA</span> a <span class="fu">=</span> <span class="dt">ExprA</span>
<span class="ot">&gt;</span>   {<span class="ot"> val ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span>   ,<span class="ot"> add ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span>   ,<span class="ot"> mul ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span>   }
<span class="ot">&gt;</span> 
<span class="ot">&gt; foldExpr ::</span> <span class="dt">ExprA</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> foldExpr alg (<span class="dt">Const</span> i)   <span class="fu">=</span> val alg i
<span class="ot">&gt;</span> foldExpr alg (<span class="dt">Add</span> e1 e2) <span class="fu">=</span> add alg (foldExpr alg e1) (foldExpr alg e2)
<span class="ot">&gt;</span> foldExpr alg (<span class="dt">Mul</span> e1 e2) <span class="fu">=</span> mul alg (foldExpr alg e1) (foldExpr alg e2)</code></pre></div>
<p>Now it is possible to define the interpreter just by giving <code>val</code>, <code>add</code> and <code>mul</code> functions.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; interpA ::</span> <span class="dt">ExprA</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> interpA <span class="fu">=</span> <span class="dt">ExprA</span>
<span class="ot">&gt;</span>   { val <span class="fu">=</span> id
<span class="ot">&gt;</span>   , add <span class="fu">=</span> (<span class="fu">+</span>)
<span class="ot">&gt;</span>   , mul <span class="fu">=</span> (<span class="fu">*</span>)
<span class="ot">&gt;</span>   }</code></pre></div>
<p>The same goes for pretty printer.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prettyA ::</span> <span class="dt">ExprA</span> <span class="dt">String</span>
<span class="ot">&gt;</span> prettyA <span class="fu">=</span> <span class="dt">ExprA</span>
<span class="ot">&gt;</span>   { val <span class="fu">=</span> show
<span class="ot">&gt;</span>   , add <span class="fu">=</span> \a b <span class="ot">-&gt;</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> a <span class="fu">++</span> <span class="st">&quot; + &quot;</span> <span class="fu">++</span> b <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
<span class="ot">&gt;</span>   , mul <span class="fu">=</span> \a b <span class="ot">-&gt;</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> a <span class="fu">++</span> <span class="st">&quot; * &quot;</span> <span class="fu">++</span> b <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
<span class="ot">&gt;</span>   }</code></pre></div>
<p>Here is our <code>interp'</code> function defined in terms of <code>foldExpr</code> and <code>interpA</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; interp&#39; ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> interp&#39; <span class="fu">=</span> foldExpr interpA</code></pre></div>
<p>We successfully isolated algorithms from recursion, but we are still not satisfied. <code>ExprA</code> is mostly duplication of <code>Expr</code> and defining <code>foldExpr</code> is boilerplate.</p>
<p>We can fix this by introducing <em>F-algebras</em> and <em>catamorphisms</em>. Interested readers might want to take a look at Bartosz Milewski’s <a href="https://bartoszmilewski.com/2013/06/10/understanding-f-algebras/">Understanding F-Algebras</a> article.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-03-writing-an-interpreter-using-fold.html";
    this.page.identifier = "/posts/2017-01-03-writing-an-interpreter-using-fold.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Tue, 03 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-03-writing-an-interpreter-using-fold.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Hindley-Milner type inference with constraints</title>
    <link>http://kseo.github.io//posts/2017-01-02-hindley-milner-inference-with-constraints.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on January  2, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/type%20inference.html">type inference</a>, <a href="/tags/Hindley-Milner.html">Hindley-Milner</a>, <a href="/tags/constraints.html">constraints</a>
      
  </div>

<p>Algorithm W is the best known algorithm for implementing Hindley-Milner type inference. But it is a bit complicated as it intermingles two separate processes: constraint generation and solving.</p>
<p>There is an alternative approach based on <em>constraints generation</em>. In this approach, constraints are collected by bottom-up traversal, and then solved independently. Heeren’s <a href="http://soft.vub.ac.be/~cfscholl/Capita-Selecta-2015/papers/2002%20Heeren.pdf">Generalizing Hindley-Milner Type Inference Algorithms</a> paper describes the algorithm in details.</p>
<p>Here’s <a href="https://github.com/kseo/poly_constraints">my implementation</a> of Heeren’s algorithm. I forked Stephen Diehls’s <a href="https://github.com/sdiehl/write-you-a-haskell/tree/master/chapter7/poly_constraints">Poly</a> and modified <a href="https://github.com/kseo/poly_constraints/blob/master/src/Infer.hs">the type checker</a> to use the Heeren’s algorithm.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-02-hindley-milner-inference-with-constraints.html";
    this.page.identifier = "/posts/2017-01-02-hindley-milner-inference-with-constraints.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Mon, 02 Jan 2017 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2017-01-02-hindley-milner-inference-with-constraints.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Type inference algorithms of Haskell-like languages</title>
    <link>http://kseo.github.io//posts/2016-12-31-type-inference-algorithms-of-haskell-like-languages.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 31, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/type%20inference.html">type inference</a>, <a href="/tags/type%20system.html">type system</a>, <a href="/tags/Haskell.html">Haskell</a>
      
  </div>

<p>I collected papers on the type inference algorithms used by Haskell-like languages.</p>
<h1 id="haskell">Haskell</h1>
<p>Haskell supports advanced type system features such as GADTs, type classes and type families. The current type checker implemented by GHC is described in <a href="https://www.microsoft.com/en-us/research/publication/outsideinx-modular-type-inference-with-local-assumptions/">OutsideIn(X): Modular type inference with local assumptions</a>.</p>
<h1 id="purescript">PureScript</h1>
<p>The type checker of PureScript is inspired by the following papers. It supports type classes, row polymorphism, higher kinded polymorphism (rank N types). There are no soundness proofs yet.</p>
<ul>
<li><a href="https://people.mpi-sws.org/~neelk/bidir.pdf">Complete and Easy Bidirectional Typechecking for Higher-Rank Polymorphism</a></li>
<li><a href="https://www.microsoft.com/en-us/research/publication/hmf-simple-type-inference-for-first-class-polymorphism/">HMF: Simple Type Inference for First-Class Polymorphism</a></li>
<li><a href="https://www.microsoft.com/en-us/research/publication/koka-programming-with-row-polymorphic-effect-types/">Koka: Programming with Row-polymorphic Effect Types</a></li>
</ul>
<h1 id="elm">Elm</h1>
<p>Elm’s type checker is an implementation of Pottier and Rem’s <a href="http://gallium.inria.fr/~fpottier/publis/emlti-final.pdf">The Essence of ML Type Inference</a> with two extensions:</p>
<ul>
<li>A limited set of built-in type classes (i.e. number, appendable, comparable)</li>
<li>Records based on <a href="https://www.microsoft.com/en-us/research/publication/extensible-records-with-scoped-labels/">Extensible records with scoped labels</a></li>
</ul>
<p>There is no support for type classes or higher kinded polymorphism yet.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2016-12-31-type-inference-algorithms-of-haskell-like-languages.html";
    this.page.identifier = "/posts/2016-12-31-type-inference-algorithms-of-haskell-like-languages.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Sat, 31 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-31-type-inference-algorithms-of-haskell-like-languages.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Write you an interpreter</title>
    <link>http://kseo.github.io//posts/2016-12-30-write-you-an-interpreter.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 30, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/interpreter.html">interpreter</a>
      
  </div>

<p>Writing an interpreter for a functional language is a good exercise in Haskell. There are several tutorials on this topic.</p>
<ul>
<li><a href="https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours">Write Yourself a Scheme in 48 Hours</a></li>
<li><a href="http://dev.stephendiehl.com/fun/">Write You a Haskell</a></li>
</ul>
<p>Implementation techniques used in these tutorials are similar even though their source languages are distinct. They all compile the source language into a small core language based on lambda calculus, and evaluate the program with a context (or an environment).</p>
<p>In this post, I am not going to revisit this common technique. Instead, I will show you how to compile a program to a finite, fixed set of combinators (SKI), and then evaluate these combinators as normal Haskell function. This technique was introduced in Matthew Naylor’s <a href="https://wiki.haskell.org/wikiupload/0/0a/TMR-Issue10.pdf">Evaluating Haskell in Haskell</a>.</p>
<p>The source code is available <a href="https://github.com/kseo/poly">here</a>.</p>
<h1 id="poly">Poly</h1>
<p>We are going to borrow the parser and type checker from Stephen Diehls’s <a href="https://github.com/sdiehl/write-you-a-haskell/tree/master/chapter7/poly_constraints">Poly</a>, a simple ML dialect with definitions, let polymorphism and a fixpoint operator.</p>
<p>An example of Poly:</p>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="kw">let</span> <span class="kw">rec</span> factorial n = <span class="kw">if</span> (n == <span class="dv">0</span>) <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> (n * (factorial (n<span class="dv">-1</span>)));</code></pre></div>
<p>The core language of Poly is a variant of lambda calculus. <code>Let</code>, <code>If</code>, <code>Fix</code> and <code>Op</code> are added as additional constructs.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">Name</span>
  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Lam</span> <span class="dt">Name</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Let</span> <span class="dt">Name</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Lit</span> <span class="dt">Lit</span>
  <span class="fu">|</span> <span class="dt">If</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Fix</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Op</span> <span class="dt">Binop</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)

<span class="kw">data</span> <span class="dt">Lit</span>
  <span class="fu">=</span> <span class="dt">LInt</span> <span class="dt">Integer</span>
  <span class="fu">|</span> <span class="dt">LBool</span> <span class="dt">Bool</span>
  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)

<span class="kw">data</span> <span class="dt">Binop</span> <span class="fu">=</span> <span class="dt">Add</span> <span class="fu">|</span> <span class="dt">Sub</span> <span class="fu">|</span> <span class="dt">Mul</span> <span class="fu">|</span> <span class="dt">Eql</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</code></pre></div>
<h1 id="desugar">Desugar</h1>
<p>Our first task is to desugar <code>Let</code>, <code>If</code>, <code>Fix</code> and <code>Op</code> to simplify the later stage of compilation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">desugar ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>
desugar (<span class="dt">App</span> fun arg) <span class="fu">=</span> <span class="dt">App</span> (desugar fun) (desugar arg)
desugar (<span class="dt">Lam</span> x body) <span class="fu">=</span> <span class="dt">Lam</span> x (desugar body)
desugar (<span class="dt">Let</span> x e body) <span class="fu">=</span> <span class="dt">App</span> (<span class="dt">Lam</span> x (desugar body)) (desugar e)
desugar (<span class="dt">If</span> cond tr fl) <span class="fu">=</span> foldl <span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;$IF&quot;</span>) args
   <span class="kw">where</span> args <span class="fu">=</span> map desugar [cond, tr, fl]
desugar (<span class="dt">Fix</span> e) <span class="fu">=</span> <span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;$FIX&quot;</span>) (desugar e)
desugar (<span class="dt">Op</span> op a b) <span class="fu">=</span> foldl <span class="dt">App</span> (<span class="dt">Var</span> n) args
  <span class="kw">where</span>
    args <span class="fu">=</span> map desugar [a, b]
    n <span class="fu">=</span> <span class="kw">case</span> op <span class="kw">of</span>
      <span class="dt">Add</span> <span class="ot">-&gt;</span> <span class="st">&quot;$ADD&quot;</span>
      <span class="dt">Sub</span> <span class="ot">-&gt;</span> <span class="st">&quot;$SUB&quot;</span>
      <span class="dt">Mul</span> <span class="ot">-&gt;</span> <span class="st">&quot;$MUL&quot;</span>
      <span class="dt">Eql</span> <span class="ot">-&gt;</span> <span class="st">&quot;$EQL&quot;</span>
desugar e <span class="fu">=</span> e</code></pre></div>
<p><code>desugar</code> function converts <code>let x = e in body</code> into <code>(\x -&gt; body) e</code>. <code>If</code>, <code>Fix</code> are <code>Op</code> are desugared into function applications. <code>$IF</code>, <code>$FIX</code>, <code>$ADD</code>, <code>$SUB</code>, <code>$MUL</code>, <code>$EQL</code> will be provided as primitive functions. (Note that <code>$IF</code> can be a function because we piggy back on the lazy evaluation of the host language, Haskell.)</p>
<h1 id="compilation-to-ski-combinators">Compilation to SKI combinators</h1>
<p>The next step is to compile expressions into a fixed, finite combinators. The key idea is to replace <code>Lam</code> and <code>Ap</code> constructors with Haskell’s built-in lambda and application constructs. The original interpreter of Poly is slow because it emulates beta reduction on top of Haskell, but our implementation avoids this overhead by utilizing the host system’s support for beta-reduction.</p>
<p>For example,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Lam</span> <span class="st">&quot;f&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;a&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;b&quot;</span> (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;b&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>)))</code></pre></div>
<p>is compiled to</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">CLam</span> (\f <span class="ot">-&gt;</span> <span class="dt">CLam</span> (\a <span class="ot">-&gt;</span> <span class="dt">CLam</span> (\b <span class="ot">-&gt;</span> ap (ap f b) a)))</code></pre></div>
<p>Here’s the definition of <code>CExpr</code>. You can see that <code>CLam</code> contains a Haskell function <code>CExpr -&gt; CExpr</code>. No variable in the lambda abstraction is necessary.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">CExpr</span>
  <span class="fu">=</span> <span class="dt">CVar</span> <span class="dt">Name</span>
  <span class="fu">|</span> <span class="dt">CApp</span> <span class="dt">CExpr</span> <span class="dt">CExpr</span>
  <span class="fu">|</span> <span class="dt">CLam</span> (<span class="dt">CExpr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span>)
  <span class="fu">|</span> <span class="dt">CBool</span> <span class="dt">Bool</span>
  <span class="fu">|</span> <span class="dt">CInt</span> <span class="dt">Integer</span></code></pre></div>
<p><code>compile</code> transforms a lambda calculus expression into an expression involving only <code>S</code>, <code>K</code>, <code>I</code> and constants. The SK compilation algorithm is well described in Simon Peyton Jones’s <a href="https://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/">The Implementation of Functional Programming Languages</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">compile ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span>
compile (<span class="dt">Var</span> n) <span class="fu">=</span> <span class="dt">CVar</span> n
compile (<span class="dt">App</span> fun arg) <span class="fu">=</span> <span class="dt">CApp</span> (compile fun) (compile arg)
compile (<span class="dt">Lam</span> x body) <span class="fu">=</span> abstract x (compile body)
compile (<span class="dt">Lit</span> (<span class="dt">LInt</span> k)) <span class="fu">=</span> <span class="dt">CInt</span> k
compile (<span class="dt">Lit</span> (<span class="dt">LBool</span> k)) <span class="fu">=</span> <span class="dt">CBool</span> k

<span class="ot">abstract ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span>
abstract x (<span class="dt">CApp</span> fun arg) <span class="fu">=</span> combS (abstract x fun) (abstract x arg)
abstract x (<span class="dt">CVar</span> n) <span class="fu">|</span> x <span class="fu">==</span> n <span class="fu">=</span> combI
abstract _ k <span class="fu">=</span> combK k

<span class="ot">combS ::</span> <span class="dt">CExpr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span>
combS f <span class="fu">=</span> <span class="dt">CApp</span> (<span class="dt">CApp</span> (<span class="dt">CVar</span> <span class="st">&quot;$S&quot;</span>) f)

<span class="ot">combK ::</span> <span class="dt">CExpr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span>
combK <span class="fu">=</span> <span class="dt">CApp</span> (<span class="dt">CVar</span> <span class="st">&quot;$K&quot;</span>)

<span class="ot">combI ::</span> <span class="dt">CExpr</span>
combI <span class="fu">=</span> <span class="dt">CVar</span> <span class="st">&quot;$I&quot;</span></code></pre></div>
<p>For example, <code>(\x -&gt; + x x) 5</code> is transformed as follows:</p>
<pre><code>S --&gt; S (\x -&gt; + x) (\x -&gt; x) 5
S --&gt; S (S (\x -&gt; +) (\x -&gt; x)) (\x -&gt; x) 5
I --&gt; S (S (\x -&gt; +) I) (\x -&gt; x) 5
I --&gt; S (S (\x -&gt; +) I) I 5
K --&gt; S (S (K +) I) I 5</code></pre>
<h1 id="primitives">Primitives</h1>
<p>Here’s the definition of our primitive functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">infixl</span> <span class="dv">0</span> <span class="fu">!</span>
<span class="ot">(!) ::</span> <span class="dt">CExpr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span>
(<span class="dt">CLam</span> f) <span class="fu">!</span> x <span class="fu">=</span> f x

<span class="ot">primitives ::</span> [(<span class="dt">String</span>, <span class="dt">CExpr</span>)]
primitives <span class="fu">=</span>
  [ (<span class="st">&quot;$I&quot;</span>, <span class="dt">CLam</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> x)
  , (<span class="st">&quot;$K&quot;</span>, <span class="dt">CLam</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> <span class="dt">CLam</span> <span class="fu">$</span> \_ <span class="ot">-&gt;</span> x)
  , (<span class="st">&quot;$S&quot;</span>, <span class="dt">CLam</span> <span class="fu">$</span> \f <span class="ot">-&gt;</span> <span class="dt">CLam</span> <span class="fu">$</span> \g <span class="ot">-&gt;</span> <span class="dt">CLam</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span> f<span class="fu">!</span>x<span class="fu">!</span>(g<span class="fu">!</span>x))
  , (<span class="st">&quot;$IF&quot;</span>, <span class="dt">CLam</span> <span class="fu">$</span> \(<span class="dt">CBool</span> cond) <span class="ot">-&gt;</span> <span class="dt">CLam</span> <span class="fu">$</span> \tr <span class="ot">-&gt;</span> <span class="dt">CLam</span> <span class="fu">$</span> \fl <span class="ot">-&gt;</span> <span class="kw">if</span> cond <span class="kw">then</span> tr <span class="kw">else</span> fl)
  , (<span class="st">&quot;$FIX&quot;</span>, <span class="dt">CLam</span> <span class="fu">$</span> \(<span class="dt">CLam</span> f) <span class="ot">-&gt;</span> fix f)
  , (<span class="st">&quot;$ADD&quot;</span>, arith (<span class="fu">+</span>))
  , (<span class="st">&quot;$SUB&quot;</span>, arith (<span class="fu">-</span>))
  , (<span class="st">&quot;$MUL&quot;</span>, arith (<span class="fu">*</span>))
  , (<span class="st">&quot;$EQL&quot;</span>, logical (<span class="fu">==</span>))
  ]

<span class="ot">arith ::</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">CExpr</span>
arith op <span class="fu">=</span> <span class="dt">CLam</span> <span class="fu">$</span> \(<span class="dt">CInt</span> a) <span class="ot">-&gt;</span> <span class="dt">CLam</span> <span class="fu">$</span> \(<span class="dt">CInt</span> b) <span class="ot">-&gt;</span> <span class="dt">CInt</span> (op a b)

<span class="ot">logical ::</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">CExpr</span>
logical op <span class="fu">=</span> <span class="dt">CLam</span> <span class="fu">$</span> \(<span class="dt">CInt</span> a) <span class="ot">-&gt;</span> <span class="dt">CLam</span> <span class="fu">$</span> \(<span class="dt">CInt</span> b) <span class="ot">-&gt;</span> <span class="kw">if</span> op a b <span class="kw">then</span> true <span class="kw">else</span> false

true,<span class="ot"> false ::</span> <span class="dt">CExpr</span>
true <span class="fu">=</span> <span class="dt">CBool</span> <span class="dt">True</span>
false <span class="fu">=</span> <span class="dt">CBool</span> <span class="dt">False</span></code></pre></div>
<h1 id="link">Link</h1>
<p>The final step is link our compiled program with other functions and primitives in the environment. <code>link</code> traverses the structure of <code>CExpr</code> and replaces <code>CVar</code> node with the actual function definition.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">TermEnv</span> <span class="fu">=</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">CExpr</span>

<span class="ot">emptyTmenv ::</span> <span class="dt">TermEnv</span>
emptyTmenv <span class="fu">=</span> Map.fromList primitives

<span class="ot">link ::</span> <span class="dt">TermEnv</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span>
link bs (<span class="dt">CApp</span> fun arg) <span class="fu">=</span> link bs fun <span class="fu">!</span> link bs arg
link bs (<span class="dt">CVar</span> n) <span class="fu">=</span> fromJust (Map.lookup n bs)
link _ e <span class="fu">=</span> e</code></pre></div>
<h1 id="eval">Eval</h1>
<p>Finally, <code>eval</code> is just a composition of <code>desugar</code>, <code>compile</code> and <code>link env</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eval ::</span> <span class="dt">TermEnv</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">CExpr</span>
eval env <span class="fu">=</span> link env <span class="fu">.</span> compile <span class="fu">.</span> desugar

<span class="ot">runEval ::</span> <span class="dt">TermEnv</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> (<span class="dt">CExpr</span>, <span class="dt">TermEnv</span>)
runEval env nm ex <span class="fu">=</span>
  <span class="kw">let</span> res <span class="fu">=</span> eval env ex <span class="kw">in</span>
  (res, Map.insert nm res env)</code></pre></div>
<h1 id="optimization">Optimization</h1>
<p>The basic compilation algorithm shown above tends to produce large combinator expressions. New combinators such as <code>B</code>, <code>C</code>, <code>S'</code>, <code>B'</code> and <code>C'</code> can optimize both execution speed and program size.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2016-12-30-write-you-an-interpreter.html";
    this.page.identifier = "/posts/2016-12-30-write-you-an-interpreter.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Fri, 30 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-30-write-you-an-interpreter.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Two encodings of substitution operation</title>
    <link>http://kseo.github.io//posts/2016-12-29-two-encodings-of-substitution-operation.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 29, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/substitution.html">substitution</a>
      
  </div>

<p>Substitution operations are heavily used in implementing type checkers. A substitution is a finite mappings from type variables to types. Thus it is natural to define <code>Subst</code> as a list of <code>(Name, Type)</code> pairs as in the following example.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Bifunctor</span>

<span class="kw">type</span> <span class="dt">Name</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="kw">data</span> <span class="dt">Type</span> <span class="fu">=</span> <span class="dt">TVar</span> <span class="dt">Name</span>
          <span class="fu">|</span> <span class="dt">TCon</span> <span class="dt">Name</span> [<span class="dt">Type</span>]

<span class="kw">type</span> <span class="dt">Subst</span> <span class="fu">=</span> [(<span class="dt">Name</span>, <span class="dt">Type</span>)]</code></pre></div>
<p>Composition of substitutions can be encoded as operations over the underlying association list.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">idSubst ::</span> <span class="dt">Subst</span>
idSubst <span class="fu">=</span> []

<span class="ot">composeSubst ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Subst</span>
composeSubst s1 s2 <span class="fu">=</span> map (second (applySubst s1)) s2 <span class="fu">++</span> s1</code></pre></div>
<p><code>applySubst</code> applies the substitution given over the structure of the type replacing type variables as specified.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">applySubst ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>
applySubst s (<span class="dt">TVar</span> n) <span class="fu">=</span> <span class="kw">case</span> lookup n s <span class="kw">of</span>
                          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">TVar</span> n
                          <span class="dt">Just</span> t <span class="ot">-&gt;</span> t
applySubst s (<span class="dt">TCon</span> n ts) <span class="fu">=</span> <span class="dt">TCon</span> n (map (applySubst s) ts)</code></pre></div>
<p>Martin Grabm¨uller’s <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.65.7733&amp;rep=rep1&amp;type=pdf">Algorithm W Step by Step</a> uses a slight variation of this encoding to implement Hindley-Milner type system. His version uses <code>Map Name Type</code> instead of <code>[(Name, String)]</code> for efficient lookup.</p>
<p>Alternatively, we can encode substitution operations directly as a function from type variables to types.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Subst</span> <span class="fu">=</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>

<span class="ot">idSubst ::</span> <span class="dt">Subst</span>
idSubst n <span class="fu">=</span> <span class="dt">TVar</span> n

<span class="ot">composeSubst ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Subst</span>
composeSubst s1 s2 <span class="fu">=</span> applySubst s1 <span class="fu">.</span> s2

<span class="ot">applySubst ::</span> <span class="dt">Subst</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span>
applySubst s (<span class="dt">TVar</span> n) <span class="fu">=</span> s n
applySubst s (<span class="dt">TCon</span> n ts) <span class="fu">=</span> <span class="dt">TCon</span> n (map (applySubst s) ts)</code></pre></div>
<p>Simon Peyton Jones’s <a href="https://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/">The Implementation of Functional Programming Languages</a> uses this encoding of substitution to implement the type checker.</p>
<p>These two encodings are equivalent.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2016-12-29-two-encodings-of-substitution-operation.html";
    this.page.identifier = "/posts/2016-12-29-two-encodings-of-substitution-operation.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Thu, 29 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-29-two-encodings-of-substitution-operation.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Lazy vs Strict State Monad</title>
    <link>http://kseo.github.io//posts/2016-12-28-lazy-vs-strict-state-monad.html</link>
    <description><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 28, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/state%20monad.html">state monad</a>, <a href="/tags/lazy.html">lazy</a>, <a href="/tags/strict.html">strict</a>
      
  </div>

<p><a href="https://www.stackage.org/lts-7.12/package/mtl-2.2.1">mtl</a> (or its underlying <a href="https://www.stackage.org/lts-7.12/package/transformers-0.5.2.0">transformers</a>) package provides two types of <code>State</code> monad; <code>Control.Monad.State.Strict</code> and <code>Control.Monad.State.Lazy</code>. <code>Control.Monad.State</code> re-exports <code>Control.Monad.State.Lazy</code>.</p>
<p>The difference between these two state monads does not matter in most cases, but it may cause unexpected surprises when infinite lists are involved. In this post, I am going to explain the subtle difference between lazy and strict state monads.</p>
<p>Let’s start the discussion with a simple example. The program shown below returns an infinite list of integers <code>[1..]</code> in a lazy state monad. Running the program prints <code>[1,2,3,4,5]</code> as expected.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.State.Lazy</span>

<span class="ot">foo ::</span> <span class="dt">State</span> () [<span class="dt">Int</span>]
foo <span class="fu">=</span> traverse pure [<span class="dv">1</span><span class="fu">..</span>]

main <span class="fu">=</span> print <span class="fu">$</span> take <span class="dv">5</span> (evalState foo ())</code></pre></div>
<p>However, when we replace the import with <code>Control.Monad.State.Strict</code>, the program hangs up.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.State.Strict</span>

<span class="ot">foo ::</span> <span class="dt">State</span> () [<span class="dt">Int</span>]
foo <span class="fu">=</span> traverse pure [<span class="dv">1</span><span class="fu">..</span>]

main <span class="fu">=</span> print <span class="fu">$</span> take <span class="dv">5</span> (evalState foo ())</code></pre></div>
<p>What happened here? The definition of <code>traverse</code> might give us a hint.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Traversable</span> [] <span class="kw">where</span>
  traverse f <span class="fu">=</span> List.foldr cons_f (pure [])
    <span class="kw">where</span> cons_f x ys <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> f x <span class="fu">&lt;*&gt;</span> ys</code></pre></div>
<p>From the definition of <code>traverse</code>, we can see that <code>traverse return [1..]</code> expands to</p>
<pre><code>(:) &lt;$&gt; (return 1) &lt;*&gt; ((:) &lt;$&gt; (return 2) &lt;*&gt; ((:) &lt;$&gt; (return 3) &lt;*&gt; (...)))</code></pre>
<p><code>(&lt;$&gt;)</code> and <code>(&lt;*&gt;)</code> operators are used to combine values. <code>(&lt;$&gt;)</code> are <code>(&lt;*&gt;)</code> are defined in <code>Functor</code> and <code>Applicative</code> instances of <code>State</code> monad respectively.</p>
<p>Let’s compare the definitions of these operators.</p>
<ul>
<li>Control.Monad.Trans.State.Lazy</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Functor</span> m) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span>
    fmap f m <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \ s <span class="ot">-&gt;</span>
        fmap (\ <span class="fu">~</span>(a, s&#39;) <span class="ot">-&gt;</span> (f a, s&#39;)) <span class="fu">$</span> runStateT m s

<span class="kw">instance</span> (<span class="dt">Functor</span> m, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span>
    pure a <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \ s <span class="ot">-&gt;</span> return (a, s)
    <span class="dt">StateT</span> mf <span class="fu">&lt;*&gt;</span> <span class="dt">StateT</span> mx <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \ s <span class="ot">-&gt;</span> <span class="kw">do</span>
        <span class="fu">~</span>(f, s&#39;) <span class="ot">&lt;-</span> mf s
        <span class="fu">~</span>(x, s&#39;&#39;) <span class="ot">&lt;-</span> mx s&#39;
        return (f x, s&#39;&#39;)</code></pre></div>
<ul>
<li>Control.Monad.Trans.State.Strict</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Functor</span> m) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span>
    fmap f m <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \ s <span class="ot">-&gt;</span>
        fmap (\ (a, s&#39;) <span class="ot">-&gt;</span> (f a, s&#39;)) <span class="fu">$</span> runStateT m s

<span class="kw">instance</span> (<span class="dt">Functor</span> m, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span>
    pure a <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \ s <span class="ot">-&gt;</span> return (a, s)
    <span class="dt">StateT</span> mf <span class="fu">&lt;*&gt;</span> <span class="dt">StateT</span> mx <span class="fu">=</span> <span class="dt">StateT</span> <span class="fu">$</span> \ s <span class="ot">-&gt;</span> <span class="kw">do</span>
        (f, s&#39;) <span class="ot">&lt;-</span> mf s
        (x, s&#39;&#39;) <span class="ot">&lt;-</span> mx s&#39;
        return (f x, s&#39;&#39;)</code></pre></div>
<p>The two definitions are almost the same except for a small difference in pattern matching. Did you find it? Yes, the lazy version uses a tilde <code>~</code> in pattern matching on a pair. It is a <a href="https://wiki.haskell.org/Lazy_pattern_match">lazy pattern</a> matching.</p>
<p>Here’s the secret. In the strict version, the pattern matches on the pair forces its evaluation. So <code>traverse pure [1..]</code> never returns until its evaluation is finished. The lazy version avoids this evaluation of the pair using an irrefutable pattern <code>~(a,w)</code>. Evaluation is forced later when the pair is actually needed. This is why we can manipulate infinite lists in a lazy state monad.</p>
<p>But this observation does not imply that we should always prefer the lazy version of state monad because the lazy state monad often builds up large thunks and causes space leaks due to its laziness.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2016-12-28-lazy-vs-strict-state-monad.html";
    this.page.identifier = "/posts/2016-12-28-lazy-vs-strict-state-monad.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Wed, 28 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-28-lazy-vs-strict-state-monad.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>

    </channel>
</rss>
