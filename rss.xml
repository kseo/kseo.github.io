<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Haskell for Pragmatic Programmers</title>
        <link>http://kseo.github.io/</link>
        <description><![CDATA[Kwang Yul Seo's Haskell Blog]]></description>
        <atom:link href="http://kseo.github.io//rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Thu, 15 Dec 2016 00:00:00 UT</lastBuildDate>
        <item>
    <title>Golden tests are tasty</title>
    <link>http://kseo.github.io//posts/2016-12-15-golden-tests-are-tasty.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on December 15, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/tasty.html">tasty</a>, <a href="/tags/golden.html">golden</a>, <a href="/tags/test.html">test</a>
      
  </div>

<p>Haskell programmers love property based testing thanks to glorious <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a> library. Once we specify the program behavior in terms of properties, <em>QuickCheck</em> generates random test cases and checks if the given properties hold for these test cases. Once it finds a failing test case, it automatically shrinks the test case to the minimal value which still violates the property.</p>
<p>However, we, Haskell programmers, often forget that there are other test methodologies. In this post, I am going to introduce <em>gold testing</em> provided by <a href="https://hackage.haskell.org/package/tasty-golden">tasty-golden</a> package.</p>
<p>The idea is simple. A golden test is just an <code>IO</code> action that writes its result to a file. To pass the test, this output file should be identical to the corresponding <em>golden</em> file, which contains the correct result for the test.</p>
<h1 id="a-cast-study-untyped-lambda-calculus">A cast study: untyped lambda calculus</h1>
<p>We have an <a href="https://github.com/kseo/untyped">untyped lambda calculus implementation</a>. It provides <code>run</code> function which evaluates the given lambda calculus script to a <code>String</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">run ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">String</span></code></pre></div>
<p>For testing, we would like to check if this function works correctly for various input scripts. To enumerate a few test scenarios:</p>
<ul>
<li><code>\x.x</code> evaluates to itself because there is no reduction in the term.</li>
<li><code>(\x.x)(\x.x)</code> evaluates to <code>(\x.x)</code> by substitution.</li>
<li><code>\x.y</code> throws an error because <code>y</code> is an unbound variable.</li>
</ul>
<p>Of course, we can manually create a test case for each scenario, but this is boring and repetitive. Instead of writing test cases in Haskell, let’s create a script file and its expected output file for each input:</p>
<ul>
<li><p>t1.lc</p>
<pre><code>\x.x</code></pre></li>
<li><p>t1.golden</p>
<pre><code>\x.x</code></pre></li>
<li><p>t2.lc</p>
<pre><code>(\x.x)(\x.x)</code></pre></li>
<li><p>t2.golden</p>
<pre><code>(\x.x)</code></pre></li>
<li><p>t3.lc</p>
<pre><code>(\x.y)</code></pre></li>
<li><p>t3.golden</p>
<pre><code>&quot;untyped lambda-calculus&quot; (line 2, column 1):
unexpected end of input
The variable y has not been bound</code></pre></li>
</ul>
<p>Once we have these files ready, what golden tests do is to read each script file and evaluates the script, and compares the output with the expected output contained in the expected file. If the actual output and the expected output are different, the test fails. We call the expected output file as the <em>golden file</em>.</p>
<p>For convenience, tasty-golden generates the golden files if they are not available. So you don’t need to create golden files initially. You also can regenerate the golden files using the <code>--accept</code> flag. This is useful when you know that your change is valid and want to rebase all the golden files accordingly.</p>
<h1 id="implementation">Implementation</h1>
<p>Here’s the actual code which performs golden tests as described above. <code>listTestFiles</code> enumerates all the script files under <code>test/tests</code> directory and <code>mkGoldenTest</code> creates a golden test from the script file using <code>goldenVsString</code> function provided by tasty-golden.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Language.LambdaCalculus</span>

<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">as</span> <span class="dt">BS</span>
<span class="kw">import </span><span class="dt">System.FilePath</span>
<span class="kw">import </span><span class="dt">System.FilePath.Glob</span>

<span class="kw">import </span><span class="dt">Test.Tasty</span>
<span class="kw">import </span><span class="dt">Test.Tasty.Golden</span> <span class="kw">as</span> <span class="dt">G</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  paths <span class="ot">&lt;-</span> listTestFiles
  goldens <span class="ot">&lt;-</span> mapM mkGoldenTest paths
  defaultMain (testGroup <span class="st">&quot;Tests&quot;</span> goldens)

<span class="ot">listTestFiles ::</span> <span class="dt">IO</span> [FilePath]
listTestFiles <span class="fu">=</span> globDir1 pat <span class="st">&quot;test/tests&quot;</span>
  <span class="kw">where</span> pat <span class="fu">=</span> compile <span class="st">&quot;*.lc&quot;</span>

<span class="ot">mkGoldenTest ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">TestTree</span>
mkGoldenTest path <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> testName <span class="fu">=</span> takeBaseName path
  <span class="kw">let</span> goldenPath <span class="fu">=</span> replaceExtension path <span class="st">&quot;.golden&quot;</span>
  return (goldenVsString testName goldenPath action)
  <span class="kw">where</span>
<span class="ot">    action ::</span> <span class="dt">IO</span> <span class="dt">BS.ByteString</span>
    action <span class="fu">=</span> <span class="kw">do</span>
      script <span class="ot">&lt;-</span> readFile path
      <span class="kw">let</span> actual <span class="fu">=</span> either id id (run script)
      return (BS.pack actual)</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Thu, 15 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-15-golden-tests-are-tasty.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>How QuickCheck generates random functions</title>
    <link>http://kseo.github.io//posts/2016-12-14-how-quick-check-generate-random-functions.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on December 14, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/QuickCheck.html">QuickCheck</a>, <a href="/tags/test.html">test</a>
      
  </div>

<p>In <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a>, test data is produced by <em>test generators</em> whose types are of the form <code>Gen a</code>. <code>Gen a</code> is a generator for values of type <code>a</code>. A type can define a default test data generator by defining an instance of the class <code>Arbitrary</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Arbitrary</span> a <span class="kw">where</span>
<span class="ot">  arbitrary   ::</span> <span class="dt">Gen</span> a
  <span class="fu">...</span></code></pre></div>
<p>We can define instances of <code>Arbitrary</code> using the combinators provided by <em>QuickCheck</em>. For example, the instances of <code>Bool</code> and <code>Ordering</code> are defined using <code>choose</code> and <code>elements</code> respectively. <code>choose</code> generates a random element in the given inclusive range and <code>elements xs</code> generates an arbitrary element of the list <code>xs</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Bool</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span> choose (<span class="dt">False</span>,<span class="dt">True</span>)
  shrink <span class="dt">True</span> <span class="fu">=</span> [<span class="dt">False</span>]
  shrink <span class="dt">False</span> <span class="fu">=</span> []

<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Ordering</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span> elements [<span class="dt">LT</span>, <span class="dt">EQ</span>, <span class="dt">GT</span>]
  shrink <span class="dt">GT</span> <span class="fu">=</span> [<span class="dt">EQ</span>, <span class="dt">LT</span>]
  shrink <span class="dt">LT</span> <span class="fu">=</span> [<span class="dt">EQ</span>]
  shrink <span class="dt">EQ</span> <span class="fu">=</span> []</code></pre></div>
<p>Simple and easy! But how about a function? Can we generate a function in the same way? The answer is surprisingly yes, but you need another type class named <code>CoArbitrary</code>.</p>
<p>Before explaining how <code>CoArbitrary</code> works, we need to check how <code>Gen</code> is defined:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | A generator for values of type @a@.</span>
<span class="kw">newtype</span> <span class="dt">Gen</span> a <span class="fu">=</span> <span class="dt">MkGen</span>{
<span class="ot">  unGen ::</span> <span class="dt">QCGen</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="co">-- ^ Run the generator on a particular seed.</span>
                             <span class="co">-- If you just want to get a random value out, consider using &#39;generate&#39;.</span>
  }</code></pre></div>
<p>Internally, <code>Gen a</code> is a function which takes 2 arguments (<code>QCGen</code> and <code>Int</code>) and returns <code>a</code>. Here <code>QCGen</code> is a newtype wrapper around either <code>StdGen</code> or <code>TFGen</code>.</p>
<p>So <code>Gen (a -&gt; b)</code> expands to <code>QCGen -&gt; Int -&gt; a -&gt; b</code>. By reordering parameters, this is equivalent to <code>a -&gt; Int -&gt; QCGen -&gt; b</code>, which represents <code>a -&gt; Gen b</code>. Thus by defining</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">promote ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Gen</span> b) <span class="ot">-&gt;</span> <span class="dt">Gen</span> (a<span class="ot">-&gt;</span>b)</code></pre></div>
<p>we can produce a generator for a <em>function type</em>, provided that we can construct a generator for the <em>result type</em> which somehow depends on the argument value.</p>
<p>So we need <code>coarbitrary</code> which modifies a generator in a way depending on its first parameter.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">CoArbitrary</span> a <span class="kw">where</span>
<span class="ot">  coarbitrary ::</span> a <span class="ot">-&gt;</span> <span class="dt">Gen</span> b <span class="ot">-&gt;</span> <span class="dt">Gen</span> b</code></pre></div>
<p>To actually define an instance of <code>CoArbitrary</code>, we need a helper function <code>variant</code>, which perturbs the generator. It creates a new generator that produces different pseudo-random results than the original.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Modifies a generator using an integer seed.</span>
<span class="ot">variant ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</code></pre></div>
<p>Now we can define instances of <code>CoArbitrary</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">CoArbitrary</span> <span class="dt">Bool</span> <span class="kw">where</span>
  coarbitrary <span class="dt">False</span> <span class="fu">=</span> variant <span class="dv">0</span>
  coarbitrary <span class="dt">True</span> <span class="fu">=</span> variant <span class="dv">1</span>

<span class="kw">instance</span> <span class="dt">CoArbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">CoArbitrary</span> (<span class="dt">Maybe</span> a) <span class="kw">where</span>
  coarbitrary <span class="dt">Nothing</span>  <span class="fu">=</span> variant <span class="dv">0</span>
  coarbitrary (<span class="dt">Just</span> x) <span class="fu">=</span> variant <span class="dv">1</span> <span class="fu">.</span> coarbitrary x</code></pre></div>
<p>With all the pieces in place, we can finally define an <code>Arbitrary</code> for the function type <code>a -&gt; b</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Coarbitrary</span> a, <span class="dt">Arbitrary</span> b) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (a <span class="ot">-&gt;</span> b) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> promote (\a <span class="ot">-&gt;</span> coarbitrary a arbitrary)</code></pre></div>
<p>To see how this works:</p>
<ol style="list-style-type: decimal">
<li><code>\a -&gt; coarbitrary a arbitrary</code> has type <code>a -&gt; Gen b</code></li>
<li><code>promote</code> has type <code>(a -&gt; Gen b) -&gt; Gen (a-&gt;b)</code></li>
<li>So, the entire expression has type <code>Gen (a-&gt;b)</code></li>
</ol>
<p>The current implementation of <em>QuickCheck</em> is a bit different as it is generalized to <code>Monad</code>, but When <code>m</code> is the function instance of <code>Monad</code>, <code>promote</code> is the same as we derived here.</p>
<pre><code>promote :: Monad m =&gt; m (Gen a) -&gt; Gen (m a)</code></pre>
<h1 id="references">References</h1>
<ul>
<li><a href="http://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf">QuickCheck: A Lightweight Tool for Random Testing of Haskell Programs</a> by Koen Claessen and John Hughes</li>
<li><a href="http://stackoverflow.com/a/16220336/2028189">StackOverflow: How to generate random, typed functions</a></li>
</ul>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Wed, 14 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-14-how-quick-check-generate-random-functions.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Scott encoding of Algebraic Data Types</title>
    <link>http://kseo.github.io//posts/2016-12-13-scott-encoding.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on December 13, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/scott%20encoding.html">scott encoding</a>, <a href="/tags/algebraic%20data%20type.html">algebraic data type</a>
      
  </div>

<p>This article is written in literate Haskell.</p>
<p>It is well known that algebraic data types can be encoded in a functional programming language by higher order functions. The Church encoding is the most famous one, but there is a lesser known encoding, called Scott encoding. The Scott encoding is generally considered as <a href="https://ifl2014.github.io/submissions/ifl2014_submission_13.pdf">better</a>.</p>
<p>In this article, I will show you some examples of Scott-encoded algebraic data types. Here I will use named functions intead of anonymous functions because the named function makes the notation of recursive algorithms easier.</p>
<p>Before move on, we need to turn on GHC extension <code>RankNTypes</code>. If you want to know how Rank-N types are related to the Scott encoding, see <a href="https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html">24 Days of GHC Extensions: Rank N Types</a>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE RankNTypes #-}</span></code></pre></div>
<h1 id="pair">Pair</h1>
<p><code>Pair</code> is a simplest example of a container type. Because it is a non-recursive type, the Church and Scott encoding overlap in this case. This is the standard encoding used for pairs in λ-calculus courses.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">PairS</span> a b <span class="fu">=</span> <span class="dt">PairS</span> {<span class="ot"> unpairS ::</span> forall r<span class="fu">.</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r }</code></pre></div>
<p>Containers can be expressed by using closures (partial applications). <code>pairS</code> takes 3 arguments. We have a closure by applying only 2 arguments.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; pairS ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">PairS</span> a b
<span class="ot">&gt;</span> pairS a b <span class="fu">=</span> <span class="dt">PairS</span> (\p <span class="ot">-&gt;</span> p a b)</code></pre></div>
<p>Now it is time to define selection functions. <code>fstS</code> and <code>sndS</code> are implemented by passing a continuation (the function in which the continuation continues). It is a 2 argument function which returns either the first or the second argument. <code>fstS</code> returns the first argument and <code>sndS</code> returns the second argument.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fstS ::</span> <span class="dt">PairS</span> a b <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> fstS (<span class="dt">PairS</span> p) <span class="fu">=</span> p (\x _ <span class="ot">-&gt;</span> x)
<span class="ot">&gt;</span> 
<span class="ot">&gt; sndS ::</span> <span class="dt">PairS</span> a b <span class="ot">-&gt;</span> b
<span class="ot">&gt;</span> sndS (<span class="dt">PairS</span> p) <span class="fu">=</span> p (\_ y <span class="ot">-&gt;</span> y)</code></pre></div>
<p>Other functions such as <code>swapS</code> can be implemented in terms of <code>pairS</code>, <code>fstS</code> and <code>sndS</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; swapS ::</span> <span class="dt">PairS</span> a b <span class="ot">-&gt;</span> <span class="dt">PairS</span> b a
<span class="ot">&gt;</span> swapS p <span class="fu">=</span> pairS (sndS p) (fstS p)</code></pre></div>
<h1 id="peano-numbers">Peano numbers</h1>
<p><code>NumS</code> is the simplest recursive data type which represents Peano numbers.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">NumS</span> <span class="fu">=</span> <span class="dt">NumS</span> {<span class="ot"> unnumS ::</span> forall r<span class="fu">.</span> (<span class="dt">NumS</span> <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r }</code></pre></div>
<p><code>NumS</code> has two constructors. <code>zeroS</code> is the non recursive constructor that represents the value zero. <code>succS</code> is the recursive constructor which yields the successor of such a Peano number.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; zeroS ::</span> <span class="dt">NumS</span>
<span class="ot">&gt;</span> zeroS <span class="fu">=</span> <span class="dt">NumS</span> (\s z <span class="ot">-&gt;</span> z)
<span class="ot">&gt;</span> 
<span class="ot">&gt; succS ::</span> <span class="dt">NumS</span> <span class="ot">-&gt;</span> <span class="dt">NumS</span>
<span class="ot">&gt;</span> succS n <span class="fu">=</span> <span class="dt">NumS</span> (\s z <span class="ot">-&gt;</span> s n)</code></pre></div>
<p><code>unnumS</code> is the deconstructor which takes 2 continuations and a <code>NumS</code>. The continuations determine what we reduce the <code>NumS</code> into depending on which constructor is found.</p>
<p>For convinence, <code>unnumS'</code> is defined to have the <code>NumS</code> argument be the last arugment to the <code>unnumS</code> function.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; unnumS&#39; ::</span> (<span class="dt">NumS</span> <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> <span class="dt">NumS</span> <span class="ot">-&gt;</span> r
<span class="ot">&gt;</span> unnumS&#39; s z (<span class="dt">NumS</span> f) <span class="fu">=</span> f s z</code></pre></div>
<p>When we find the num is a successor, then we know that the num is not empty, so we reduce it to <code>False</code>. When we find it is the zero, we reduce it to <code>True</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; isZero ::</span> <span class="dt">NumS</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> isZero <span class="fu">=</span> unnumS&#39; (\_ <span class="ot">-&gt;</span> <span class="dt">False</span>) <span class="dt">True</span></code></pre></div>
<p><code>addS</code> is slightly more complex, but it can also be defined using the same techinque. You can recognize that it is a pattern mathcing in disguse.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; addS ::</span> <span class="dt">NumS</span> <span class="ot">-&gt;</span> <span class="dt">NumS</span> <span class="ot">-&gt;</span> <span class="dt">NumS</span>
<span class="ot">&gt;</span> addS n m <span class="fu">=</span>
<span class="ot">&gt;</span>     unnumS&#39; (\s <span class="ot">-&gt;</span> succS (addS s m))
<span class="ot">&gt;</span>             m n</code></pre></div>
<h1 id="list">List</h1>
<p>We can apply the same transformation to <code>ListS</code> type.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">ListS</span> a <span class="fu">=</span>
<span class="ot">&gt;</span>    <span class="dt">ListS</span> {
<span class="ot">&gt;      unconsS ::</span> forall r<span class="fu">.</span> (a <span class="ot">-&gt;</span> <span class="dt">ListS</span> a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r
<span class="ot">&gt;</span>    }
<span class="ot">&gt;</span> 
<span class="ot">&gt; nilS ::</span> <span class="dt">ListS</span> a
<span class="ot">&gt;</span> nilS <span class="fu">=</span> <span class="dt">ListS</span> (\co ni <span class="ot">-&gt;</span> ni)
<span class="ot">&gt;</span> 
<span class="ot">&gt; consS ::</span> a <span class="ot">-&gt;</span> <span class="dt">ListS</span> a <span class="ot">-&gt;</span> <span class="dt">ListS</span> a
<span class="ot">&gt;</span> consS x xs <span class="fu">=</span> <span class="dt">ListS</span> (\co ni <span class="ot">-&gt;</span> co x xs)
<span class="ot">&gt;</span> 
<span class="ot">&gt; unconsS&#39; ::</span> (a <span class="ot">-&gt;</span> <span class="dt">ListS</span> a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> <span class="dt">ListS</span> a <span class="ot">-&gt;</span> r
<span class="ot">&gt;</span> unconsS&#39; co ni (<span class="dt">ListS</span> f) <span class="fu">=</span> f co ni
<span class="ot">&gt;</span> 
<span class="ot">&gt; isNullS ::</span> <span class="dt">ListS</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> isNullS <span class="fu">=</span> unconsS&#39; (\_ _ <span class="ot">-&gt;</span> <span class="dt">False</span>) <span class="dt">True</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; mapS ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">ListS</span> a <span class="ot">-&gt;</span> <span class="dt">ListS</span> b
<span class="ot">&gt;</span> mapS f <span class="fu">=</span>
<span class="ot">&gt;</span>   unconsS&#39; (\x xs <span class="ot">-&gt;</span> consS (f x) (mapS f xs))
<span class="ot">&gt;</span>            nilS</code></pre></div>
<h1 id="references">References</h1>
<p>Interested readers might like to take a look at the following papers for more information:</p>
<ul>
<li><a href="http://www.nlda-tw.nl/janmartin/papers/jmjansenLambdapaper.pdf">Comprehensive Encoding of Data Types and Algorithms in the λ-Calculus (Functional Pearl)</a> by JAN MARTIN JANSEN</li>
<li><a href="https://ifl2014.github.io/submissions/ifl2014_submission_13.pdf">Church Encoding of Data Types Considered Harmful for Implementations (Functional Pearl)</a> by Pieter Koopman, Rinus Plasmeijer and Jan Martin Jansen</li>
</ul>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Tue, 13 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-13-scott-encoding.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>unfold and fold</title>
    <link>http://kseo.github.io//posts/2016-12-12-unfold-and-fold.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on December 12, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/unfold.html">unfold</a>, <a href="/tags/fold.html">fold</a>, <a href="/tags/category%20theory.html">category theory</a>
      
  </div>

<h1 id="unfold">unfold</h1>
<p>Every functional programmer loves <em>fold</em>. fold is <a href="http://www.cs.nott.ac.uk/~pszgmh/fold.pdf">universal and expressive</a>. But <em>fold</em> has a secret twin brother named <em>unfold</em> which undoes what <em>fold</em> does. In this post, we will see what <em>unfold</em> is and how it is related to <em>fold</em>.</p>
<p><code>unfoldr</code> builds a list from a seed value while <code>foldr</code> reduces a list to a summary value.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unfoldr ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, b)) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a]</code></pre></div>
<p><code>unfoldr</code> takes the element and returns <code>Nothing</code> if it is done producing the list or returns <code>Just (a, b)</code>, in which case, <code>a</code> is a prepended to the list and <code>b</code> is used as the next element in a recursive call.</p>
<p>For example, we can define <code>iterate</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">iterate f <span class="fu">==</span> unfoldr (\x <span class="ot">-&gt;</span> <span class="dt">Just</span> (x, f x))</code></pre></div>
<p>Another simple use of <code>unfoldr</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> unfoldr (\b <span class="ot">-&gt;</span> <span class="kw">if</span> b <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Nothing</span> <span class="kw">else</span> <span class="dt">Just</span> (b, b<span class="fu">-</span><span class="dv">1</span>)) <span class="dv">10</span>
[<span class="dv">10</span>,<span class="dv">9</span>,<span class="dv">8</span>,<span class="dv">7</span>,<span class="dv">6</span>,<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]</code></pre></div>
<p>As the name suggests, <em>unfold</em> is the categorical dual of <em>fold</em>. (Maybe it should be <em>cofold</em> instead of <em>unfold</em>.) It means we can get the signature of <code>foldr</code> by reversing the arrows of <code>unfoldr</code>, and vice versa.</p>
<p>Let’s try this.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unfoldr ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, b)) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> [a])
foldr<span class="ot">   ::</span> (<span class="dt">Maybe</span> (a, b) <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> ([a] <span class="ot">-&gt;</span> b)</code></pre></div>
<p>Oops! It is not our beloved <code>foldr</code> function whose signature is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</code></pre></div>
<h1 id="type-isomorphisms">Type isomorphisms</h1>
<p>But don’t be disappointed! We can show that they represent the same thing by using type isomorphisms:</p>
<pre><code>(a → b → b) → b → ([a] → b)</code></pre>
<blockquote>
<p>by a -&gt; b -&gt; c ~= (a, b) -&gt; c</p>
</blockquote>
<pre><code>((a, b) → b) → b → ([a] → b)</code></pre>
<blockquote>
<p>by a ~= () -&gt; a</p>
</blockquote>
<pre><code>((a, b) → b) → (() -&gt; b) → ([a] → b)</code></pre>
<blockquote>
<p>by a -&gt; b -&gt; c ~= (a, b) -&gt; c</p>
</blockquote>
<pre><code>(((a, b) → b), (() -&gt; b)) → ([a] → b)</code></pre>
<blockquote>
<p>by ((a -&gt; c), (b -&gt; c)) ~= Either a b -&gt; c</p>
</blockquote>
<pre><code>((Either (a, b) ()) → b) → ([a] → b)</code></pre>
<blockquote>
<p>by Either a () ~= Maybe a</p>
</blockquote>
<pre><code>(Maybe (a, b) -&gt; b) → ([a] → b)</code></pre>
<p>Now we can clearly see that <em>unfold</em> is the dual of <em>fold</em>. If you want to learn more on the relationship between <em>fold</em> and <em>unfold</em>, see Conal Elliott’s <a href="http://conal.net/talks/folds-and-unfolds.pdf">Folds and unfolds all around us</a>.</p>
<h1 id="implementation">Implementation</h1>
<p>Here’s an implementation of <code>unfoldr</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unfoldr ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, b)) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> [a])
unfoldr f b <span class="fu">=</span> <span class="kw">case</span> f b <span class="kw">of</span>
                <span class="dt">Just</span> (a, b&#39;) <span class="ot">-&gt;</span> a <span class="fu">:</span> unfoldr f b&#39;
                <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Mon, 12 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-12-unfold-and-fold.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>How to read arrow combinators</title>
    <link>http://kseo.github.io//posts/2016-12-11-how-to-read-arrow-combinators.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on December 11, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Arrow.html">Arrow</a>
      
  </div>

<p>Arrows, like monads and applicative functors, express computations that happen within a context. In Haskell, arrows are represented with a constructor class <code>Arrow</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Arrow</span> a <span class="kw">where</span>
<span class="ot">  arr ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a b c
  <span class="co">-- Each function may be treated as a computation.</span>

<span class="ot">  (&gt;&gt;&gt;) ::</span> a b c <span class="ot">-&gt;</span> a c d <span class="ot">-&gt;</span> a b d
  <span class="co">-- Computations may be composed, by connecting the output of the first to the input of the second.</span>

<span class="ot">  first ::</span> a b c <span class="ot">-&gt;</span> a (b,d) (c,d)
  <span class="co">-- A computation may be applied to part of the input, with the rest copied through to the output.</span>
  <span class="fu">...</span></code></pre></div>
<p>As usual, it takes some time to comprehend what arrow is and why and how it is useful. If you are looking for a good arrow tutorial, I strongly recommend John Hughes’s <a href="http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf">Programming with Arrows</a>.</p>
<p>However, it is not necessary to understand arrow just to read some code written with arrow combinators because arrows are often used even when there is no compelling reason to do so. <code>(-&gt;)</code> is an instance of <code>Arrow</code> and some Haskell programmers just prefer arrow style even though combinators of <code>Data.Bifunctor</code> are often more readable.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Arrow</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span>
    arr f <span class="fu">=</span> f
    (<span class="fu">***</span>) f g <span class="fu">~</span>(x,y) <span class="fu">=</span> (f x, g y)</code></pre></div>
<p>So here is my tip. If you encounter code written with arrow combinators in the context of <code>(-&gt;)</code>, use the following <a href="https://en.wikibooks.org/wiki/Haskell/Understanding_arrows#Arrow_combinators_crop_up_in_unexpected_places">translation table</a> to decode what the code means.</p>
<table>
<thead>
<tr class="header">
<th>Combinator</th>
<th>Meaning</th>
<th>Alternatives</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>(&gt;&gt;&gt;)</td>
<td>flip (.)</td>
<td></td>
</tr>
<tr class="even">
<td>first</td>
<td>(x, y) -&gt; (f x, y)</td>
<td>first (Data.Bifunctor)</td>
</tr>
<tr class="odd">
<td>second</td>
<td>(x, y) -&gt; (x, f y)</td>
<td>second (Data.Bifunctor)</td>
</tr>
<tr class="even">
<td>(***)</td>
<td>g (x, y) -&gt; (f x, g y)</td>
<td>bimap (Data.Bifunctor)</td>
</tr>
<tr class="odd">
<td>(&amp;&amp;&amp;)</td>
<td>g x -&gt; (f x, g x)</td>
<td>liftA2 (,) (Control.Applicative)</td>
</tr>
<tr class="even">
<td>left</td>
<td>Maps over Left case</td>
<td>first (Data.Bifunctor)</td>
</tr>
<tr class="odd">
<td>right</td>
<td>Maps over Right case</td>
<td>second (Data.Bifunctor)</td>
</tr>
<tr class="even">
<td>(+++)</td>
<td>Maps over both cases</td>
<td>bimap (Data.Bifunctor)</td>
</tr>
<tr class="odd">
<td>(|||)</td>
<td>Eliminates Either</td>
<td>either (Data.Either)</td>
</tr>
<tr class="even">
<td>app</td>
<td>(f, x) -&gt; f x</td>
<td>uncurry ($)</td>
</tr>
</tbody>
</table>
<p>In case of <code>second</code> and <code>right</code>, we can also use <code>fmap</code> because both <code>(,)</code> and <code>Either</code> is functorial on the second type. But I personally don’t recommend <code>fmap</code> in this case because these types arbitrarily map the second type instead of the first one.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Sun, 11 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-11-how-to-read-arrow-combinators.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Encodings of lens</title>
    <link>http://kseo.github.io//posts/2016-12-10-encodings-of-lense.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on December 10, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Lens.html">Lens</a>
      
  </div>

<p>There are variety of libraries offering lens on the hackage. These include <a href="https://hackage.haskell.org/package/data-accessor">data-accessor</a>, <a href="https://hackage.haskell.org/package/fclabels">fclabels</a>, <a href="https://hackage.haskell.org/package/lenses">lenses</a>, <a href="https://hackage.haskell.org/package/data-lens">data-lens</a> and <a href="https://www.stackage.org/haddock/lts-7.12/lens-4.14/Control-Lens.html">lens</a>. Though they represent the same idea, their encodings of lens are not compatible. This article is an attempt to understand various encodings used to represent the idea of lens.</p>
<h1 id="lens-as-a-getter-and-a-setter">Lens as a getter and a setter</h1>
<p>The most intuitive way to encode lens is to represent it as a collection of a <em>getter</em> and a <em>setter</em>. <code>Lens s a</code> represents a <em>focus</em> to an <code>a</code> inside an <code>s</code> structure.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Lens</span> s a <span class="fu">=</span> <span class="dt">Lens</span>
  {<span class="ot"> get ::</span> s <span class="ot">-&gt;</span> a
  ,<span class="ot"> set ::</span> a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
  }</code></pre></div>
<p>We can define a lens to the first element of a pair as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fstL ::</span> <span class="dt">Lens</span> (a,b) a
fstL <span class="fu">=</span> <span class="dt">Lens</span> {
    get <span class="fu">=</span> \(x,y) <span class="ot">-&gt;</span> x
  , set <span class="fu">=</span> \x (_,y) <span class="ot">-&gt;</span> (x,y)
  }</code></pre></div>
<p>Similarly, we can define <code>snd</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sndL ::</span> <span class="dt">Lens</span> (a,b) b
sndL <span class="fu">=</span> <span class="dt">Lens</span> {
    get <span class="fu">=</span> \(x,y) <span class="ot">-&gt;</span> y
  , set <span class="fu">=</span> \y (x,_) <span class="ot">-&gt;</span> (x,y)
  }</code></pre></div>
<p>Having defined this, it is easy to access and modify a pair:</p>
<pre><code>&gt; get fstL (1,2)
1
&gt; set fstL 3 (1,2)
(3,2)</code></pre>
<p>We can also implement <code>update</code> in terms of <code>get</code> and <code>set</code> by getting the value, applying a function and setting it again.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">update ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
update l f s <span class="fu">=</span> set l (f (get l s)) s</code></pre></div>
<p>This <code>update</code> function works fine for a small data structure such as pairs, but becomes expensive for large data structures as it needs to visit all the way down to the <em>focus</em> twice every time it updates.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> update fstL (<span class="fu">+</span><span class="dv">1</span>) (<span class="dv">1</span>,<span class="dv">2</span>)
(<span class="dv">2</span>,<span class="dv">2</span>)</code></pre></div>
<p>Lenses are composable with <code>compose</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">compose ::</span> <span class="dt">Lens</span> b c <span class="ot">-&gt;</span> <span class="dt">Lens</span> a b <span class="ot">-&gt;</span> <span class="dt">Lens</span> a c
compose bc ab <span class="fu">=</span> <span class="dt">Lens</span>
  { get <span class="fu">=</span> get bc <span class="fu">.</span> get ab
  , set <span class="fu">=</span> update ab <span class="fu">.</span> set bc
  }</code></pre></div>
<p>We can now modify nested pairs:</p>
<pre><code>&gt; update (sndL `compose` fstL) (*2) ((3,4),5)
((3,8),5)</code></pre>
<h1 id="lens-as-a-getter-and-an-updater">Lens as a getter and an updater</h1>
<p>A slight variation to the previous lens encoding is to represent a lens with a <em>getter</em> and an <em>updater</em> instead of a <em>getter</em> and a <em>setter</em>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Lens</span> s a <span class="fu">=</span> <span class="dt">Lens</span>
  {<span class="ot"> get ::</span> s <span class="ot">-&gt;</span> a
  ,<span class="ot"> update ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
  }</code></pre></div>
<p>The performance of this encoding is better than the previous one because we no longer need to visit the <em>focus</em> twice for an single update. <code>fstL</code> and <code>sndL</code> directly implement <code>update</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fstL ::</span> <span class="dt">Lens</span> (a,b) a
fstL <span class="fu">=</span> <span class="dt">Lens</span> {
    get <span class="fu">=</span> \(x,y) <span class="ot">-&gt;</span> x
  , update <span class="fu">=</span> \f (x,y) <span class="ot">-&gt;</span> (f x,y)
  }

<span class="ot">sndL ::</span> <span class="dt">Lens</span> (a,b) b
sndL <span class="fu">=</span> <span class="dt">Lens</span> {
    get <span class="fu">=</span> \(x,y) <span class="ot">-&gt;</span> y
  , update <span class="fu">=</span> \f (x,y) <span class="ot">-&gt;</span> (x, f y)
  }</code></pre></div>
<p>But what about <code>set</code>? We can easily define <code>set</code> in terms of <code>update</code> using <code>const</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">set ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
set l a s <span class="fu">=</span> update l (const a) s</code></pre></div>
<p>Composition of two lenses are similarly defined:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">compose ::</span> <span class="dt">Lens</span> b c <span class="ot">-&gt;</span> <span class="dt">Lens</span> a b <span class="ot">-&gt;</span> <span class="dt">Lens</span> a c
compose bc ab <span class="fu">=</span> <span class="dt">Lens</span>
  { get <span class="fu">=</span> get bc <span class="fu">.</span> get ab
  , update <span class="fu">=</span> update ab <span class="fu">.</span> update bc
  }</code></pre></div>
<h1 id="cps-based-lens-aka-van-laarhoven-lens">CPS based lens (aka van Laarhoven lens)</h1>
<p>This encoding is called <em>a CPS based lens</em> as the type looks like a continuation passing style function, which would be <code>(b -&gt; r) -&gt; (a -&gt; r)</code> though the return type is <code>f a</code> instead of any <code>r</code>. It is also called <a href="http://www.twanvl.nl/blog/haskell/cps-functional-references">van Laarhoven lens</a> named after <strong>Twan van Laarhoven</strong> who first discovered this encoding.</p>
<p>This is the most popular lens encoding as it is used by the famous Edward Kmett’s <a href="https://www.stackage.org/haddock/lts-7.12/lens-4.14/Control-Lens.html">lens</a> library.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE Rank2Types #-}</span>

<span class="kw">type</span> <span class="dt">Lens</span> s a <span class="fu">=</span> forall f<span class="fu">.</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> f s)</code></pre></div>
<p>It is hard to understand the type at first sight. There are no longer identifiable setter or getter in the type signature. Instead, we have a functor <code>f</code> in the signature.</p>
<p>As expected from the clue, we can derive <code>get</code> and <code>update</code> by applying different functors to the type.</p>
<p>First, we derive <code>get</code> by applying <code>Const</code> functor:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Applicative</span>

<span class="ot">get ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a
get l <span class="fu">=</span> getConst <span class="fu">.</span> l <span class="dt">Const</span></code></pre></div>
<p>Also we can derive <code>update</code> by applying <code>Identity</code> functor:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Identity</span>

<span class="ot">update ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
update l m <span class="fu">=</span> runIdentity <span class="fu">.</span> l (<span class="dt">Identity</span> <span class="fu">.</span> m)</code></pre></div>
<p><code>set</code> function can be implemented in terms of <code>get</code> and <code>update</code> as usual:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">set ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
set l b a <span class="fu">=</span> update l (const b) a</code></pre></div>
<p>Fortunately, defining a lens in var Laarhoven lens encoding is not hard. For example, we can define <code>fstL</code> using <code>fmap</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fstL ::</span> <span class="dt">Lens</span> (a,b) a
fstL f (x,y) <span class="fu">=</span> fmap (\a <span class="ot">-&gt;</span> (a, y)) (f x)</code></pre></div>
<p>Or we can define <code>sndL</code> more succinctly using <code>TupleSections</code> and <code>(&lt;$&gt;)</code> operator:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sndL ::</span> <span class="dt">Lens</span> (a,b) b
sndL x (a,b) <span class="fu">=</span> (a,) <span class="fu">&lt;$&gt;</span> x b</code></pre></div>
<p>As this job of defining a lens is so mechanical, lens library provides a <a href="https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-TH.html#v:makeLenses">TemplateHaskell macro</a> to generate lenses from a record.</p>
<p>Let’s see how <code>get</code> works by actually evaluating <code>get fstL (1,2)</code>:</p>
<pre><code>get fstL (1,2)
=&gt; getConst . (fstL Const) (1,2)
=&gt; getConst . (\x (a,b) -&gt; (,b) &lt;$&gt; x a) (1,2)
=&gt; getConst . (\(a,b) -&gt; (,b) &lt;$&gt; Const a) (1,2)
=&gt; getConst . ((,2) &lt;$&gt; Const 1)
=&gt; getConst . (Const 1)
=&gt; 1</code></pre>
<p>One particularly nice property of var Laarhoven lens is that composition of two lens is just the function composition operator <code>(.)</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">compose ::</span> <span class="dt">Lens</span> b c <span class="ot">-&gt;</span> <span class="dt">Lens</span> a b <span class="ot">-&gt;</span> <span class="dt">Lens</span> a c
compose r s <span class="fu">=</span> s <span class="fu">.</span> r</code></pre></div>
<p>So we can simply use the <code>(.)</code> to compose two lenses instead of custom <code>compose</code> function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> update (fstL <span class="fu">.</span> sndL) (<span class="fu">*</span><span class="dv">2</span>) ((<span class="dv">3</span>,<span class="dv">4</span>),<span class="dv">5</span>)
((<span class="dv">3</span>,<span class="dv">8</span>),<span class="dv">5</span>)</code></pre></div>
<p>However, the order of composition is reversed due to the nature of CPS based encoding. This is a bit confusing at first, but it makes sense when we think of it as a property referencing in an OO language.</p>
<pre><code>pair.(fstL.sndL) *= 2</code></pre>
<p>This style of composition is also possible with previous two encodings if we use Haskell’s type classes to overload <code>(.)</code> and <code>id</code> as described in <a href="http://www.twanvl.nl/blog/haskell/overloading-functional-references">Overloading functional references</a>. But van Laarhoven lens is still simpler as we don’t need to hide the <code>(.)</code> operator of the <code>Prelude</code>.</p>
<h1 id="isomorphism-lens">Isomorphism lens</h1>
<p>There is a yet another encoding of lens called <a href="http://www.twanvl.nl/blog/haskell/isomorphism-lenses">Isomorphism lens</a> which was also discovered by van Laarhoven.</p>
<blockquote>
<p>A lens from type s to a is a bijection between s and a pair of a and some residual r.</p>
</blockquote>
<p>To put it more succinctly,</p>
<pre><code>type Lens s a = exists r. s &lt;-&gt; (a,r)</code></pre>
<p>Because Haskell has no <code>exists</code> keyword, we can represent the encoding with a <code>newtype</code> wrapper:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE Rank2Types #-}</span>
<span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span>

<span class="co">-- Isomorphisms/bijections between type @a@ and @b@</span>
<span class="kw">data</span> <span class="dt">Iso</span> a b <span class="fu">=</span> <span class="dt">Iso</span> {<span class="ot"> fw ::</span> a <span class="ot">-&gt;</span> b,<span class="ot"> bw ::</span> b <span class="ot">-&gt;</span> a }

<span class="co">-- Lenses with a data wrapper, in practice you might want to unpack the Iso type</span>
<span class="kw">data</span> <span class="dt">Lens</span> s a <span class="fu">=</span> forall r<span class="fu">.</span> <span class="dt">Lens</span> (<span class="dt">Iso</span> s (a,r))</code></pre></div>
<p>This encoding captures the intuition of what lens does extremely well. Suppose we have a record type <code>s</code>, and want to take out a field of type <code>a</code>. When we do that, there is some residual, which is <code>s - a</code>. So <code>s</code> and <code>(a, s - a)</code> is must be isomorphic.</p>
<p>We can define <code>get</code> and <code>update</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Bifunctor</span>

<span class="ot">get ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a
get (<span class="dt">Lens</span> l) <span class="fu">=</span> fst <span class="fu">.</span> fw l

<span class="ot">update ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> s)
update (<span class="dt">Lens</span> l) f <span class="fu">=</span> bw l <span class="fu">.</span> first f <span class="fu">.</span> fw l</code></pre></div>
<p><code>set</code> function is the same as before:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">set ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
set l b a <span class="fu">=</span> update l (const b) a</code></pre></div>
<p>Isomorphism lens has the nice property that we can derive lens laws directly from the isomorphism law.</p>
<blockquote>
<p>fw i . bw i = bw i . fw i = id</p>
</blockquote>
<p>See <a href="http://www.twanvl.nl/blog/haskell/isomorphism-lenses">van Laarhoven’s article</a> to see how we can derive three lens law.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Sat, 10 Dec 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-12-10-encodings-of-lense.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Objects versus Abstract Data Types</title>
    <link>http://kseo.github.io//posts/2016-06-14-objects-vs-abstract-data-types.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on June 14, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/objects.html">objects</a>, <a href="/tags/abstract%20data%20types.html">abstract data types</a>
      
  </div>

<p>William R. Cook’s essay titled <a href="http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf">On Understanding Data Abstraction, Revisited</a> explains the differences between two forms of data abstraction, <em>objects</em> and <em>abstract data types</em>. His another paper, <a href="https://www.cs.utexas.edu/users/wcook/papers/OOPvsADT/CookOOPvsADT90.pdf">Object-Oriented Programming Versus Abstract Data Types</a> shows why distinguishing these two data abstractions are important:</p>
<blockquote>
<p>Object-oriented programming and abstract data types can also be viewed as complementary implementation techniques: objects are centered around the constructors of a data abstraction, while abstract data types are organized around the operations. These differences have consequences relating to extensibility, efficiency, typing, and verification; in many cases the strengths of one paradigm are the weaknesses of the other. Most object-oriented programming languages support aspects of both techniques, not a unification of them, so an understanding of their relative merits is useful in designing programs.</p>
</blockquote>
<p>Haskell type classes are also discussed in Cook’s essay. He described Haskell type classes as a powerful mechanism for parameterization and extensibility because type classes are unique in that they have properties of both objects and abstract data types:</p>
<ul>
<li>Type classes do not allow different instances to interoperate, but they allow multiple type class instances within a single program.</li>
<li>Type classes are similar to object interfaces in allowing a method to operate on any value that has the necessary operations.</li>
<li>Type classes are based on algebraic signatures as in abstract data types, but they do not enforce any hiding of representations.</li>
</ul>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Tue, 14 Jun 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-06-14-objects-vs-abstract-data-types.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Learn Haskell to be a better programmer</title>
    <link>http://kseo.github.io//posts/2016-06-01-learn-haskell-to-be-a-better-programmer.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on June  1, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/category%20theory.html">category theory</a>, <a href="/tags/composition.html">composition</a>
      
  </div>

<p>Haskell is notorious for being hard to learn. Pure functions, lazy evaluation, Haskell type system are just start.</p>
<p>To use Haskell effectively, it is necessary to learn the abstract concepts borrowed from the category theory such as Functor, Applicative Functor and Monad. You need to understand these concepts throughly because most of Haskell code is written using these abstract non-sense.</p>
<p>Of course, it is still possible to write IO code and use <code>Maybe</code>, <code>Either</code> and <code>List</code> types without understanding Monad. But then why do you want to learn Haskell anyway? If you avoid learning these concpets, you can’t learn much from Haskell. It would be much beneficial to learn other more practical languages.</p>
<p>Before explaining why you should learn Haskell, let’s ask a question. What’s the essence of programming?</p>
<p>Programming is basically instructing the computer to some labor. For example, “Load the value at memory x into the register, add 1 to it, and store the value back to the memory” is a program.</p>
<p>But a program is not just a sequence of instructions. It is a solution to our real problem. What makes programming interesting is that the problems we solve as a programmer is much bigger in size than simply loading a value from the memory and doing some arithmetic.</p>
<p>So programming is to divide a big problem that can’t be solved at once into many small problems, solve them independently, and compose the resulting small programs into a program that solves the original problem. In other words, the essence of programming is recomposition after decomposition. See Bartosz Milewski’s <a href="https://bartoszmilewski.com/2014/11/04/category-the-essence-of-composition/">Category: The Essence of Composition</a>.</p>
<p>Here comes the most important property of programming, which is called <em>composability</em>. We need to solve many complex problems which are similar but not exactly same. If we can compose small reusable programs into a new program which solves the new problem, the productivity of a programmer will be dramatically increased.</p>
<p>The changes of programming paradigm in the history can be explained as our continous endeavor to enhance the composability. For example, the shift from assembly programming with goto to structure programming emphasizing subroutine and loop was necessary as the problem size increases. We desparately needed a better way to compose programs.</p>
<p>But as the complexity of problem drastically increased again in 80-90s, we needed a new programming paradigm called object-oriented programming. Classes and objects, encapsulation and information hiding were another endeavor to imporve the composability of programs.</p>
<p>Now in 2010s, functional programming is gaining attention. The complexity of problems we have today is enormous and we need new tools and concepts to cope with ever increasing complexity. Classes are not enough. We need more composability.</p>
<p>Haskell provides new tools and concepts which can help organize code better. Concepts like Functor, Applicative Functor, Monad, Arrow and Lense all provide new means to compose programs. See Gabriel Gonzalez’s <a href="http://www.haskellforall.com/2012/08/the-category-design-pattern.html">The category design pattern</a>.</p>
<p>In fact, you already know some of these concepts. For example, ES6’s Promise, C#’s null propagation operator, Python’s list comprehension all share the same monadic structure. But you probably never noticed the common structure lying behind these different language features. After you learn Haskell, you will begin to see the common structure you’ve never imagined before.</p>
<p>In summary, the essence of programming is <em>composition</em>. Haskell provides new tools and concepts to compose programs. Learning Haskell improves your code organizational skills and make you prepared to handle more complex problems. <a href="http://learnyouahaskell.com/chapters">Learn you a Haskell for great good!</a></p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Wed, 01 Jun 2016 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2016-06-01-learn-haskell-to-be-a-better-programmer.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Summary of Philip Walder’s "Proofs are Programs"</title>
    <link>http://kseo.github.io//posts/2015-06-19-proofs-are-programs.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on June 19, 2015
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Curry-Howard%20Isomorphism.html">Curry-Howard Isomorphism</a>, <a href="/tags/lambda%20calculus.html">lambda calculus</a>, <a href="/tags/logic.html">logic</a>, <a href="/tags/natural%20deduction.html">natural deduction</a>, <a href="/tags/program.html">program</a>, <a href="/tags/proof.html">proof</a>, <a href="/tags/type%20system.html">type system</a>
      
  </div>

<p>This is my short summary of Philip Wadler’s <a href="http://homepages.inf.ed.ac.uk/wadler/papers/frege/frege.pdf">Proofs are Programs: 19th Century Logic and 21st Century Computing</a>.</p>
<p>Proofs and programs are the same thing. But it took a century of efforts to recognize the relationship.</p>
<ul>
<li>Modern logic began with Gottlob Frege’s Begriffschrift in 1879.</li>
<li>Gerhard Gentzen introduced natural deduction in 1934.</li>
<li>Alonzo Church introduced lambda calculus in 1932. He also introduced a typed version of lambda calculus in 1940.</li>
<li>Dag Prawitz showed how to simplify natural deduction proofs directly in 1956.</li>
<li>Haskell Curry noted a correspondence between the types of the combinators and the laws of logic as formulated by Hilbert in 1956.</li>
<li>W. A. Howard put together the results of Curry and Prawitz, and wrote down the correspondence between natural deduction and lambda calculus in 1969.</li>
<li>Howard’s work was published in 1980.</li>
</ul>
<p>So it took more than 30 years to recognize the correspondence between Gentzen’s natural deduction and Church’s typed lambda calculus. They are the same thing! Proofs and programs. This correspondence is called Curry-Howard Isomorphism.</p>
<p>Logicians and computer scientists have discovered exactly the same type systems!</p>
<ul>
<li>Hindley-Milner type system: Hindley (1969), Milner (1978).</li>
<li>Girard-Reynolds system: Girard (1972), Reynolds (1974).</li>
<li>.. still being discovered</li>
</ul>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Fri, 19 Jun 2015 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2015-06-19-proofs-are-programs.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>
<item>
    <title>Fay + Node.js</title>
    <link>http://kseo.github.io//posts/2014-03-11-fay-with-nodejs.html</link>
    <description><![CDATA[<article>
  <div class="info">
      Posted on March 11, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Fay.html">Fay</a>, <a href="/tags/node.js.html">node.js</a>
      
  </div>

<p><a href="https://github.com/faylang/fay">Fay</a> is a proper subset of Haskell that compiles to JavaScript. Thus it is by definition a statically typed lazy pure functional language. If you want a more thorough introduction to Fay, please read Paul Callaghan’s <a href="https://pragprog.com/magazines/2012-12/web-programming-in-haskell">Web Programming in Haskell</a> and <a href="https://ocharles.org.uk/blog/posts/2013-12-23-24-days-of-hackage-fay.html">Oliver Charles’s 24 Days of Hackage: fay</a>.</p>
<p>The original intention of Fay is to use Haskell on the client side. If you use a Haskell web framework such as Yesod or Snap, using Fay you can use the same language on both client and server sides and some code can actually be shared.</p>
<p>However, because Fay is simply a subset of Haskell that compiles to JavaScript with no dependencies on the client side, you can use it on the server side too in combination with Node.js. I am not saying it is actually a good idea to write server code in Fay, but it is at least fun to investigate the feasibility. Here is <a href="https://gist.github.com/kseo/9477930">a web server example</a> written in Fay.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE EmptyDataDecls #-}</span>
<span class="kw">module</span> <span class="dt">Hello</span> <span class="kw">where</span></code></pre></div>
<p><code>EmptyDataDecls</code> is required because JavaScript types are represented by empty data declarations in Fay.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">FFI</span></code></pre></div>
<p>FFI module provides a foreign function interface.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Http</span>
<span class="kw">data</span> <span class="dt">HttpServer</span>
<span class="kw">data</span> <span class="dt">Request</span>
<span class="kw">data</span> <span class="dt">Response</span></code></pre></div>
<p><code>Http</code>, <code>HttpServer</code>, <code>Request</code> and <code>Response</code> are JavaScript types we use in this example. They are represented by empty data declarations.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">requireHttp ::</span> <span class="dt">Fay</span> <span class="dt">Http</span>
requireHttp <span class="fu">=</span> ffi <span class="st">&quot;require(&#39;http&#39;)&quot;</span></code></pre></div>
<p>This is a simple example of a FFI declaration. It returns the result of <code>require('http')</code> as a <code>Http</code> instance. Fay is a monad which is similar to IO monad. Because a FFI function often has side effects, Fay monad is used to represent this.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">createServer ::</span> <span class="dt">Http</span> <span class="ot">-&gt;</span> (<span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()) <span class="ot">-&gt;</span> <span class="dt">Fay</span> <span class="dt">HttpServer</span>
createServer <span class="fu">=</span> ffi <span class="st">&quot;%1.createServer(%2)&quot;</span>
 
<span class="ot">consoleLog ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()
consoleLog <span class="fu">=</span> ffi <span class="st">&quot;console.log(%1)&quot;</span>
 
<span class="ot">listen ::</span> <span class="dt">HttpServer</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()
listen <span class="fu">=</span> ffi <span class="st">&quot;%1.listen(%2, %3)&quot;</span>
  
<span class="ot">writeHead ::</span> <span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()
writeHead <span class="fu">=</span> ffi <span class="st">&quot;%1.writeHead(%2, %3)&quot;</span>
  
<span class="ot">end ::</span> <span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()
end <span class="fu">=</span> ffi <span class="st">&quot;%1.end(%2)&quot;</span></code></pre></div>
<p>These FFI declarations use <code>%1</code>, <code>%2</code> that corresponds to the arguments we specify in the type. Most Fay types are automatically serialized and deserialized. Note that we can only use point free style in FFI functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">Fay</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  http <span class="ot">&lt;-</span> requireHttp
  server <span class="ot">&lt;-</span> createServer http (\req res <span class="ot">-&gt;</span> <span class="kw">do</span>
    writeHead res <span class="dv">200</span> <span class="st">&quot;{ &#39;Content-Type&#39;: &#39;text/plain&#39; }&quot;</span>
    end res <span class="st">&quot;Hello World\n&quot;</span>
    )
  listen server <span class="dv">1337</span> <span class="st">&quot;127.0.0.1&quot;</span>
  consoleLog <span class="st">&quot;Server running at http://127.0.0.1:1337/&quot;</span></code></pre></div>
<p><code>main</code> is the entry point to our web server example. Its return type is <code>Fay ()</code> because a Fay program can’t do anything without interacting with the world outside. Because we already wrapped all the Node.js APIs we use, we can program as if we write a normal Haskell program.</p>
<p>Compare our Fay web server program with the original Node.js program. Except for the FFI bindings, the main code is almost the same as before. However, our version is much more type-safe!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">var http <span class="fu">=</span> require(<span class="ch">&#39;http&#39;</span>);
http<span class="fu">.</span>createServer(function (req, res) {
  res<span class="fu">.</span>writeHead(<span class="dv">200</span>, {<span class="ch">&#39;Content-Type&#39;</span><span class="fu">:</span> <span class="ch">&#39;text/plain&#39;</span>});
  res<span class="fu">.</span>end(<span class="ch">&#39;Hello World\n&#39;</span>);
})<span class="fu">.</span>listen(<span class="dv">1337</span>, <span class="ch">&#39;127.0.0.1&#39;</span>);
console<span class="fu">.</span>log(<span class="ch">&#39;Server running at http://127.0.0.1:1337/&#39;</span>);</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></description>
    <pubDate>Tue, 11 Mar 2014 00:00:00 UT</pubDate>
    <guid>http://kseo.github.io//posts/2014-03-11-fay-with-nodejs.html</guid>
    <dc:creator>Kwang Yul Seo</dc:creator>
</item>

    </channel>
</rss>
