<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Haskell for Pragmatic Programmers</title>
    <link href="http://kseo.github.io//atom.xml" rel="self" />
    <link href="http://kseo.github.io/" />
    <id>http://kseo.github.io//atom.xml</id>
    <author>
        <name>Kwang Yul Seo</name>
        <email>kwangyul.seo@gmail.com</email>
    </author>
    <updated>2017-01-24T00:00:00Z</updated>
    <entry>
    <title>Generating the Docker client with servant-client</title>
    <link href="http://kseo.github.io//posts/2017-01-24-generating-the-docker-client-with-servant-client.html" />
    <id>http://kseo.github.io//posts/2017-01-24-generating-the-docker-client-with-servant-client.html</id>
    <published>2017-01-24T00:00:00Z</published>
    <updated>2017-01-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January 24, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/docker.html">docker</a>, <a href="/tags/API.html">API</a>, <a href="/tags/servant.html">servant</a>, <a href="/tags/servant-client.html">servant-client</a>
      
  </div>

<p><a href="http://haskell-servant.readthedocs.io/en/stable/">Servant</a> provides a type-level DSL for declaring web APIs. Once we write the specification with the DSL, we can do various things including:</p>
<ul>
<li>Write servers (this part of servant can be considered a web framework),</li>
<li>Obtain client functions (in Haskell),</li>
<li>Generate client functions for other programming languages,</li>
<li>Generate documentation for your web applications</li>
</ul>
<p>The primary use case of Servant is to write servers, but we can use <a href="https://hackage.haskell.org/package/servant-client">servant-client</a> to generate client functions for the pre-existing web servers too! In this post, I will show you how we can generate client functions for the <a href="https://docs.docker.com/engine/api/">Docket remote API</a> automatically with servant-client.</p>
<h1 id="api-specification">API specification</h1>
<p>To make the exposition simple, we will specify only three APIs: <code>ping</code>, <code>version</code> and <code>containerList</code>.</p>
<p>The simplest API is <a href="https://docs.docker.com/engine/api/v1.25/#operation/SystemPing">Ping</a> which tests if the server is accessible. Its path is <code>/v1.25/_ping</code> and it returns <code>OK</code> as a plain text with status code 200. We can succinctly describe this endpoint with Servant’s type-level DSL.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Ping</span> <span class="fu">=</span> <span class="st">&quot;_ping&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">&#39;[PlainText] Text</span></code></pre></div>
<p><a href="https://docs.docker.com/engine/api/v1.25/#operation/SystemVersion">Version</a> is a slightly more complex API which returns the version information as JSON. <code>Version</code> data type has the required fields and it declares an instance of <code>FromJSON</code> for unmarshalling JSON data into <code>Version</code>. <code>fieldLabelModifier</code> is used to bridge JSON field names to <code>Version</code> field names.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Version</span> <span class="fu">=</span> <span class="st">&quot;version&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">&#39;[JSON] Version</span>

<span class="kw">data</span> <span class="dt">Version</span> <span class="fu">=</span> <span class="dt">Version</span>
  {<span class="ot"> versionVersion       ::</span> <span class="dt">Text</span>
  ,<span class="ot"> versionApiVersion    ::</span> <span class="dt">Text</span>
  ,<span class="ot"> versionMinAPIVersion ::</span> <span class="dt">Text</span>
  ,<span class="ot"> versionGitCommit     ::</span> <span class="dt">Text</span>
  ,<span class="ot"> versionGoVersion     ::</span> <span class="dt">Text</span>
  ,<span class="ot"> versionOs            ::</span> <span class="dt">Text</span>
  ,<span class="ot"> versionArch          ::</span> <span class="dt">Text</span>
  ,<span class="ot"> versionKernelVersion ::</span> <span class="dt">Text</span>
  ,<span class="ot"> versionExperimental  ::</span> <span class="dt">Bool</span>
  ,<span class="ot"> versionBuildTime     ::</span> <span class="dt">Text</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Generic</span>)

<span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Version</span> <span class="kw">where</span>
  parseJSON <span class="fu">=</span> genericParseJSON opts
    <span class="kw">where</span> opts <span class="fu">=</span> defaultOptions { fieldLabelModifier <span class="fu">=</span> stripPrefix <span class="st">&quot;version&quot;</span> }

<span class="ot">stripPrefix ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
stripPrefix prefix <span class="fu">=</span> fromJust <span class="fu">.</span> DL.stripPrefix prefix</code></pre></div>
<p>Finally, <a href="https://docs.docker.com/engine/api/v1.25/#operation/ContainerList">ContainerList</a> returns the list of containers. The API takes optional query parameters such as <code>all</code>, <code>limit</code>, <code>size</code> and <code>filters</code> as specified follows. We created a newtype wrapper for <code>ContainerID</code> and declared <code>FromJSON</code> instances for <code>ContainerID</code> and <code>Container</code>. Some fields are omitted for brevity.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">ContainerList</span> <span class="fu">=</span> <span class="st">&quot;containers&quot;</span> <span class="fu">:&gt;</span> <span class="st">&quot;json&quot;</span> <span class="fu">:&gt;</span> <span class="dt">QueryParam</span> <span class="st">&quot;all&quot;</span> <span class="dt">Bool</span>
                                            <span class="fu">:&gt;</span> <span class="dt">QueryParam</span> <span class="st">&quot;limit&quot;</span> <span class="dt">Int</span>
                                            <span class="fu">:&gt;</span> <span class="dt">QueryParam</span> <span class="st">&quot;size&quot;</span> <span class="dt">Bool</span>
                                            <span class="fu">:&gt;</span> <span class="dt">QueryParam</span> <span class="st">&quot;filters&quot;</span> <span class="dt">Text</span>
                                            <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">&#39;[JSON] [Container]</span>

<span class="kw">newtype</span> <span class="dt">ContainerID</span> <span class="fu">=</span> <span class="dt">ContainerID</span> <span class="dt">Text</span>
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Generic</span>)

<span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">ContainerID</span>

<span class="kw">data</span> <span class="dt">Container</span> <span class="fu">=</span> <span class="dt">Container</span>
  {<span class="ot"> containerId               ::</span> <span class="dt">ContainerID</span>
  ,<span class="ot"> containerNames            ::</span> [<span class="dt">Text</span>]
  ,<span class="ot"> containerImage            ::</span> <span class="dt">Text</span>
  ,<span class="ot"> containerImageID          ::</span> <span class="dt">ImageID</span>
  ,<span class="ot"> containerCommand          ::</span> <span class="dt">Text</span>
  ,<span class="ot"> containerCreated          ::</span> <span class="dt">Int</span>
  <span class="co">-- FIXME: Add Ports</span>
  ,<span class="ot"> containerSizeRw           ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
  ,<span class="ot"> containerSizeRootFs       ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
  <span class="co">-- FIXME: Add Labels</span>
  ,<span class="ot"> containerState            ::</span> <span class="dt">Text</span>
  ,<span class="ot"> containerStatus           ::</span> <span class="dt">Text</span>
  <span class="co">-- FIXME: Add HostConfig</span>
  <span class="co">-- FIXME: Add NetworkSettings</span>
  <span class="co">-- FIXME: Add Mounts</span>
  } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Generic</span>)</code></pre></div>
<p>Our API is just the combination of these endpoints.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Api</span> <span class="fu">=</span> <span class="dt">Ping</span> <span class="fu">:&lt;|&gt;</span> <span class="dt">Version</span> <span class="fu">:&lt;|&gt;</span> <span class="dt">ContainerList</span></code></pre></div>
<h1 id="api-versioning">API Versioning</h1>
<p>Because the Docker remote API has many versions, it adds a version prefix in the path. Servant allows us to expression this version scheme by declaring a new Api with the version prefix.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">ApiV1_25</span> <span class="fu">=</span> <span class="st">&quot;v1.25&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Api</span></code></pre></div>
<p>We can also mix-and-match many endpoints as the Docker remote API changes. Let’a assume that the docker API version v1.26 changed the specification of the Version endpoint. We can reuse unchanged endpoints by replacing only the changed endpoints with new ones.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Version1_26</span> <span class="fu">=</span> <span class="fu">...</span>
<span class="kw">type</span> <span class="dt">ApiV1_26</span> <span class="fu">=</span> <span class="st">&quot;v1.26&quot;</span> <span class="fu">:&gt;</span> (<span class="dt">Ping</span> <span class="fu">:&lt;|&gt;</span> <span class="dt">Version1_26</span> <span class="fu">:&lt;|&gt;</span> <span class="dt">ContainerList</span>)</code></pre></div>
<h1 id="generating-client-functions">Generating Client Functions</h1>
<p>Now it’s time to generate client functions from the specification. It’s super easy! We can simply pass our API to <code>client</code> function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ping ::</span> <span class="dt">ClientM</span> <span class="dt">Text</span>
<span class="ot">version ::</span> <span class="dt">ClientM</span> <span class="dt">Version</span>
<span class="ot">containerList&#39; ::</span> <span class="dt">Maybe</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">ClientM</span> [<span class="dt">Container</span>]

ping
  <span class="fu">:&lt;|&gt;</span> version
  <span class="fu">:&lt;|&gt;</span> containerList&#39; <span class="fu">=</span> client apiV1_25</code></pre></div>
<p><code>ping</code> and <code>version</code> functions are okay, but the signature <code>containerList'</code> is a bit confusing. We have to pass four <code>Maybe</code> values and two of them have the <code>Bool</code> type and it is not easy to remember the order of the arguments. We can improve the function by declaring a wrapper function <code>containerList</code>. It takes a <code>ContainerListOptions</code>, and the users of the function can pass <code>defaultContainerListOptions</code> as the default value.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ContainerListOptions</span> <span class="fu">=</span> <span class="dt">ContainerListOptions</span>
  {<span class="ot"> containerListOptionAll     ::</span> <span class="dt">Maybe</span> <span class="dt">Bool</span>
  ,<span class="ot"> containerListOptionLimit   ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span>
  ,<span class="ot"> containerListOptionSize    ::</span> <span class="dt">Maybe</span> <span class="dt">Bool</span>
  ,<span class="ot"> containerListOptionFilters ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="ot">defaultContainerListOptions ::</span> <span class="dt">ContainerListOptions</span>
defaultContainerListOptions <span class="fu">=</span> <span class="dt">ContainerListOptions</span>
  { containerListOptionAll     <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">False</span>
  , containerListOptionLimit   <span class="fu">=</span> <span class="dt">Nothing</span>
  , containerListOptionSize    <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">False</span>
  , containerListOptionFilters <span class="fu">=</span> <span class="dt">Nothing</span>
  }

<span class="ot">containerList ::</span> <span class="dt">ContainerListOptions</span> <span class="ot">-&gt;</span> <span class="dt">ClientM</span> [<span class="dt">Container</span>]
containerList opt <span class="fu">=</span> containerList&#39; (containerListOptionAll opt)
                                   (containerListOptionLimit opt)
                                   (containerListOptionSize opt)
                                   (containerListOptionFilters opt)</code></pre></div>
<p>Because the expressiveness of Haskell is much more powerful than that of the REST API specification, these wrappings are somewhat unavoidable to make our client functions more Haskell-friendly.</p>
<h1 id="using-client-functions">Using Client Functions</h1>
<p>Now our client functions for the Docker API is ready. We need to prepare a <code>ClientEnv</code> by passing the host, port and url prefix of the server. We also created a custom connection manager which uses the domain socket for communication because the Docker server listens on the domain socket by default. Interested readers are referred to my previous article <a href="https://kseo.github.io/posts/2017-01-23-custom-connection-manager-for-http-client.html">Custom connection manager for http-client</a> for the implementation details of <code>newUnixSocketManager</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">query ::</span> <span class="dt">ClientM</span> [<span class="dt">Container</span>]
query <span class="fu">=</span> <span class="kw">do</span>
  ok <span class="ot">&lt;-</span> ping
  liftIO <span class="fu">$</span>  print ok
  version <span class="ot">&lt;-</span> version
  liftIO <span class="fu">$</span> print (versionVersion version)
  containerList defaultContainerListOptions

<span class="ot">app ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
app host port <span class="fu">=</span> <span class="kw">do</span>
  manager <span class="ot">&lt;-</span> newUnixSocketManager <span class="st">&quot;/var/run/docker.sock&quot;</span>
  res <span class="ot">&lt;-</span> runClientM query (<span class="dt">ClientEnv</span> manager (<span class="dt">BaseUrl</span> <span class="dt">Http</span> host port <span class="st">&quot;&quot;</span>))
  <span class="kw">case</span> res <span class="kw">of</span>
    <span class="dt">Left</span> err          <span class="ot">-&gt;</span> putStrLn <span class="fu">$</span> <span class="st">&quot;Error: &quot;</span> <span class="fu">++</span> show err
    <span class="dt">Right</span> containers  <span class="ot">-&gt;</span> mapM_ print containers</code></pre></div>
<p>Because <code>ClientM</code> is a monad, we can combine multiple monadic actions into one. <code>query</code> function pings the server, queries the version information and then request the list of containers.</p>
<h1 id="swagger">Swagger</h1>
<p>So far I manually specified the API with Servant’s DSL, but if the server has the <a href="http://swagger.io/">Swagger</a> specification we can even generate the Servant DSL from the Swagger specification. <a href="https://github.com/swagger-api/swagger-codegen">swagger-codegen</a> has the <a href="https://github.com/swagger-api/swagger-codegen/blob/master/modules/swagger-codegen/src/main/java/io/swagger/codegen/languages/HaskellServantCodegen.java">HaskellServantCodegen</a>, so we can use it! (I haven’t tried it yet.)</p>
<h1 id="wrap-up">Wrap-up</h1>
<p>Writing client functions for existing servers are boring and repetitive. With <em>servant-client</em>, we no longer need to write these functions. We just specify the API and Servant writes the client functions for us. Have fun with Servant!</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-24-generating-the-docker-client-with-servant-client.html";
    this.page.identifier = "/posts/2017-01-24-generating-the-docker-client-with-servant-client.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Custom connection manager for http-client</title>
    <link href="http://kseo.github.io//posts/2017-01-23-custom-connection-manager-for-http-client.html" />
    <id>http://kseo.github.io//posts/2017-01-23-custom-connection-manager-for-http-client.html</id>
    <published>2017-01-23T00:00:00Z</published>
    <updated>2017-01-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January 23, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/http-client.html">http-client</a>, <a href="/tags/Network.HTTP.Client.html">Network.HTTP.Client</a>, <a href="/tags/Manager.html">Manager</a>
      
  </div>

<p><a href="https://www.stackage.org/haddock/lts-7.12/http-client-0.4.31.2/Network-HTTP-Client.html">http-client</a> provides the low-level API for HTTP client. In this post, I will explain how to create custom connection managers. If you want to know the basics of the library, read <a href="https://haskell-lang.org/library/http-client">Making HTTP requests</a> first.</p>
<p>Every HTTP request is made via a <code>Manager</code>. It handles the details of creating connections to the server such as managing a connection pool. It also allows us to configure various settings and setup secure connections (HTTPS).</p>
<p>The easiest way to create one is to use <code>newManager defaultManagerSettings</code> as follows.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Network.HTTP.Client</span>
<span class="kw">import </span><span class="dt">Network.HTTP.Types.Status</span> (statusCode)

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  manager <span class="ot">&lt;-</span> newManager defaultManagerSettings

  request <span class="ot">&lt;-</span> parseRequest <span class="st">&quot;http://httpbin.org/post&quot;</span>
  response <span class="ot">&lt;-</span> httpLbs request manager

  putStrLn <span class="fu">$</span> <span class="st">&quot;The status code was: &quot;</span> <span class="fu">++</span> (show <span class="fu">$</span> statusCode <span class="fu">$</span> responseStatus response)
  print <span class="fu">$</span> responseBody response</code></pre></div>
<p>But the default connection manager is not enough for some cases. One such case is the <a href="https://docs.docker.com/engine/api/">docker remote API</a>. Because Docker listens on the unix domain socket by default for security reasons, we can’t access to the API with the default connection manager which uses tcp.</p>
<p>But we are not out of luck. We can configure the connection manager to create a <em>unix domain socket</em> instead of a <em>tcp socket</em> by setting a custom <code>managerRawConnection</code> field.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">managerRawConnection ::</span> <span class="dt">ManagerSettings</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">HostAddress</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Connection</span>)</code></pre></div>
<p>It is used by <code>Manager</code> to create a new <code>Connection</code> from the host and port. So we can make the connection manager to create a unix socket by replacing the default implementation with <code>openUnixSocket</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Network.Socket</span> <span class="kw">as</span> <span class="dt">S</span>
<span class="kw">import qualified</span> <span class="dt">Network.Socket.ByteString</span> <span class="kw">as</span> <span class="dt">SBS</span>
<span class="kw">import </span><span class="dt">Network.HTTP.Client</span>
<span class="kw">import </span><span class="dt">Network.HTTP.Client.Internal</span> (makeConnection)
<span class="kw">import </span><span class="dt">Network.HTTP.Types.Status</span> (statusCode)

<span class="ot">newUnixDomainSocketManager ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Manager</span>
newUnixDomainSocketManager path <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> mSettings <span class="fu">=</span> defaultManagerSettings { managerRawConnection <span class="fu">=</span> return <span class="fu">$</span> openUnixSocket path }
  newManager mSettings
  <span class="kw">where</span>
    openUnixSocket filePath _ _ _ <span class="fu">=</span> <span class="kw">do</span>
      s <span class="ot">&lt;-</span> S.socket <span class="dt">S.AF_UNIX</span> <span class="dt">S.Stream</span> S.defaultProtocol
      S.connect s (<span class="dt">S.SockAddrUnix</span> filePath)
      makeConnection (SBS.recv s <span class="dv">8096</span>)
                     (SBS.sendAll s)
                     (S.close s)</code></pre></div>
<p>By creating a connection manager with “/var/run/docker.sock”, we can make a request to the docker. The code below returns the version of the docker.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  manager <span class="ot">&lt;-</span> newUnixDomainSocketManager
   <span class="st">&quot;/var/run/docker.sock&quot;</span>
  request <span class="ot">&lt;-</span> parseRequest <span class="st">&quot;http://192.168.99.100:2376/v1.25/version&quot;</span>
  response <span class="ot">&lt;-</span> httpLbs request manager

  putStrLn <span class="fu">$</span> <span class="st">&quot;The status code was: &quot;</span> <span class="fu">++</span> (show <span class="fu">$</span> statusCode <span class="fu">$</span> responseStatus response)
  print <span class="fu">$</span> responseBody response</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-23-custom-connection-manager-for-http-client.html";
    this.page.identifier = "/posts/2017-01-23-custom-connection-manager-for-http-client.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Writer monad</title>
    <link href="http://kseo.github.io//posts/2017-01-21-writer-monad.html" />
    <id>http://kseo.github.io//posts/2017-01-21-writer-monad.html</id>
    <published>2017-01-21T00:00:00Z</published>
    <updated>2017-01-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January 21, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/writer%20monad.html">writer monad</a>, <a href="/tags/state%20monad.html">state monad</a>, <a href="/tags/reverse%20state%20monad.html">reverse state monad</a>
      
  </div>

<p>The <em>Writer monad</em> represents computations which produce a stream of data in addition to the computed values. It is commonly used by code generators to emit code.</p>
<p><a href="https://www.stackage.org/lts-7.12/package/transformers-0.5.2.0">transformers</a> provides both the strict and lazy versions of <code>WriterT</code> monad transformer. The definition of bind operator <code>&gt;&gt;=</code> reveals how the Writer monad works.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Monoid</span> w, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">WriterT</span> w m) <span class="kw">where</span>
    return a <span class="fu">=</span> writer (a, mempty)
    m <span class="fu">&gt;&gt;=</span> k  <span class="fu">=</span> <span class="dt">WriterT</span> <span class="fu">$</span> <span class="kw">do</span>
        (a, w)  <span class="ot">&lt;-</span> runWriterT m
        (b, w&#39;) <span class="ot">&lt;-</span> runWriterT (k a)
        return (b, w <span class="ot">`mappend`</span> w&#39;)</code></pre></div>
<p><code>runWriterT</code> returns a pair whose second element is the output to accumulate. Because the output value is a <code>Monoid</code> instance, we can merge two outputs <code>w</code> and <code>w'</code> using <code>mappend</code> and return the combined output.</p>
<p>Here is a simple example of the Writer monad. It accumulates <code>LogEntry</code>s in a list. (CAUTION: Do not use <code>WriterT</code> for plain logging in real world applications. It unnecessarily keeps the entire logs in memory. I recommend <a href="https://hackage.haskell.org/package/fast-logger">fast-logger</a> for logging.)</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Monad.Trans.Writer.Strict</span>

<span class="kw">data</span> <span class="dt">LogEntry</span> <span class="fu">=</span> <span class="dt">LogEntry</span> {<span class="ot"> msg::</span><span class="dt">String</span> }
  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="ot">calc ::</span> <span class="dt">Writer</span> [<span class="dt">LogEntry</span>] <span class="dt">Integer</span>
calc <span class="fu">=</span> <span class="kw">do</span>
  output <span class="st">&quot;start&quot;</span>
  <span class="kw">let</span> x <span class="fu">=</span> sum [<span class="dv">1</span><span class="fu">..</span><span class="dv">10000000</span>]
  output (show x)
  output <span class="st">&quot;done&quot;</span>
  return x

<span class="ot">output ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> [<span class="dt">LogEntry</span>] ()
output x <span class="fu">=</span> tell [<span class="dt">LogEntry</span> x]

test <span class="fu">=</span> mapM_ print <span class="fu">$</span> execWriter calc</code></pre></div>
<p>The code looks innocuous, but its performance deteriorates when the accumulated log gets bigger because the <code>Monoid</code> instance of <code>[]</code> uses <code>(++)</code> to append two lists and the concatenations are left-nested.</p>
<pre><code>do { tell [1]; tell [2]; tell [3]; tell[4]; tell [5] }
=&gt;
(((([1] ++ [2]) ++ [3]) ++ [4]) ++ [5])</code></pre>
<p><code>(++)</code> is <a href="http://stackoverflow.com/a/13879693/2028189">known to perform poorly</a> when applications of <code>(++)</code> are left-nested.</p>
<h1 id="difference-list">Difference List</h1>
<p>One well-known solution is to use <em>the difference list</em> instead of an ordinary list. <code>DList</code> provides O(1) <code>append</code> and <code>snoc</code> operations on lists. <a href="http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/">Demystifying DList</a> explains how <code>DList</code> works in details.</p>
<p>The code is almost the same except we replaced <code>[LogEntry]</code> with <code>DList LogEntry</code>, but it scales well as the accumulated log gets bigger.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.DList</span>

<span class="ot">calc ::</span> <span class="dt">Writer</span> (<span class="dt">DList</span> <span class="dt">LogEntry</span>) <span class="dt">Integer</span>
calc <span class="fu">=</span> <span class="fu">...</span>

<span class="ot">output ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> (<span class="dt">DList</span> <span class="dt">LogEntry</span>) ()
output x <span class="fu">=</span> tell (singleton (<span class="dt">LogEntry</span> x))

test <span class="fu">=</span> mapM_ print <span class="fu">$</span> toList (execWriter calc)</code></pre></div>
<h1 id="endo">Endo</h1>
<p>Another option is to use <code>Endo</code> wrapper from <code>Data.Monoid</code>. It is an endomorphism from type <code>a</code> to <code>a</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Endo</span> a <span class="fu">=</span> <span class="dt">Endo</span> {<span class="ot"> appEndo ::</span> a <span class="ot">-&gt;</span> a }
               <span class="kw">deriving</span> (<span class="dt">Generic</span>)</code></pre></div>
<p>Surprisingly, it is an instance of <code>Monoid</code>. <code>mempty</code> is the <em>identity</em> function and <code>mappend</code> is the <em>composition</em> of two functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Endo</span> a) <span class="kw">where</span>
        mempty <span class="fu">=</span> <span class="dt">Endo</span> id
        <span class="dt">Endo</span> f <span class="ot">`mappend`</span> <span class="dt">Endo</span> g <span class="fu">=</span> <span class="dt">Endo</span> (f <span class="fu">.</span> g)</code></pre></div>
<p>But how can I output a log? We need a function of type <code>[LogEntry] -&gt; [LogEntry]</code> to make an <code>Endo</code> value. The trick is to create a section <code>([LogEntry x]&lt;&gt;)</code> which prepends a log entry to the list.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">calc ::</span> <span class="dt">Writer</span> (<span class="dt">Endo</span> [<span class="dt">LogEntry</span>]) <span class="dt">Integer</span>
calc <span class="fu">=</span> <span class="fu">...</span>

<span class="ot">output ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> (<span class="dt">Endo</span> [<span class="dt">LogEntry</span>]) ()
output x <span class="fu">=</span> tell <span class="fu">$</span> <span class="dt">Endo</span> ([<span class="dt">LogEntry</span> x]<span class="fu">&lt;&gt;</span>)

test <span class="fu">=</span> mapM_ print <span class="fu">$</span> appEndo (execWriter calc) []</code></pre></div>
<p>But why does this use of <code>Endo</code> perform well? To see why, we need to see how the following code is actually evaluated.</p>
<pre><code>do { tell [1]; tell [2]; tell [3]; tell[4]; tell [5] }</code></pre>
<p>is translated to</p>
<pre><code>([1]++) . ([2]++) . ([3]++) . ([4]++) . ([5]++)</code></pre>
<p>This is a composition of functions whose type is <code>[Int] -&gt; [Int]</code>. We can obtain the final result by applying <code>[]</code>.</p>
<pre><code>([1]++) . ([2]++) . ([3]++) . ([4]++) . ([5]++) $ []
=&gt;
[1] ++ ([2] ++ ([3] ++ ([4] ++ ([5] ++ []))))</code></pre>
<p>We can see that <code>(++)</code> operators are right-nested.</p>
<p>This also explains why <code>DList</code> in the previous section performs well because <code>DList</code> is just <code>Endo</code> specialized to lists.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">DList</span> a <span class="fu">=</span> <span class="dt">DL</span> {<span class="ot"> unDL ::</span> [a] <span class="ot">-&gt;</span> [a] }

<span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">DList</span> a) <span class="kw">where</span>
    mempty  <span class="fu">=</span> <span class="dt">DL</span> id
    mappend xs ys <span class="fu">=</span> <span class="dt">DL</span> (unDL xs <span class="fu">.</span> unDL ys)</code></pre></div>
<h1 id="state-monad">State Monad</h1>
<p>It is possible to implement the Writer monad in terms of the <em>State monad</em>. We can store the accumulated logs in the state and update it by appending a new log.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Trans.State</span>
<span class="kw">import </span><span class="dt">Data.Monoid</span> ((&lt;&gt;))

<span class="ot">calc ::</span> <span class="dt">State</span> [<span class="dt">LogEntry</span>] <span class="dt">Integer</span>
calc <span class="fu">=</span> <span class="fu">...</span>

<span class="ot">output ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">State</span> [<span class="dt">LogEntry</span>] ()
output x <span class="fu">=</span> modify (<span class="fu">&lt;&gt;</span> [<span class="dt">LogEntry</span> x])

test <span class="fu">=</span> mapM_ print <span class="fu">$</span> execState calc []</code></pre></div>
<p>Unfortunately, this version has the same performance issue with the initial version because applications of <code>(++)</code> are left-nested.</p>
<p>But there is a magical trick that can change this situation.</p>
<h1 id="backward-state-monad">Backward State Monad</h1>
<p>The section “2.8 Variation six: Backwards state” of Philip Wadler’s <a href="https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/the-essence-of-functional-programming.pdf">The essence of functional programming</a> briefly mentions the <em>Backwards state</em> monad (also known as <em>reverse state monad</em>). This is a strange variant of the State monad where the state is propagated backward.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">RState</span> s a <span class="fu">=</span> <span class="dt">RState</span> {<span class="ot"> runRState ::</span> s <span class="ot">-&gt;</span> (a,s) }

<span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">RState</span> s) <span class="kw">where</span>
    return x <span class="fu">=</span> <span class="dt">RState</span> <span class="fu">$</span> (,) x
    <span class="dt">RState</span> sf <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">RState</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span>
        <span class="kw">let</span> (a,s&#39;&#39;) <span class="fu">=</span> sf s&#39;
            (b,s&#39;) <span class="fu">=</span> runRState (f a) s
        <span class="kw">in</span> (b,s&#39;&#39;)

rget <span class="fu">=</span> <span class="dt">RState</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> (s,s)
rmodify f <span class="fu">=</span> <span class="dt">RState</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> ((),f s)
rput <span class="fu">=</span> rmodify <span class="fu">.</span> const

execRState f s <span class="fu">=</span> snd (runRState f s)</code></pre></div>
<p>In the definition of <code>&gt;&gt;=</code>, the state <code>s</code> is passed to the second expression and its result <code>s'</code> is passed back to the first expression. This seems impossible because two expressions are mutually recursive, but Haskell’s lazy evaluation makes it possible. In the backward state monad, <code>rget</code> reads the state from the future!</p>
<p>With this in mind, we can implement the Writer monad by prepending the log to the state. Because the state contains all the future logs, we can simply prepend our log to it.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">calc ::</span> <span class="dt">RState</span> [<span class="dt">LogEntry</span>] <span class="dt">Integer</span>
calc <span class="fu">=</span> <span class="fu">...</span>

<span class="ot">output ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">RState</span> [<span class="dt">LogEntry</span>] ()
output x <span class="fu">=</span> rmodify ([<span class="dt">LogEntry</span> x]<span class="fu">&lt;&gt;</span>)

test <span class="fu">=</span> mapM_ print <span class="fu">$</span> execRState calc []</code></pre></div>
<p>Applications of <code>(++)</code> are right-nested because logs are accumulated backward from the end.</p>
<p>Readers who would like to know more about the backward state monads are referred to:</p>
<ul>
<li><a href="https://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/">Mindfuck: The Reverse State Monad</a> shows how to compute the fibonacci number using the reverse state monad.</li>
<li><a href="https://hackage.haskell.org/package/tardis-0.4.1.0">tardis</a> package - a combination of both a forwards and a backwards state transformer.</li>
</ul>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-21-writer-monad.html";
    this.page.identifier = "/posts/2017-01-21-writer-monad.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>How Servant's type-safe links work</title>
    <link href="http://kseo.github.io//posts/2017-01-20-how-servant%27s-type-safe-links-work.html" />
    <id>http://kseo.github.io//posts/2017-01-20-how-servant%27s-type-safe-links-work.html</id>
    <published>2017-01-20T00:00:00Z</published>
    <updated>2017-01-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January 20, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/servant.html">servant</a>, <a href="/tags/safe%20link.html">safe link</a>, <a href="/tags/type%20families.html">type families</a>
      
  </div>

<p>Many Haskell web frameworks provide so called <em>type-safe links</em>. Servant is no exception and it provides one of the strongest safety check. It statically guarantees that all links are valid endpoints of the server!</p>
<p>In servant, we can create a type-safe URI using <code>safeLink</code> function. It takes both <em>the whole API</em> and <em>the API endpoint</em> we would like to point to. It signals a type error if the endpoint does not belong to the whole api.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Create a valid (by construction) relative URI with query params.</span>
<span class="co">--</span>
<span class="co">-- This function will only typecheck if `endpoint` is part of the API `api`</span>
safeLink
<span class="ot">    ::</span> forall endpoint api<span class="fu">.</span> (<span class="dt">IsElem</span> endpoint api, <span class="dt">HasLink</span> endpoint)
    <span class="ot">=&gt;</span> <span class="dt">Proxy</span> api      <span class="co">-- ^ The whole API that this endpoint is a part of</span>
    <span class="ot">-&gt;</span> <span class="dt">Proxy</span> endpoint <span class="co">-- ^ The API endpoint you would like to point to</span>
    <span class="ot">-&gt;</span> <span class="dt">MkLink</span> endpoint</code></pre></div>
<p>To better explain how type-safe links work in Servant, let’s create a mini web DSL that is a small subset of Servant DSL.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds              #-}</span>
<span class="ot">{-# LANGUAGE ConstraintKinds        #-}</span>
<span class="ot">{-# LANGUAGE PolyKinds              #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies           #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators          #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances   #-}</span>

<span class="kw">import </span><span class="dt">Data.Proxy</span>
<span class="kw">import </span><span class="dt">GHC.Exts</span> (<span class="dt">Constraint</span>)
<span class="kw">import </span><span class="dt">GHC.TypeLits</span>

<span class="kw">data</span> a <span class="fu">:&lt;|&gt;</span> b <span class="fu">=</span> a <span class="fu">:&lt;|&gt;</span> b
<span class="kw">infixr</span> <span class="dv">8</span> <span class="fu">:&lt;|&gt;</span>

<span class="kw">data</span> (<span class="ot">path ::</span> k) <span class="fu">:&gt;</span> a
<span class="kw">infixr</span> <span class="dv">9</span> <span class="fu">:&gt;</span>

<span class="kw">data</span> <span class="dt">Method</span> <span class="fu">=</span> <span class="dt">Get</span> <span class="fu">|</span> <span class="dt">Post</span></code></pre></div>
<ul>
<li><code>(:&lt;|&gt;)</code> is the union of two APIs.</li>
<li><code>(:&gt;)</code> specifies the path.</li>
<li>Support only two methods <code>Get</code> and <code>Post</code></li>
</ul>
<p>Here’s the API and a few endpoints defined using our mini web DSL.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Api</span> <span class="fu">=</span> <span class="st">&quot;item&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span>
      <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;item&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Post</span>
      <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;user&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span>

<span class="kw">type</span> <span class="dt">ValidEndpoint</span> <span class="fu">=</span> <span class="st">&quot;item&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span>

<span class="kw">type</span> <span class="dt">InvalidEndpoint1</span> <span class="fu">=</span> <span class="st">&quot;user&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Post</span>
<span class="kw">type</span> <span class="dt">InvalidEndpoint2</span> <span class="fu">=</span> <span class="st">&quot;none&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span></code></pre></div>
<p>For simplicity, our <code>safeLink</code> function is also revised to return <code>()</code> instead of creating an actual URI. Creating a URI from the endpoint is straightforward.</p>
<p>Our mini <code>safeLink</code> throws an type error if <code>endpoint</code> does not belong to <code>api</code>. But how? The body of <code>safeLink</code> is just <code>()</code>!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">safeLink ::</span> forall endpoint api<span class="fu">.</span> (<span class="dt">IsElem</span> endpoint api) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> api <span class="ot">-&gt;</span> <span class="dt">Proxy</span> endpoint <span class="ot">-&gt;</span> ()
safeLink _ _ <span class="fu">=</span> ()</code></pre></div>
<p>An acute reader might have noticed, the magic is hidden in the <code>IsElem</code> type function. <code>IsElem endpoint api</code> checks if <code>endpoint</code> is an element of <code>api</code>.</p>
<p>Before diving into the definition of <code>IsElem</code>, we need an auxiliary type-level function <code>Or</code>. It is defined using <em>closed type families</em>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | If either a or b produce an empty constraint, produce an empty constraint.</span>
<span class="kw">type</span> family <span class="dt">Or</span> (<span class="ot">a ::</span> <span class="dt">Constraint</span>) (<span class="ot">b ::</span> <span class="dt">Constraint</span>)<span class="ot"> ::</span> <span class="dt">Constraint</span> <span class="kw">where</span>
    <span class="co">-- This works because of:</span>
    <span class="co">-- https://ghc.haskell.org/trac/ghc/wiki/NewAxioms/CoincidentOverlap</span>
    <span class="dt">Or</span> () b       <span class="fu">=</span> ()
    <span class="dt">Or</span> a ()       <span class="fu">=</span> ()</code></pre></div>
<p><code>Or</code> takes two constraints as arguments and produces an empty constraint if either one of two arguments produces an empty constraint.</p>
<p><code>IsElm</code> is defined in terms of <code>Or</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Closed type family, check if endpoint is within api</span>
<span class="kw">type</span> family <span class="dt">IsElem</span> endpoint<span class="ot"> api ::</span> <span class="dt">Constraint</span> <span class="kw">where</span>
    <span class="dt">IsElem</span> e (sa <span class="fu">:&lt;|&gt;</span> sb)                   <span class="fu">=</span> <span class="dt">Or</span> (<span class="dt">IsElem</span> e sa) (<span class="dt">IsElem</span> e sb)
    <span class="dt">IsElem</span> (e <span class="fu">:&gt;</span> sa) (e <span class="fu">:&gt;</span> sb)              <span class="fu">=</span> <span class="dt">IsElem</span> sa sb
    <span class="dt">IsElem</span> e e                              <span class="fu">=</span> ()</code></pre></div>
<p>The rules are straightforward:</p>
<ol style="list-style-type: decimal">
<li>If <code>api</code> consists of multiple endpoints, check each endpoint and combines the result using <code>Or</code>.</li>
<li>If both <code>api</code> and <code>endpoint</code> start with the same path <code>e</code>, check the remaining parts.</li>
<li>If both <code>api</code> and <code>endpoint</code> is the same, return an empty constraint.</li>
</ol>
<p>If <code>endpoint</code> does not belong to <code>api</code>, GHC can’t deduce the type and emits an type error. The actual implementation of Servant is more complicated because it needs to handle other components such as <code>Capture</code> and <code>QueryParam</code>, but the core idea is the same!</p>
<p>Now we can test if our <code>safeLink</code> actually works.</p>
<p><code>getItem</code> is well-typed because <code>ValidEndpoint</code> is in fact a valid endpoint of <code>Api</code> using <code>safeLink</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">getItem  <span class="fu">=</span> safeLink (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Api</span>) (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">ValidEndpoint</span>)
postUser <span class="fu">=</span> safeLink (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Api</span>) (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">InvalidEndpoint1</span>)</code></pre></div>
<p><code>postUser</code> is ill-typed because <code>InvalidEndpoint1</code> is not a valid endpoint of <code>Api</code>. We can see that GHC actually throws an error!</p>
<pre><code>• Could not deduce: Or
                      (IsElem (&quot;user&quot; :&gt; &#39;Post) (&quot;item&quot; :&gt; &#39;Get))
                      (Or
                         (IsElem (&quot;user&quot; :&gt; &#39;Post) (&quot;item&quot; :&gt; &#39;Post))
                         (IsElem (&quot;user&quot; :&gt; &#39;Post) (&quot;user&quot; :&gt; &#39;Get)))
    arising from a use of ‘safeLink’
• In the expression:
    safeLink (Proxy :: Proxy Api) (Proxy :: Proxy InvalidEndpoint1)
  In an equation for ‘postUser’:
      postUser
        = safeLink (Proxy :: Proxy Api) (Proxy :: Proxy InvalidEndpoint1)</code></pre>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-20-how-servant%27s-type-safe-links-work.html";
    this.page.identifier = "/posts/2017-01-20-how-servant%27s-type-safe-links-work.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Fun with hint</title>
    <link href="http://kseo.github.io//posts/2017-01-19-fun-with-hint.html" />
    <id>http://kseo.github.io//posts/2017-01-19-fun-with-hint.html</id>
    <published>2017-01-19T00:00:00Z</published>
    <updated>2017-01-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January 19, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/hint.html">hint</a>, <a href="/tags/dynamic%20evaluation.html">dynamic evaluation</a>, <a href="/tags/interpreter.html">interpreter</a>
      
  </div>

<p>If you are a Haskell convert from Lisp, JavaScript or any other dynamic programming language, you might miss <a href="https://en.wikipedia.org/wiki/Eval">eval</a> function of those languages. <code>eval</code> lets us load code dynamically and execute it on the fly. It is commonly used to provide user-defined plugins and is a very handy tool for software extension.</p>
<p>Dynamic evaluation is not limited to dynamic languages. Even Java supports dynamic class loading through class loaders. It seems Haskell does not support dynamic evaluation as it is a strictly defined language. But GHC allows us to compile and execute Haskell code dynamically through GHC API.</p>
<p><a href="https://hackage.haskell.org/package/hint">hint</a> library provides a Haskell interpreter built on top of GHC API. It allows to load and execute Haskell expressions and even coerce them into values.</p>
<p><em>hint</em> provides a bunch of monadic actions based on <code>InterpreterT</code> monad transformer. <code>runInterpreter</code> is used to execute the action.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runInterpreter ::</span> (<span class="dt">MonadIO</span> m, <span class="dt">MonadMask</span> m) <span class="ot">=&gt;</span> <span class="dt">InterpreterT</span> m a <span class="ot">-&gt;</span> m (<span class="dt">Either</span> <span class="dt">InterpreterError</span> a)</code></pre></div>
<h1 id="type-check">Type check</h1>
<p>We can check the type of a Haskell expression using <code>typeOf</code>.</p>
<pre><code>λ&gt; import Language.Haskell.Interpreter
λ&gt; runInterpreter $ typeOf &quot;\&quot;foo\&quot;&quot;
Right &quot;[GHC.Types.Char]&quot;
λ&gt; runInterpreter $ typeOf &quot;3.14&quot;
Right &quot;GHC.Real.Fractional t =&gt; t&quot;</code></pre>
<h1 id="import-modules">Import modules</h1>
<p><em>hint</em> does not import prelude implicitly. We need import modules explicitly using <code>setImport</code>. For qualified imports, use <code>setImportQ</code> instead.</p>
<pre><code>λ&gt; runInterpreter $ do { setImports [&quot;Prelude&quot;]; typeOf &quot;head [True, False]&quot; }
Right &quot;Bool&quot;
λ&gt; runInterpreter $ do { setImportsQ [(&quot;Prelude&quot;, Nothing), (&quot;Data.Map&quot;, Just &quot;M&quot;) ]; typeOf &quot;M.empty&quot; }
Right &quot;M.Map k a&quot;</code></pre>
<h1 id="evaluate-expressions">Evaluate expressions</h1>
<p><code>eval</code> function lets us evaluate Haskell expressions dynamically.</p>
<pre><code>λ&gt; runInterpreter $ do { setImports [&quot;Prelude&quot;]; eval &quot;head [True, False]&quot; }
Right &quot;True&quot;
λ&gt; runInterpreter $ do { setImports [&quot;Prelude&quot;]; eval &quot;1 + 2 * 3&quot; }
Right &quot;7&quot;</code></pre>
<p>The result type of evaluation is <code>String</code>. To convert the result into the type we want, use <code>interpret</code> with <code>as</code>. Here <code>as</code> provides a witness for its monomorphic type.</p>
<pre><code>λ&gt; runInterpreter $ do { setImports [&quot;Prelude&quot;]; interpret &quot;head [True, False]&quot; (as :: Bool) }
Right True
λ&gt; runInterpreter $ do { setImports [&quot;Prelude&quot;]; interpret &quot;1 + 2 * 3&quot; (as :: Int) }
Right 7</code></pre>
<h1 id="load-modules">Load modules</h1>
<p>It is also possible to load modules dynamically.</p>
<p>Here’s a small module <code>Foo</code> stored in <code>Foo.hs</code> file.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Foo</span> <span class="kw">where</span>

f <span class="fu">=</span> head
g <span class="fu">=</span> tail</code></pre></div>
<p>We can load <code>Foo</code> using <code>loadModules</code> function. <code>setTopLevelModules</code> ensures that all bindings of the module are in scope.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Language.Haskell.Interpreter</span>

<span class="ot">ex ::</span> <span class="dt">Interpreter</span> ()
ex <span class="fu">=</span> <span class="kw">do</span>
  loadModules [<span class="st">&quot;Foo.hs&quot;</span>]
  setTopLevelModules [<span class="st">&quot;Foo&quot;</span>]
  setImportsQ [(<span class="st">&quot;Prelude&quot;</span>, <span class="dt">Nothing</span>)]

  <span class="kw">let</span> expr1 <span class="fu">=</span> <span class="st">&quot;f [1, 2, 3]&quot;</span>
  a <span class="ot">&lt;-</span> eval expr1
  liftIO <span class="fu">$</span> print a

  <span class="kw">let</span> expr2 <span class="fu">=</span> <span class="st">&quot;g [1, 2, 3]&quot;</span>
  a <span class="ot">&lt;-</span> eval expr2
  liftIO <span class="fu">$</span> print a

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  r <span class="ot">&lt;-</span> runInterpreter ex
  <span class="kw">case</span> r <span class="kw">of</span>
    <span class="dt">Left</span> err <span class="ot">-&gt;</span> print err
    <span class="dt">Right</span> () <span class="ot">-&gt;</span> return ()</code></pre></div>
<p>Executing this program prints</p>
<pre><code>&quot;1&quot;
&quot;[2,3]&quot;</code></pre>
<p>because <code>f</code> is <code>head</code> and <code>g</code> is <code>tail</code>.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-19-fun-with-hint.html";
    this.page.identifier = "/posts/2017-01-19-fun-with-hint.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Natural transformations in Servant</title>
    <link href="http://kseo.github.io//posts/2017-01-18-natural-transformations-in-servant.html" />
    <id>http://kseo.github.io//posts/2017-01-18-natural-transformations-in-servant.html</id>
    <published>2017-01-18T00:00:00Z</published>
    <updated>2017-01-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January 18, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/servant.html">servant</a>, <a href="/tags/natural%20transformation.html">natural transformation</a>, <a href="/tags/monad%20morphism.html">monad morphism</a>
      
  </div>

<p>I’ve recently started using <a href="http://haskell-servant.readthedocs.io/en/stable/">servant</a> at work. Servant lets us declare web APIs at the type-level once and use those APIs to write servers, obtains client functions and generate documentation. It’s a real world example which shows the power of Haskell type system.</p>
<p>The most interesting part of Servant is its <em>extensible type-level DSL</em> for describing web APIs. However, I found another interesting application of theory into practice in <a href="https://hackage.haskell.org/package/servant-server">servant-server</a> library. It is the use of <em>natural transformation</em> to convert one handler type into another handler type.</p>
<p>In Servant, <code>Handler</code> is a type alias for <code>ExceptT ServantErr IO</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Handler</span> <span class="fu">=</span> <span class="dt">ExceptT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span></code></pre></div>
<p>Thus <code>Handler</code> monad allows us to do:</p>
<ul>
<li>Perform IO operations such as database query through the base monad <code>IO</code>.</li>
<li>Throw a <code>ServantErr</code> if something went wrong.</li>
</ul>
<p>Here’s an example of a Servant handler.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">ItemApi</span> <span class="fu">=</span>
    <span class="st">&quot;item&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;itemId&quot;</span> <span class="dt">Integer</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">&#39;[JSON] Item</span>

<span class="ot">queryItemFirst ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">Item</span>)
queryItemFirst itemId <span class="fu">=</span> <span class="fu">...</span>

<span class="ot">getItemById ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Item</span>
getItemById itemId <span class="fu">=</span> <span class="kw">do</span>
  mItem <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> queryItemFirst itemId
  <span class="kw">case</span> mItem <span class="kw">of</span>
    <span class="dt">Just</span> item <span class="ot">-&gt;</span> return item
    <span class="dt">Nothing</span>   <span class="ot">-&gt;</span> throwError err404</code></pre></div>
<p>So far so good, but what if <code>queryItemFirst</code> needs a database connection to retrieve the item? Ideally, we would like to create a custom monad for our application such as</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">AppEnv</span> <span class="fu">=</span> <span class="dt">AppEnv</span> {<span class="ot"> db ::</span> <span class="dt">ConnectionPool</span> }
<span class="kw">type</span> <span class="dt">MyHandler</span> <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="dt">AppEnv</span> (<span class="dt">ExceptT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>)

<span class="ot">queryItemFirst ::</span> <span class="dt">ConnectionPool</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">Item</span>)
queryItemFirst cp itemId <span class="fu">=</span> <span class="fu">...</span>

<span class="ot">getItemById ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">MyHandler</span> <span class="dt">Item</span>
getItemById itemId <span class="fu">=</span> <span class="kw">do</span>
  cp <span class="ot">&lt;-</span> db <span class="fu">&lt;$&gt;</span> ask
  mItem <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> queryItemFirst cp itemId
  <span class="kw">case</span> mItem <span class="kw">of</span>
    <span class="dt">Just</span> item <span class="ot">-&gt;</span> return item
    <span class="dt">Nothing</span>   <span class="ot">-&gt;</span> throwError err404</code></pre></div>
<p>Unfortunately, this does not work because <a href="https://www.stackage.org/haddock/lts-7.12/servant-server-0.8.1/Servant-Server.html#v:serve">serve</a> wants <code>Handler</code> type. We need a way to transform <code>MyHandler</code> into <code>Handler</code> so that Servant can happily serve our handlers. Because both <code>MyHandler</code> and <code>Handler</code> are monads, we need a monad morphism. Or more generally, we need a <em>natural transformation</em> from <code>MyHandler</code> to <code>Handler</code>.</p>
<p>Servant provides a newtype wrapper <code>Nat</code> which represents a natural transformation from <code>m a</code> to <code>n a</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> m <span class="fu">:~&gt;</span> n <span class="fu">=</span> <span class="dt">Nat</span> {<span class="ot"> unNat ::</span> forall a<span class="fu">.</span> m a <span class="ot">-&gt;</span> n a}</code></pre></div>
<p>So what we want is <code>MyHandler :~&gt; Handler</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myHandlerToHandler ::</span> <span class="dt">AppEnv</span> <span class="ot">-&gt;</span> <span class="dt">MyHandler</span> <span class="fu">:~&gt;</span> <span class="dt">Handler</span>
myHandlerToHandler env <span class="fu">=</span> <span class="dt">Nat</span> myHandlerToHandler&#39;
  <span class="kw">where</span>
<span class="ot">  myHandlerToHandler&#39; ::</span> <span class="dt">MyHandler</span> a <span class="ot">-&gt;</span> <span class="dt">Handler</span> a
  myHandlerToHandler&#39; h <span class="fu">=</span> runReaderT h env</code></pre></div>
<p>Okay, now we can get a natural transformation <code>MyHandler :~&gt; Handler</code> by applying an <code>AppEnv</code> to <code>myHandlerToHandler</code>. How can I tell the Servant to use this natural transformation to serve our handlers? That’s what <a href="https://www.stackage.org/haddock/lts-7.12/servant-server-0.8.1/Servant-Server.html#v:enter">enter</a> does!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">server ::</span> <span class="dt">AppEnv</span> <span class="ot">-&gt;</span> <span class="dt">Server</span> <span class="dt">ItemApi</span>
server env <span class="fu">=</span>
  enter (myHandlerToHandler env) getItemById</code></pre></div>
<p>Wrapping <code>Handler</code> with <code>ReaderT</code> is a common idiom, so Servant provides a convenient function <code>runReaderTNat</code> which is exactly the same to <code>myHandlerToHandler</code>. So we can rewrite <code>server</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">server ::</span> <span class="dt">AppEnv</span> <span class="ot">-&gt;</span> <span class="dt">Server</span> <span class="dt">ItemApi</span>
server env <span class="fu">=</span>
  enter (runReaderTNat env) getItemById</code></pre></div>
<p>Servant also provides a lot of monad morphisms such as <code>hoistNat</code>, <code>embedNat</code>, <code>squashNat</code> and <code>generalizeNat</code>. Sounds familiar? These are just wrappers around <a href="https://hackage.haskell.org/package/mmorph">mmorph</a> library functions. Interested readers are referred to Gabriel Gonzalez’s article <a href="http://www.haskellforall.com/2013/03/mmorph-100-monad-morphisms.html">mmorph-1.0.0: Monad morphisms</a>.</p>
<p>In object-oriented programming, we use <em>Adapter pattern</em> to allow the interface of an existing class to be used as another interface. In functional programming, we use <em>natural transformations</em> (or more generally, <em>functors</em>) to do so!</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-18-natural-transformations-in-servant.html";
    this.page.identifier = "/posts/2017-01-18-natural-transformations-in-servant.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Type-level functions using closed type families</title>
    <link href="http://kseo.github.io//posts/2017-01-16-type-level-functions-using-closed-type-families.html" />
    <id>http://kseo.github.io//posts/2017-01-16-type-level-functions-using-closed-type-families.html</id>
    <published>2017-01-16T00:00:00Z</published>
    <updated>2017-01-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January 16, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/dependent%20type.html">dependent type</a>, <a href="/tags/type-level.html">type-level</a>, <a href="/tags/list.html">list</a>
      
  </div>

<p>In this post, we will see how to write basic type-level functions using <a href="https://github.com/ghc/ghc/commit/569b26526403df4d88fe2a6d64c7dade09d003ad">closed type families</a>.</p>
<p>Before we start, let’s declare a bunch of GHC language extensions required to use type-level functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></code></pre></div>
<p>Also import required modules. <code>GHC.TypeLits</code> provides type-level natural numbers and symbols.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">GHC.TypeLits</span>
<span class="kw">import </span><span class="dt">Data.Proxy</span></code></pre></div>
<h1 id="literals">Literals</h1>
<p>Datatype promotion allows us to use <code>True</code> and <code>False</code> as type constructors whose kind is <code>Bool</code>. The quotes are used to emphasize the promotion, but can be omitted when syntactically unambiguous.</p>
<pre><code>λ&gt; :set -XDataKinds
λ&gt; :kind &#39;True
&#39;True :: Bool
λ&gt; :kind &#39;False
&#39;False :: Bool</code></pre>
<p>We can also use numbers such as <code>1</code> and <code>2</code> as types. The kind of these numbers is <code>Nat</code>.</p>
<pre><code>λ&gt; :kind 1
1 :: Nat</code></pre>
<h1 id="type-level-function">Type-level Function</h1>
<p><code>If</code> takes three arguments <code>c</code>, <code>t</code> and <code>e</code> and returns <code>t</code> if <code>c</code> is <code>True</code>, returns <code>e</code> otherwise. The kind of <code>If</code> is <code>Bool -&gt; * -&gt; * -&gt; *</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">If</span> c t e <span class="kw">where</span>
  <span class="dt">If</span> <span class="ch">&#39;True  t e = t</span>
  <span class="dt">If</span> <span class="ch">&#39;False t e = e</span></code></pre></div>
<p>We can use GHCi’s <code>kind!</code> command to evaluate type functions.</p>
<pre><code>λ&gt; :kind! If &#39;True Bool Char
If &#39;True Bool Char :: *
= Bool
λ&gt; :kind! If &#39;False Int Double
If &#39;False Int Double :: *
= Double</code></pre>
<p>Note that type-level function <code>If</code> is strict in its type arugments.</p>
<h1 id="type-level-list">Type-level List</h1>
<p>As we can promote types like <code>Bool</code>, we can also promote lists and treat <code>[]</code> as a <em>kind constructor</em>, and <code>[]</code> and <code>(:)</code> as <em>types</em>.</p>
<p>When <code>(:)</code> is seen as a type constructor, it has kind</p>
<pre><code>λ&gt; :kind (:)
(:) :: a -&gt; [a] -&gt; [a]</code></pre>
<p>It means <code>(:)</code> is <em>kind-polymorphic</em>.</p>
<p>So we can create a type-level list of booleans as well as naturals.</p>
<pre><code>λ&gt; :kind [True, False]
[True, False] :: [Bool]
λ&gt; :kind [1, 2]
[1,2] :: [Nat]</code></pre>
<h1 id="type-level-list-function">Type-level List Function</h1>
<p>The definition of type-level function <code>Length</code> is the same as the value level <code>length</code> function. If it an empty list returns 0. If it not empty, add 1 to the length of the tail.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Length</span> xs <span class="kw">where</span>
   <span class="dt">Length</span> <span class="ch">&#39;[]       = 0</span>
   <span class="dt">Length</span> (x <span class="ch">&#39;: xs) = 1 + Length xs</span></code></pre></div>
<p><code>0</code> and <code>1</code> are types of <code>Nat</code> kind and <code>(+)</code> is a type-level add function defined in <code>GHC.TypeLits</code>. We can even use <code>(:)</code> as a pattern here.</p>
<pre><code>λ&gt; :kind! Length [Char,Bool,Int]
Length [Char,Bool,Int] :: Nat
= 3</code></pre>
<p>It seems <code>Length</code> is almost identical to the value level function <code>length</code>, but <code>Length</code> function is not kind-polymorphic by default. Thus passing <code>[1, 2, 3]</code> to <code>Length</code> causes an error.</p>
<pre><code>λ&gt; :kind! Length [1,2,3]

&lt;interactive&gt;:1:8: error:
    • Expected kind ‘[*]’, but ‘&#39;[1, 2, 3]’ has kind ‘[Nat]’
    • In the first argument of ‘Length’, namely ‘&#39;[1, 2, 3]’
      In the type ‘Length &#39;[1, 2, 3]’</code></pre>
<p>To make it poly-kinded, we need to turn on <code>PolyKind</code> extension. The kind is inferred automatically, but we can also specify the kind with <code>k</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Length</span> (<span class="ot">xs ::</span> [k]) <span class="kw">where</span>
   <span class="dt">Length</span> <span class="ch">&#39;[]       = 0</span>
   <span class="dt">Length</span> (x <span class="ch">&#39;: xs) = 1 + Length xs</span></code></pre></div>
<p><code>Head</code> and <code>Tail</code> are defined in a similar manner. Note that the kind of <code>xs</code> is explicitly annotated with <code>[*]</code> because they only work on type-level lists.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Head</span> (<span class="ot">xs ::</span> [<span class="fu">*</span>]) <span class="kw">where</span>
   <span class="dt">Head</span> (x <span class="ch">&#39;: xs) = x</span>

<span class="kw">type</span> family <span class="dt">Tail</span> (<span class="ot">xs ::</span> [<span class="fu">*</span>]) <span class="kw">where</span>
  <span class="dt">Tail</span> (x <span class="ch">&#39;: xs) = xs</span></code></pre></div>
<p>We can see <code>Head</code> and <code>Tail</code> work as expected.</p>
<pre><code>λ&gt; :kind! Head [Char, Bool, Int]
Head [Char, Bool, Int] :: *
= Char
*Main
λ&gt; :kind! Tail [Char, Bool, Int]
Tail [Char, Bool, Int] :: [*]
= &#39;[Bool, Int]</code></pre>
<p>One notable thing here is that both <code>Head</code> and <code>Tail</code> are partially defined. What if we pass <code>'[]</code> to <code>Head</code> or <code>Tail</code>?</p>
<pre><code>λ&gt; :kind! Head &#39;[]
Head &#39;[] :: GHC.Types.*
= Head &#39;[]</code></pre>
<p>It seems GHC treats <code>Head '[]</code> as a valid type instead of emitting a type error. It is a bit mysterious, but at least we can see that type-level functions in Haskell can be partial and the behavior is not intuitive. Interested readers are referred to Richard Eisenberg’s <a href="https://typesandkinds.wordpress.com/2015/09/09/what-are-type-families/">What are type families?</a> which discusses this issue in details.</p>
<h1 id="higher-order-type-level-list-function">Higher-order Type-level List Function</h1>
<p>It is even possible to define type-level <em>map</em> function. <code>Map</code> takes a type-level function <code>f</code> and a type-level list <code>xs</code>. It applies <code>f</code> to every element of <code>xs</code> and returns a new type-level list containing the results.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Map</span> (<span class="ot">f ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) (<span class="ot">xs ::</span> [<span class="fu">*</span>]) <span class="kw">where</span>
   <span class="dt">Map</span> f <span class="ch">&#39;[]       = &#39;</span>[]
   <span class="dt">Map</span> f (x <span class="ch">&#39;: xs) = f x &#39;</span><span class="fu">:</span> <span class="dt">Map</span> f xs</code></pre></div>
<pre><code>λ&gt; :kind! Map MakePair [Char,Bool,Int]
Map MakePair [Char,Bool,Int] :: [GHC.Types.*]
= &#39;[(Char, Char), (Bool, Bool), (Int, Int)]</code></pre>
<p>where the definition of <code>MakePair</code> is</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">MakePair</span> (<span class="ot">x ::</span> <span class="fu">*</span>) <span class="kw">where</span>
  <span class="dt">MakePair</span> x <span class="fu">=</span> (x, x)</code></pre></div>
<h1 id="wrap-up">Wrap-up</h1>
<p>So far we’ve covered only the basics of type-level datatypes and functions. Recent additions to GHC make it possible to explore the whole new world of dependent type programming in Haskell. Interested readers might want to take a look at the publications of <a href="http://cs.brynmawr.edu/~rae/">Richard A. Eisenberg</a> whose current work is to add dependent types to Haskell.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-16-type-level-functions-using-closed-type-families.html";
    this.page.identifier = "/posts/2017-01-16-type-level-functions-using-closed-type-families.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Data.Proxy</title>
    <link href="http://kseo.github.io//posts/2017-01-15-data-proxy.html" />
    <id>http://kseo.github.io//posts/2017-01-15-data-proxy.html</id>
    <published>2017-01-15T00:00:00Z</published>
    <updated>2017-01-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January 15, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Proxy.html">Proxy</a>
      
  </div>

<p><a href="https://www.stackage.org/haddock/lts-7.12/base-4.9.0.0/Data-Proxy.html">Proxy</a> is a mysterious type residing in <code>Data.Proxy</code> module. The definition of <code>Proxy</code> tells nothing about its nature.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | A concrete, poly-kinded proxy type</span>
<span class="kw">data</span> <span class="dt">Proxy</span> t <span class="fu">=</span> <span class="dt">Proxy</span></code></pre></div>
<p>The documentation of <code>Proxy</code> says two hints. It is a (1) <em>concrete</em> and (2) <em>poly-kinded</em> proxy type.</p>
<h1 id="poly-kinded">Poly-kinded</h1>
<p>The kind of <code>Proxy</code> is <code>forall k. k -&gt; *</code>.</p>
<pre><code>λ&gt; :k Proxy
Proxy :: k -&gt; *</code></pre>
<p>Here <code>k</code> is <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#ghc-flag--XPolyKinds">poly-kinded</a> so we can pass types of any kind to <code>Proxy</code>.</p>
<ul>
<li><code>Proxy Char</code> where <code>k</code> is <code>*</code>.</li>
<li><code>Proxy (,)</code> where <code>k</code> is <code>* -&gt; *</code></li>
<li><code>Proxy Show</code> where <code>k</code> is <code>* -&gt; Constraint</code></li>
<li><code>Proxy Monad</code> where <code>k</code> is <code>(* -&gt; *) -&gt; Constraint</code></li>
</ul>
<h1 id="concrete-value">Concrete value</h1>
<p>In Haskell, we can create a value of any type we want by annotating <code>undefined</code> with the type.</p>
<pre><code>λ&gt; let p = undefined :: Int</code></pre>
<p>However, we can’t use this trick if the kind of the type is not <code>*</code>, For example, we can’t annotate <code>undefined</code> with type <code>(,)</code> because its kind is <code>* -&gt; * -&gt; *</code>.</p>
<pre><code>λ&gt; let q = undefined :: (,)

&lt;interactive&gt;:4:22: error:
    • Expecting two more arguments to ‘(,)’
      Expected a type, but ‘(,)’ has kind ‘* -&gt; * -&gt; *’
    • In an expression type signature: (,)
      In the expression: undefined :: (,)
      In an equation for ‘q’: q = undefined :: (,)</code></pre>
<p><code>Proxy</code> lets us to overcome this limitation. We can create a proxy value representing the type by annotating <code>Proxy</code> data constructor.</p>
<pre><code>λ&gt; import Data.Proxy
λ&gt; let p = Proxy :: Proxy (,)
λ&gt; :t p
p :: Proxy (,)</code></pre>
<p>We can think of <code>Proxy :: Proxy (,)</code> as a reified value of the type <code>(,)</code>.</p>
<h1 id="type-application">Type Application</h1>
<p>The read/show problem below is ill-typed because of ambiguity.</p>
<pre><code>f :: String -&gt; String
f s = show (read s)</code></pre>
<p>We can fix this issue by explicitly passing the type as a value argument. As you can see the wild card pattern <code>_</code>, the value is not used anywhere in the definition of <code>f</code>. Only its type is used.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> forall proxy a<span class="fu">.</span> (<span class="dt">Read</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> proxy a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
f _ <span class="fu">=</span> (show<span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>) <span class="fu">.</span> read</code></pre></div>
<pre><code>λ&gt; f (Proxy :: Proxy Int) &quot;3&quot;
&quot;3&quot;</code></pre>
<p>As a side note, <a href="https://kseo.github.io/posts/2017-01-08-visible-type-application-ghc8.html">TypeApplications</a> extension introduced in GHC 8 provides an alternative way to fix this.</p>
<h1 id="typeable">Typeable</h1>
<p>Another application of <code>Proxy</code> is <code>Typeable</code>. Before kind polymorphism was introduced in GHC, there was a lot of code duplication in the way <code>Typeable</code> is implemented because <code>t</code> can represent only a specific kind.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Typeable</span> (<span class="ot">t ::</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">  typeOf ::</span> t <span class="ot">-&gt;</span> <span class="dt">TypeRep</span>

<span class="kw">class</span> <span class="dt">Typeable1</span> (<span class="ot">t ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">  typeOf1 ::</span> t a <span class="ot">-&gt;</span> <span class="dt">TypeRep</span>

<span class="kw">class</span> <span class="dt">Typeable2</span> (<span class="ot">t ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">  typeOf2 ::</span> t a b <span class="ot">-&gt;</span> <span class="dt">TypeRep</span></code></pre></div>
<p><code>Proxy</code> allows us to merge all these classes into one:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Typeable</span> t <span class="kw">where</span>
<span class="ot">  typeOf ::</span> <span class="dt">Proxy</span> t <span class="ot">-&gt;</span> <span class="dt">TypeRep</span>

<span class="kw">instance</span> <span class="dt">Typeable</span> <span class="dt">Int</span>  <span class="kw">where</span> typeOf _ <span class="fu">=</span> <span class="dt">TypeRep</span>
<span class="kw">instance</span> <span class="dt">Typeable</span> []   <span class="kw">where</span> typeOf _ <span class="fu">=</span> <span class="dt">TypeRep</span></code></pre></div>
<h1 id="other-use-cases-of-proxy">Other use cases of Proxy</h1>
<ul>
<li><a href="https://www.stackage.org/lts-7.12/package/json-schema-0.7.4.1">json-schema</a> uses <code>Proxy</code> to obtain the JSON representation for the given type.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">JSONSchema</span> a <span class="kw">where</span>
<span class="ot">  schema ::</span> <span class="dt">Proxy</span> a <span class="ot">-&gt;</span> <span class="dt">Schema</span></code></pre></div>
<ul>
<li>Edward Kmett’s <a href="https://www.stackage.org/lts-7.12/package/reflection-2.1.2">reflection</a> package shows an advanced usage of <code>Proxy</code>. Austin Seipp’s <a href="https://www.schoolofhaskell.com/user/thoughtpolice/using-reflection">Reflecting values to types and back</a> explains how to reify arbitrary terms into types that can be reflected back into terms.</li>
</ul>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-15-data-proxy.html";
    this.page.identifier = "/posts/2017-01-15-data-proxy.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Memoization in Haskell</title>
    <link href="http://kseo.github.io//posts/2017-01-14-memoization-in-hasekll.html" />
    <id>http://kseo.github.io//posts/2017-01-14-memoization-in-hasekll.html</id>
    <published>2017-01-14T00:00:00Z</published>
    <updated>2017-01-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January 14, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/memoization.html">memoization</a>
      
  </div>

<p><em>Memoization</em> is an optimization technique used to speed up a function by caching its previously computed results. In impure programming languages, a mutable map is used to cache computed results.</p>
<p>For example, <code>fib</code> function in Python</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> fib(n):
    <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">2</span>: <span class="cf">return</span> <span class="dv">1</span>
    <span class="cf">return</span> fib(n<span class="dv">-1</span>) <span class="op">+</span> fib(n<span class="dv">-2</span>)</code></pre></div>
<p>can be speed up by memoization:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">fib_memo <span class="op">=</span> {}
<span class="kw">def</span> fib(n):
    <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">2</span>: <span class="cf">return</span> <span class="dv">1</span>
    <span class="cf">if</span> <span class="kw">not</span> fib_memo.has_key(n):
        fib_memo[n] <span class="op">=</span> fib(n<span class="dv">-1</span>) <span class="op">+</span> fib(n<span class="dv">-2</span>)
    <span class="cf">return</span> fib_memo[n]</code></pre></div>
<p><code>fib_memo</code> dictionary caches the previous computed results, so <code>fib(n)</code> does not need to repeat the same calculation again for the same <code>n</code>.</p>
<p>This implementation technique of memoization is used widely in many programming languages, but it can’t be applied directly to Haskell because Haskell is pure and we don’t want to introduce impurity just to memoize a function. Fortunately, it is possible to memoize a function without side effects thanks to Haskell’s nature of <em>lazy evaluation</em>.</p>
<p>The following <code>memoize</code> function takes a function of type <code>Int -&gt; a</code> and returns a memoized version of the same function. The trick is to turn a function into a value because, in Haskell, <em>functions</em> are not memoized but <em>values</em> are. <code>memoize</code> converts a function <code>f :: Int -&gt; a</code> into an infinite list <code>[a]</code> whose <code>n</code>th element contains the value of <code>f n</code>. Thus each element of the list is evaluated when it is first accessed and cached automatically by the Haskell runtime thanks to lazy evaluation.</p>
<pre><code>memoize :: (Int -&gt; a) -&gt; (Int -&gt; a)
memoize f = (map f [0 ..] !!)</code></pre>
<p>Let’s define a memoized version of <code>fib</code> using <code>memoize</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
fib <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
fib <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span>
fib n <span class="fu">=</span> fib (n <span class="fu">-</span> <span class="dv">1</span>) <span class="fu">+</span> fib (n <span class="fu">-</span> <span class="dv">2</span>)

fibMemo <span class="fu">=</span> memoize fib</code></pre></div>
<p>Does <code>fibMemo</code> work properly? Sadly no, because <code>fib</code> is a recursive function which calls itself. When we call <code>fibMemo 10</code> twice, the second call is returned immediately because the first result is cached. However, intermediate <code>fib</code> calls used to evaluate <code>fib 10</code> are not cached at all because the body of <code>fib</code> calls itself directly without using <code>fibMemo</code>.</p>
<p>We can fix this issue by factoring out recursion from <code>fib</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Function</span> (fix)

<span class="ot">fib ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
fib f <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
fib f <span class="dv">1</span> <span class="fu">=</span> <span class="dv">1</span>
fib f n <span class="fu">=</span> f (n <span class="fu">-</span> <span class="dv">1</span>) <span class="fu">+</span> f (n <span class="fu">-</span> <span class="dv">2</span>)

<span class="ot">fibMemo ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>
fibMemo <span class="fu">=</span> fix (memoize <span class="fu">.</span> fib)</code></pre></div>
<p>Now every call to <code>fib</code> is memoized because <code>memoize . fib</code> is used every time <code>fib</code> recursively calls itself.</p>
<p>So far, I explained how to memoize a function whose domain is <code>Int</code>. Of course, we can generalize this technique so that an arbitrary function can be memoized. The basic idea is the same. A function is converted into a large data structure which contains the same information so that memoization is performed by lazy evaluation.</p>
<p>Interested readers are referred to</p>
<ul>
<li>Section 3 of <a href="https://wiki.haskell.org/Simonpj/Talk:FunWithTypeFuns">Fun with type functions</a> explains the type-directed memoization technique using type families.</li>
<li>Ralf Hinze’s <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.43.3272&amp;rep=rep1&amp;type=pdf">Memo funtions, polytypially!</a></li>
</ul>
<p>Conal Elliott’s articles on memoization:</p>
<ul>
<li><a href="http://conal.net/blog/posts/memoizing-polymorphic-functions-part-one">Memoizing polymorphic functions – part one</a></li>
<li><a href="http://conal.net/blog/posts/memoizing-polymorphic-functions-part-two">Memoizing polymorphic functions – part two</a></li>
<li><a href="http://conal.net/blog/posts/memoizing-polymorphic-functions-via-unmemoization">Memoizing polymorphic functions via unmemoization</a></li>
<li><a href="http://conal.net/blog/posts/elegant-memoization-with-functional-memo-tries">Elegant memoization with functional memo tries</a></li>
</ul>
<p><a href="https://hackage.haskell.org/package/MemoTrie-0.6.7">MemoTrie</a> provides a basis for memoized functions over some domains, using tries.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-14-memoization-in-hasekll.html";
    this.page.identifier = "/posts/2017-01-14-memoization-in-hasekll.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Constraint Kinds</title>
    <link href="http://kseo.github.io//posts/2017-01-13-constraint-kinds.html" />
    <id>http://kseo.github.io//posts/2017-01-13-constraint-kinds.html</id>
    <published>2017-01-13T00:00:00Z</published>
    <updated>2017-01-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January 13, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/constraints.html">constraints</a>, <a href="/tags/kinds.html">kinds</a>
      
  </div>

<p>In this blog post, I will show some examples of using the <a href="https://downloads.haskell.org/~ghc/8.0.2/docs/html/users_guide/glasgow_exts.html#the-constraint-kind">ConstraintKinds</a> GHC extension.</p>
<h1 id="constraints">Constraints</h1>
<p>Constraints in Haskell mean one of the following things:</p>
<ul>
<li>Class constraints, e.g. <code>Show a</code></li>
<li><em>Implicit parameter constraints</em>, e.g. <code>?x::Int</code> (with the <code>-XImplicitParams</code> flag)</li>
<li><em>Equality constraints</em>, e.g. <code>a ~ Int</code> (with the <code>-XTypeFamilies</code> or <code>-XGADTs</code> flag)</li>
<li>Tuples of any of the above, e.g., <code>(Show a, a ~ Int)</code></li>
</ul>
<p>These constraints can only occur to the left of =&gt; arrow in standard Haskell.</p>
<h1 id="kinds">Kinds</h1>
<p>In Haskell, types have types which are called <em>kinds</em>.</p>
<ul>
<li>The kind <code>*</code> is for types that have terms (even though not every type of kind <code>*</code> needs be inhabited if we exclude ⊥).</li>
<li><code>k -&gt; l</code> forms a function kind to indicate types of kind <code>l</code> that are parameterized over types of kind <code>k</code>.</li>
</ul>
<p>Examples:</p>
<ul>
<li>kind <code>*</code>: <code>Char</code>, <code>Bool</code>, <code>Char -&gt; Bool</code>, <code>Maybe Int</code>, <code>[Int]</code></li>
<li>kind <code>* -&gt; *</code>: <code>Maybe</code>, <code>[]</code></li>
<li>kind <code>* -&gt; * -&gt; *</code>: <code>Either</code>, <code>(,)</code></li>
</ul>
<p>While <em>data</em> introduces types of kind <code>*</code>, <em>classes</em> introduce types of kind <code>Constraint</code>.</p>
<ul>
<li>Classes such as <code>Show</code>, <code>Eq</code> or <code>Ord</code> are of kind <code>* -&gt; Constraint</code>. They form a class constraint when applied to types of kind <code>*</code>.</li>
<li>Classes such as <code>Functor</code> or <code>Monad</code> are of kind <code>(* -&gt; *) -&gt; Constraint</code>. They form a class constraint when applied to type constructors of kind <code>* -&gt; *</code>.</li>
</ul>
<p>We can use tuple syntax to create empty constraints and combine constraints.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">NoConstraint</span> <span class="fu">=</span> (<span class="ot">() ::</span> <span class="dt">Constraint</span>)
<span class="kw">type</span> <span class="dt">Text</span> a <span class="fu">=</span> (<span class="dt">Read</span> a, <span class="dt">Show</span> a)</code></pre></div>
<h1 id="constraintkinds">ConstraintKinds</h1>
<p>Classes and contexts were not first-class citizens in Haskell, but the introduction of the <em>Constraint kind</em> has changed this and allows them to be used as parameters of types.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ConstraintKinds #-}</span></code></pre></div>
<p>With this extension, constraints can be used in new ways:</p>
<ul>
<li>Aliases of classes, partially applied classes, and contexts can be defined using type declarations</li>
<li>Families of classes, partially applied classes, and contexts can be defined using type synonym families</li>
</ul>
<p>Let’s visit each use case with concrete examples.</p>
<h1 id="constraint-synonyms">Constraint synonyms</h1>
<p>Since constraints are now just types, type synonyms can be reused on constraints.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Text</span> a <span class="fu">=</span> (<span class="dt">Show</span> a, <span class="dt">Read</span> a)</code></pre></div>
<p>Here is a real world example of constraint synonyms defined in the <a href="https://github.com/commercialhaskell/stack/blob/master/src/Stack/Types/StackT.hs#L67">Haskell Tool Stack</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Constraint synonym for all of the common environment instances</span>
<span class="kw">type</span> <span class="dt">HasEnv</span> r <span class="fu">=</span> (<span class="dt">HasLogOptions</span> r, <span class="dt">HasTerminal</span> r, <span class="dt">HasReExec</span> r, <span class="dt">HasSticky</span> r)

<span class="co">-- | Constraint synonym for constraints commonly satisifed by monads used in stack.</span>
<span class="kw">type</span> <span class="dt">StackM</span> r m <span class="fu">=</span>
    (<span class="dt">MonadReader</span> r m, <span class="dt">MonadIO</span> m, <span class="dt">MonadBaseControl</span> <span class="dt">IO</span> m, <span class="dt">MonadLoggerIO</span> m, <span class="dt">MonadMask</span> m, <span class="dt">HasEnv</span> r)</code></pre></div>
<p>Or we can define <code>Func</code> in terms of two type arguments <code>ctx</code> and <code>a</code> where <code>ctx</code> is a context of kind <code>* -&gt; Constraint</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Func</span> cxt a <span class="fu">=</span> cxt a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a

<span class="ot">inc ::</span> <span class="dt">Func</span> <span class="dt">Num</span> a
inc <span class="fu">=</span> (<span class="fu">+</span><span class="dv">1</span>)</code></pre></div>
<h1 id="constraint-families">Constraint families</h1>
<p>Constraint families allow constraints to be indexed by a type in the same way that type families and data families allow types to be indexed by types.</p>
<p>For example, constraint families let us define a generalized version of the <code>Monad</code> class where we can impose some constraints on the element it can contain. Wolfgang Jeltsch’s <a href="https://jeltsch.wordpress.com/2013/02/14/the-constraint-kind/">The Constraint kind</a> and Max Bolingbroke’s <a href="http://blog.omega-prime.co.uk/?p=127">Constraint Kinds for GHC</a> explain this classic example in details.</p>
<p><a href="https://hackage.haskell.org/package/rmonad">rmonad</a> provides a collection of restricted monads based on associated datatypes.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">RMonad</span> m <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">RMonadCtxt</span> m<span class="ot"> a ::</span> <span class="dt">Constraint</span>
  <span class="kw">type</span> <span class="dt">RMonadCtxt</span> m a <span class="fu">=</span> ()

<span class="ot">  return ::</span> <span class="dt">RMonadCtxt</span> m a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m a
<span class="ot">  (&gt;&gt;=) ::</span> (<span class="dt">RMonadCtxt</span> m a, <span class="dt">RMonadCtxt</span> m b) <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b

<span class="kw">instance</span> <span class="dt">RMonad</span> <span class="dt">S.Set</span> <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">RMonadCtxt</span> <span class="dt">S.Set</span> a <span class="fu">=</span> <span class="dt">Ord</span> a
  return <span class="fu">=</span> S.singleton
  mx <span class="fu">&gt;&gt;=</span> fxmy <span class="fu">=</span> S.fromList [y <span class="fu">|</span> x <span class="ot">&lt;-</span> S.toList mx, y <span class="ot">&lt;-</span> S.toList (fxmy x)]      

<span class="kw">instance</span> <span class="dt">RMonad</span> [] <span class="kw">where</span>
  return x <span class="fu">=</span> [x]
  (<span class="fu">&gt;&gt;=</span>) <span class="fu">=</span> flip concatMap</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-13-constraint-kinds.html";
    this.page.identifier = "/posts/2017-01-13-constraint-kinds.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>

</feed>
