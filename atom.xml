<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Haskell for Pragmatic Programmers</title>
    <link href="http://kseo.github.io//atom.xml" rel="self" />
    <link href="http://kseo.github.io/" />
    <id>http://kseo.github.io//atom.xml</id>
    <author>
        <name>Kwang Yul Seo</name>
        <email>kwangyul.seo@gmail.com</email>
    </author>
    <updated>2016-12-24T00:00:00Z</updated>
    <entry>
    <title>Reader monad and SKI combinators</title>
    <link href="http://kseo.github.io//posts/2016-12-24-reader-monad-and-ski-combinators.html" />
    <id>http://kseo.github.io//posts/2016-12-24-reader-monad-and-ski-combinators.html</id>
    <published>2016-12-24T00:00:00Z</published>
    <updated>2016-12-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 24, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/reader%20monad.html">reader monad</a>, <a href="/tags/ski%20combinator.html">ski combinator</a>
      
  </div>

<p>In this post, I am going to show you the relationship between the reader monad and the SKI combinators.</p>
<h1 id="reader-monad">Reader monad</h1>
<p>The reader monad encapsulates computations which read values from a shared environment. Here’s the definition of our beloved <code>Reader</code> monad.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Reader</span> r a <span class="fu">=</span> <span class="dt">Reader</span> {
<span class="ot">  runReader ::</span> r <span class="ot">-&gt;</span> a
}

<span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Reader</span> r ) <span class="kw">where</span>
  return a <span class="fu">=</span> <span class="dt">Reader</span> <span class="fu">$</span> \_ <span class="ot">-&gt;</span> a
  m <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> <span class="dt">Reader</span> <span class="fu">$</span> \r <span class="ot">-&gt;</span> runReader (k (runReader m r )) r</code></pre></div>
<p>There are actually two instances of the reader monad in Haskell. The function monad <code>(-&gt;) r</code> is also a reader monad. The definition of the function monad is just like the <code>Reader</code> monad, but without <code>newtype</code> wrapping and unwrapping.</p>
<pre><code>instance Monad ((-&gt;) r ) where
  return a = \_ -&gt; a
  m &gt;&gt;= k = \r -&gt; k (m r ) r</code></pre>
<p>From now on, I will use the function monad definition because it makes our presentation more clear. But remember these two monad definitions are isomorphic.</p>
<h1 id="ski-combinators">SKI combinators</h1>
<p><a href="https://en.wikipedia.org/wiki/Combinatory_logic">Combinatory logic</a> is a formal system without the need for variables. It was introduced by Moses Schönfinkel and Haskell Curry. All operations in lambda calculus can be encoded via <em>abstraction elimination</em> into the SKI calculus.</p>
<p>The definition of <code>S</code>, <code>K</code> and <code>I</code> are as follows:</p>
<pre><code>k :: a -&gt; b -&gt; a
k x y = x

s :: (a -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
s x y z = (x z) (y z)

i :: a -&gt; a
i x = x</code></pre>
<p>From the types of these combinators, we can see that <code>k</code> is Haskell’s <code>const</code> function and <code>i</code> is Haskell’s <code>id</code> function.</p>
<p>Technically speaking, we don’t need the I combinator to encode lambda calculus into the SKI combinators because we can encode I in terms of S and K. I is just for convenience.</p>
<h1 id="relationship">Relationship</h1>
<p>So what’s the relationship between the reader monad and the SKI combinators? Let’s look at the types of the reader monad more closely.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">return<span class="ot"> ::</span> a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> a
<span class="ot">(&gt;&gt;=) ::</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> b</code></pre></div>
<p>Can you see the similarity to the types of the combinator <code>k</code> and <code>s</code>? The function <code>return</code> is the same as <code>k</code>, but the function <code>(&gt;&gt;=)</code> is somewhat similar but not exactly the same as <code>s</code>.</p>
<p>Let’s see the <em>applicative functor</em> definition of the reader monad instead.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pure<span class="ot"> ::</span> a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> a
<span class="ot">(&lt;*&gt;) ::</span> (r <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> b</code></pre></div>
<p>Now we can see that the type of <code>(&lt;*&gt;)</code> is the same to the type of <code>s</code>. Because these functions are fully polymorphic, we don’t need to check the definition of these functions to see if they are really equivalent.</p>
<p><a href="http://www.staff.city.ac.uk/~ross/papers/Applicative.html">Conor McBride and Ross Paterson’s paper</a> also mentions this relationship briefly.</p>
<h1 id="conclusion">Conclusion</h1>
<p>We’ve just discovered that <code>k</code> and <code>s</code> combinators of SKI calculus correspond to <code>pure</code> and <code>(&lt;*&gt;)</code> functions of the reader monad. Because we can encode any lambda calculus term into SKI calculus, we can encode any lambda calculus term into the reader monad too! Amazing, isn’t it?</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Organize code using monads</title>
    <link href="http://kseo.github.io//posts/2016-12-23-organize-code-using-monads.html" />
    <id>http://kseo.github.io//posts/2016-12-23-organize-code-using-monads.html</id>
    <published>2016-12-23T00:00:00Z</published>
    <updated>2016-12-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 23, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/monad.html">monad</a>, <a href="/tags/monad%20transformer.html">monad transformer</a>, <a href="/tags/lambda%20lifting.html">lambda lifting</a>
      
  </div>

<p>Novice Haskell programmers think that monads are only for IO and stateful computations. But experienced Haskell programmers use monads to better structure their programs.</p>
<p>In this blog post, I am going to show you how we can better organize our code using monads.</p>
<h1 id="motivating-example-lambda-lifting">Motivating example: Lambda lifting</h1>
<p><em>Lambda lifting</em> is a compiler transformation which eliminates all free variables from function definitions. It is an important step in a lazy functional language because it greatly simplifies evaluation on the graph reduction machine.</p>
<p>In his <a href="https://www.microsoft.com/en-us/research/publication/a-modular-fully-lazy-lambda-lifter-in-haskell/">paper</a>, Simon Peyton Jones describes how to perform lambda lifting in a modular fashion. The lambda lifter works in three steps:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | freeVars: Annotate every node in the expression with its free variables.</span>
<span class="ot">freeVars ::</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> <span class="dt">AnnExpr</span> <span class="dt">Name</span> (<span class="dt">Set</span> <span class="dt">Name</span>)

<span class="co">-- | Abstract the free variables from each lambda abstraction, replacing the lambda abstraction with the application of the new abstraction.</span>
<span class="ot">abstract ::</span> <span class="dt">AnnExpr</span> <span class="dt">Name</span> (<span class="dt">Set</span> <span class="dt">Name</span>) <span class="ot">-&gt;</span> <span class="dt">Expression</span>

<span class="co">-- | Give a unique name to each supercombinator and collect all the supercombinator definitions.</span>
<span class="ot">collectSCs ::</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> [<span class="dt">SCDefn</span>]</code></pre></div>
<p><code>lambdaLift</code> is the composition of these three functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lambdaLift ::</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> [<span class="dt">SCDefn</span>]
lambdaLift <span class="fu">=</span> collectSCs <span class="fu">.</span> abstract <span class="fu">.</span> freeVars</code></pre></div>
<p>I am not going to explain the details of these steps in this post. Interested readers are referred to SPJ’s <a href="https://www.microsoft.com/en-us/research/publication/a-modular-fully-lazy-lambda-lifter-in-haskell/">paper</a> and <a href="https://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/">book</a>.</p>
<p>Instead, let’s dive into the last step and see how <code>collectSCs</code> is actually implemented.</p>
<h1 id="collecting-supercombinators">Collecting supercombinators</h1>
<p><code>collectSCs</code> is defined in terms of a helper function named <code>collecSC'</code> which returns both the collection of supercombinators it has found and the transformed expression. It also carries around a <em>name supply</em> as an argument and returns the depleted supply as a result because it needs to generate fresh names for supercombinators.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Gives a unique name to each supercombinator, collects all the</span>
<span class="co">-- supercombinator definitions into a single list, and introduce the</span>
<span class="co">-- $main supercombinator definition.</span>
<span class="ot">collectSCs ::</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> [<span class="dt">SCDefn</span>]
collectSCs e <span class="fu">=</span> (<span class="st">&quot;$main&quot;</span>, [], e&#39;) <span class="fu">:</span> scs
  <span class="kw">where</span>
  (_, scs, e&#39;) <span class="fu">=</span> collectSCs&#39; initialNameSupply e

<span class="ot">collectSCs&#39; ::</span> <span class="dt">NameSupply</span> <span class="ot">-&gt;</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> (<span class="dt">NameSupply</span>, [<span class="dt">SCDefn</span>], <span class="dt">Expression</span>)
collectSCs&#39; ns (<span class="dt">EConst</span> k) <span class="fu">=</span> (ns, [], <span class="dt">EConst</span> k)
collectSCs&#39; ns (<span class="dt">EVar</span> v) <span class="fu">=</span> (ns, [], <span class="dt">EVar</span> v)
collectSCs&#39; ns (<span class="dt">EAp</span> e1 e2) <span class="fu">=</span>
  (ns2, scs1 <span class="fu">++</span> scs2, <span class="dt">EAp</span> e1&#39; e2&#39;)
  <span class="kw">where</span>
  (ns1, scs1, e1&#39;) <span class="fu">=</span> collectSCs&#39; ns e1
  (ns2, scs2, e2&#39;) <span class="fu">=</span> collectSCs&#39; ns1 e2
collectSCs&#39; ns (<span class="dt">ELam</span> args body) <span class="fu">=</span>
  (ns2, (name, args, body&#39;) <span class="fu">:</span> bodySCs, <span class="dt">EConst</span> (<span class="dt">CFun</span> name))
  <span class="kw">where</span>
  (ns1, bodySCs, body&#39;) <span class="fu">=</span> collectSCs&#39; ns body
  (ns2, name) <span class="fu">=</span> newName ns1 <span class="st">&quot;SC&quot;</span>
collectSCs&#39; ns (<span class="dt">ELet</span> isRec defns body) <span class="fu">=</span>
  (ns2, scs, <span class="dt">ELet</span> isRec defns&#39; body&#39;)
  <span class="kw">where</span>
  (ns1, bodySCs, body&#39;) <span class="fu">=</span> collectSCs&#39; ns body
  ((ns2, scs), defns&#39;) <span class="fu">=</span> mapAccumL collectSCs&#39;&#39; (ns1, bodySCs) defns

  collectSCs&#39;&#39; (ns, scs) (name, rhs) <span class="fu">=</span>
    ((ns1, scs <span class="fu">++</span> scs&#39;), (name, rhs&#39;))
    <span class="kw">where</span>
    (ns1, scs&#39;, rhs&#39;) <span class="fu">=</span> collectSCs&#39; ns rhs</code></pre></div>
<p>The code is rather complex compared to what it actually does. The only place where interest things happen is lambda abstractions. It replaces lambda abstractions by names and return supercombinators.</p>
<p>The code is complex because it violates the most important software engineering principle: <em>separation of concerns</em>. <code>collectSCs</code> contains at least three orthogonal concerns:</p>
<ol style="list-style-type: decimal">
<li>Generation of fresh names</li>
<li>Accumulation of supercombinatros</li>
<li>Transformation of expressions</li>
</ol>
<h1 id="organize-code-using-monads">Organize code using monads</h1>
<p>Monads are great tools to separate concerns. For example, <code>Reader</code> monad helps us get rid of an extra argument used to pass a context. <code>Writer</code> monad frees us from the agony of returning the accumulated results in every function.</p>
<p>So let’s separate our concerns in <code>collectSCs</code>.</p>
<ol style="list-style-type: decimal">
<li><code>Supply</code> monad for fresh name generation (it’s a <code>State</code> monad in disguise)</li>
<li><code>Writer</code> monad for accumulation of supercombinators</li>
</ol>
<p>Because we need to compose two different monads, we use the monad transformer <code>SupplyT</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Collector</span> a <span class="fu">=</span> <span class="dt">SupplyT</span> (<span class="dt">Writer</span> [<span class="dt">SCDefn</span>]) a

<span class="ot">collectSCs ::</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> [<span class="dt">SCDefn</span>]
collectSCs e <span class="fu">=</span> (<span class="st">&quot;$main&quot;</span>, [], e&#39;) <span class="fu">:</span> scs
  <span class="kw">where</span>
  (e&#39;, scs) <span class="fu">=</span> runWriter <span class="fu">$</span> evalSupplyT <span class="dv">0</span> (collectSCs&#39; e)

<span class="ot">collectSCs&#39; ::</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> <span class="dt">Collector</span> <span class="dt">Expression</span>
collectSCs&#39; (<span class="dt">EConst</span> k) <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">EConst</span> k
collectSCs&#39; (<span class="dt">EVar</span> v) <span class="fu">=</span> return <span class="fu">$</span> <span class="dt">EVar</span> v
collectSCs&#39; (<span class="dt">EAp</span> e1 e2) <span class="fu">=</span> <span class="kw">do</span>
  e1&#39; <span class="ot">&lt;-</span> collectSCs&#39; e1
  e2&#39; <span class="ot">&lt;-</span> collectSCs&#39; e2
  return <span class="fu">$</span> <span class="dt">EAp</span> e1&#39; e2&#39;
collectSCs&#39; (<span class="dt">ELam</span> args body) <span class="fu">=</span> <span class="kw">do</span>
  name <span class="ot">&lt;-</span> freshName
  body&#39; <span class="ot">&lt;-</span> collectSCs&#39; body
  collect (name, args, body&#39;)
  return <span class="fu">$</span> <span class="dt">EConst</span> (<span class="dt">CFun</span> name)
collectSCs&#39; (<span class="dt">ELet</span> isRec defns body) <span class="fu">=</span> <span class="kw">do</span>
  body&#39; <span class="ot">&lt;-</span> collectSCs&#39; body
  defns&#39; <span class="ot">&lt;-</span> traverse (\(name, defn) <span class="ot">-&gt;</span> (name,) <span class="fu">&lt;$&gt;</span> collectSCs&#39; defn) defns
  return <span class="fu">$</span> <span class="dt">ELet</span> isRec defns&#39; body&#39;

<span class="ot">collect ::</span> <span class="dt">SCDefn</span> <span class="ot">-&gt;</span> <span class="dt">Collector</span> ()
collect defn <span class="fu">=</span> tell [defn]</code></pre></div>
<p>We can see that the resulting code is much more readable by removing all the clutters that not not essential to the core logic.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Pattern Synonyms</title>
    <link href="http://kseo.github.io//posts/2016-12-22-pattern-synonyms.html" />
    <id>http://kseo.github.io//posts/2016-12-22-pattern-synonyms.html</id>
    <published>2016-12-22T00:00:00Z</published>
    <updated>2016-12-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 22, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/GHC%20extension.html">GHC extension</a>, <a href="/tags/PatternSynonyms.html">PatternSynonyms</a>
      
  </div>

<p><a href="https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms">Pattern synonyms</a> allow us give names to pattern matches. It is a relatively new GHC extension which was first introduced in GHC 7.8 and further enhanced in GHC 8.0. In this post, I will show you an usage of pattern synonyms with a practical example.</p>
<p>Our assignment is to create a compiler for a toy functional language. We’ve already finished writing the parser and the type checker. It uses a small IR based on lambda calculus. Our next plan is to transform this IR into SK combinators for execution on the graph reduction machine.</p>
<p>Here’s the datatype of our IR:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="dt">Ap</span> <span class="dt">Exp</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Lambda</span> <span class="dt">VarId</span> <span class="dt">Exp</span>
         <span class="fu">|</span> <span class="dt">Fun</span> <span class="dt">FunId</span>
         <span class="fu">|</span> <span class="dt">Var</span> <span class="dt">VarId</span>
         <span class="fu">|</span> <span class="dt">Int</span> <span class="dt">Int</span></code></pre></div>
<p>The SK compilation scheme is taken from Simon Peyton Jones’s <a href="https://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/">The Implementation of Functional Programming Languages</a>. (You don’t need to understand how this actually works. Interested readers are referred to SPJ’s book.)</p>
<pre><code>C[e] compiles e to SK combinators

C[e1 e2] = C[e1] C[e2]
C[\x.e] = A x [C[e]]
C[cv] = cv

A x [f] abstracts x from f

A x [f1 f2] = S (A x [f1]) (A x [f2])
A x [x] = I
A x [cv] = K cv</code></pre>
<p>This compilation scheme can be succinctly implemented in Haskell using pattern matches on <code>Exp</code> because the scheme uses the data constructors of <code>Exp</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">compile ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
compile (<span class="dt">Ap</span> e1 e2) <span class="fu">=</span> <span class="dt">Ap</span> (compile e1) (compile e2)
compile (<span class="dt">Lambda</span> v e) <span class="fu">=</span> abstract v (compile e)
compile cv <span class="fu">=</span> cv

<span class="ot">abstract ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
abstract x (<span class="dt">Ap</span> f1 f2) <span class="fu">=</span> (abstract x f1) (abstract x f2)
abstract x (<span class="dt">Var</span> v) <span class="fu">|</span> x <span class="fu">==</span> v <span class="fu">=</span> i
abstract x (<span class="dt">Fun</span> v) <span class="fu">|</span> x <span class="fu">==</span> v <span class="fu">=</span> i
abstract _ cv <span class="fu">=</span> k cv

<span class="ot">s ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
s f g <span class="fu">=</span> <span class="dt">Ap</span> (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;S&quot;</span>) f ) g

<span class="ot">k ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
k c <span class="fu">=</span> <span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;K&quot;</span>) c

<span class="ot">i ::</span> <span class="dt">Exp</span>
i <span class="fu">=</span> <span class="dt">Fun</span> <span class="st">&quot;I&quot;</span></code></pre></div>
<p>So far so good, but we realized that this basic compilation algorithm tends to produce large combinator expressions. SPJ suggests that we can improve the scheme by introducing additional combinators <code>B</code> and <code>C</code>.</p>
<p>Reduction rules:</p>
<pre><code>B f g x = f (g x)
C f g x = f x g</code></pre>
<p>Optimization rules:</p>
<pre><code>S (K p) (K q) = K (p q)
S (K p) I = p
S (K p) q = B p q
S p (K q) = C p q</code></pre>
<p>The optimization algorithm can be implemented as pattern matches on <code>Exp</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">optimize ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
optimize (<span class="dt">Ap</span> (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;S&quot;</span>) (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;K&quot;</span>) p)) (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;K&quot;</span>) q)) <span class="fu">=</span> k (<span class="dt">Ap</span> p q)
optimize (<span class="dt">Ap</span> (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;S&quot;</span>) (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;K&quot;</span>) p)) (<span class="dt">Fun</span> <span class="st">&quot;I&quot;</span>)) <span class="fu">=</span> p
optimize (<span class="dt">Ap</span> (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;S&quot;</span>) (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;K&quot;</span>) p)) q) <span class="fu">=</span> b p q
optimize (<span class="dt">Ap</span> (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;S&quot;</span>) p) (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;K&quot;</span>) q)) <span class="fu">=</span> c p q
optimize x <span class="fu">=</span> x</code></pre></div>
<p>Unfortunately, this time the code is very complicated because <code>S</code>, <code>K</code> and <code>I</code> are not the data constructors of <code>Exp</code>. We have to sprinkle <code>Ap</code> and <code>Fun</code> all over to represent <code>S</code>, <code>K</code> and <code>I</code> combinators.</p>
<p>Can we improve it? As you might have expected, GHC’s <code>PatternSynonyms</code> extension is the rescue! It lets us make synonyms for complicated patterns like these. We can define <code>S</code>, <code>K</code> and <code>I</code> as pattern synonyms and use them as if they were data constructors.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">pattern <span class="dt">S</span> p q <span class="fu">=</span> <span class="dt">Ap</span> (<span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;S&quot;</span>) p) q
pattern <span class="dt">K</span> p <span class="fu">=</span> <span class="dt">Ap</span> (<span class="dt">Fun</span> <span class="st">&quot;K&quot;</span>) p
pattern <span class="dt">I</span> <span class="fu">=</span> <span class="dt">Fun</span> <span class="st">&quot;I&quot;</span></code></pre></div>
<p>With the help of these pattern synonyms, we can rewrite <code>optimize</code> function compactly.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">optimize ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span>
optimize (<span class="dt">S</span> (<span class="dt">K</span> p) (<span class="dt">K</span> q)) <span class="fu">=</span> k (<span class="dt">Ap</span> p q)
optimize (<span class="dt">S</span> (<span class="dt">K</span> p) <span class="dt">I</span>) <span class="fu">=</span> p
optimize (<span class="dt">S</span> (<span class="dt">K</span> p) q) <span class="fu">=</span> b p q
optimize (<span class="dt">S</span> p (<span class="dt">K</span> q)) <span class="fu">=</span> c p q
optimize x <span class="fu">=</span> x</code></pre></div>
<p>Compare the code with the optimization rules. Now they look almost the same!</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>foldl vs foldl'</title>
    <link href="http://kseo.github.io//posts/2016-12-21-foldl-vs-foldl%27.html" />
    <id>http://kseo.github.io//posts/2016-12-21-foldl-vs-foldl%27.html</id>
    <published>2016-12-21T00:00:00Z</published>
    <updated>2016-12-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 21, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/fold.html">fold</a>, <a href="/tags/recursion.html">recursion</a>
      
  </div>

<p>Chris Allen <a href="http://lorepub.com/post/2016-12-17-Haskell-Pitfalls">mentioned</a> <code>foldl</code> as one of the newbie traps in Haskell.</p>
<blockquote>
<p>foldl’ is always what you want, don’t use foldl!</p>
</blockquote>
<p>Because <code>foldl</code> always has to examine the whole list, there is no reason to make it lazy. It just uses more memory to do the same thing as <code>foldl'</code>.</p>
<p><a href="http://book.realworldhaskell.org/read/functional-programming.html">Real World Haskell</a> also recommends using <code>foldl'</code> instead of <code>foldl</code>.</p>
<blockquote>
<p>Due to the thunking behavior of foldl, it is wise to avoid this function in real programs: even if it doesn’t fail outright, it will be unnecessarily inefficient. Instead, import Data.List and use foldl’</p>
</blockquote>
<p><a href="https://wiki.haskell.org/Foldr_Foldl_Foldl&#39;#Foldl">Haskell Wiki</a> compares <code>foldr</code>, <code>foldl</code> and <code>foldl'</code> and recommends using either <code>foldr</code> or <code>foldl'</code>.</p>
<blockquote>
<p>foldl’ is the more efficient way to arrive at that result because it doesn’t build a huge thunk.</p>
</blockquote>
<p>But here comes a question. If <code>foldl'</code> is almost always better than <code>foldl</code>, why do we have <code>foldl</code> anyway? It makes sense only when the combining function is non-strict in its <em>first</em> argument. (The example is taken from the Haskell Wiki.)</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(?) ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
_ <span class="fu">?</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
x <span class="fu">?</span> y <span class="fu">=</span> x<span class="fu">*</span>y

<span class="ot">list ::</span> [<span class="dt">Int</span>]
list <span class="fu">=</span> [<span class="dv">2</span>,<span class="dv">3</span>,undefined,<span class="dv">5</span>,<span class="dv">0</span>]

okey <span class="fu">=</span> foldl (<span class="fu">?</span>) <span class="dv">1</span> list
boom <span class="fu">=</span> foldl&#39; (<span class="fu">?</span>) <span class="dv">1</span> list</code></pre></div>
<p>Evaluation of <code>okey</code>:</p>
<pre><code>okey --&gt;
foldl (?) 1 [2,3,undefined,5,0] --&gt;
foldl (?) (1 ? 2) [3,undefined,5,0] --&gt;
foldl (?) ((1 ? 2) ? 3) [undefined,5,0] --&gt;
foldl (?) (((1 ? 2) ? 3) ? undefined) [5,0] --&gt;
foldl (?) ((((1 ? 2) ? 3) ? undefined) ? 5) [0] --&gt;
foldl (?) (((((1 ? 2) ? 3) ? undefined) ? 5) ? 0) [] --&gt;
((((1 ? 2) ? 3) ? undefined) ? 5) ? 0 --&gt;
0</code></pre>
<p>Evaluation of <code>boom</code>:</p>
<pre><code>boom --&gt;
foldl&#39; (?) 1 [2,3,undefined,5,0] --&gt;
    1 ? 2 --&gt; 2
foldl&#39; (?) 2 [3,undefined,5,0] --&gt;
    2 ? 3 --&gt; 6
foldl&#39; (?) 6 [undefined,5,0] --&gt;
    6 ? undefined --&gt;
*** Exception: Prelude.undefined</code></pre>
<p>This example actually shows why <code>foldl</code> is so useless because it is hard to find a function which is non-strict in its <em>first</em> argument.</p>
<p>Many functions in Haskell are non-strict in its <em>second</em> argument and this is why <code>foldr</code> is useful. For example, <code>(&amp;&amp;)</code> is non-strict in its <em>second</em> argument and <code>and</code> can be efficiently defined using <code>foldr</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&amp;&amp;)                    ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="dt">True</span>  <span class="fu">&amp;&amp;</span> x              <span class="fu">=</span>  x
<span class="dt">False</span> <span class="fu">&amp;&amp;</span> _              <span class="fu">=</span>  <span class="dt">False</span>

and<span class="ot">                     ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
and                     <span class="fu">=</span>  foldr (<span class="fu">&amp;&amp;</span>) <span class="dt">True</span></code></pre></div>
<p>In conclusion, we should use <code>foldl'</code> by default unless we have a very compelling reason to use <code>foldl</code> instead.</p>
<p>But, wait! Let’s check how our beloved <code>sum</code> function is written. Because <code>(+)</code> is strict in both of its arguments, <code>foldl'</code> should have been used. But here’s <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.List.html#sum">the actual code</a> taken from the <code>base</code> package.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sum<span class="ot">                     ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
<span class="ot">{-# INLINE sum #-}</span>
sum                     <span class="fu">=</span>  foldl (<span class="fu">+</span>) <span class="dv">0</span></code></pre></div>
<p>OMG! There is a historical accident here. Interested readers are referred to <a href="http://www.well-typed.com/blog/90/">Fixing foldl</a> article from Well-Typed.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Non empty list</title>
    <link href="http://kseo.github.io//posts/2016-12-20-non-empty-list.html" />
    <id>http://kseo.github.io//posts/2016-12-20-non-empty-list.html</id>
    <published>2016-12-20T00:00:00Z</published>
    <updated>2016-12-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 20, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/non%20empty%20list.html">non empty list</a>, <a href="/tags/prelude.html">prelude</a>
      
  </div>

<p>Haskell is well known for its safety. A well-typed Haskell program never goes wrong. Is it true? Unfortunately, no. The type system of Haskell is great and it does catch many bugs at compile time, but Haskell’s <code>Prelude</code> is full of partial functions.</p>
<p>For example, <code>head</code> and <code>tail</code> functions of <code>Data.List</code> throws an error when an empty list is given as an argument.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> head []
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> Prelude.head<span class="fu">:</span> empty list</code></pre></div>
<p>That’s why we have a separate <a href="https://hackage.haskell.org/package/safe">safe</a> package which provides alternative safe functions such as <a href="https://www.stackage.org/haddock/lts-7.12/safe-0.3.10/Safe.html#v:headMay">headMay</a> and <a href="https://www.stackage.org/haddock/lts-7.12/safe-0.3.10/Safe.html#v:tailMay">tailMay</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> headMay []
<span class="dt">Nothing</span>
<span class="ot">it ::</span> <span class="dt">Maybe</span> a</code></pre></div>
<p>What if you know that your list is never empty? Checking the return value of <code>headMay</code> or <code>tailMay</code> soon becomes cumbersome.</p>
<p>Fortunately, Haskell <code>Prelude</code> provides <a href="https://www.stackage.org/haddock/lts-7.12/base-4.9.0.0/Data-List-NonEmpty.html">NonEmpty</a> data type which guarantees that the list is not empty. You can use <code>head</code> and <code>tail</code> functions without worrying about the partiality. It also provides many list functions such as <code>map</code>, <code>reverse</code> and <code>length</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:|</span>, <span class="fu">&lt;|</span>
<span class="kw">data</span> <span class="dt">NonEmpty</span> a <span class="fu">=</span> a <span class="fu">:|</span> [a]

head<span class="ot"> ::</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Encoding existentials</title>
    <link href="http://kseo.github.io//posts/2016-12-19-encoding-existentials.html" />
    <id>http://kseo.github.io//posts/2016-12-19-encoding-existentials.html</id>
    <published>2016-12-19T00:00:00Z</published>
    <updated>2016-12-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 19, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/existential%20type.html">existential type</a>, <a href="/tags/Church%20encoding.html">Church encoding</a>
      
  </div>

<p>Existential types are important because <a href="http://theory.stanford.edu/~jcm/papers/mitch-plotkin-88.pdf">Abstract Types Have Existential Type</a>. Haskell supports existential types though a GHC extension named <code>ExistentialQuantification</code>.</p>
<p>Here’s is an example. This code below creates an abstract data type named <code>Obj</code>. Clients of <code>Obj</code> can use only <code>show</code> function because clients can’t know the hidden representation of <code>Obj</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span>

<span class="kw">data</span> <span class="dt">Obj</span> <span class="fu">=</span> forall a<span class="fu">.</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Obj</span> a

<span class="ot">obj1 ::</span> <span class="dt">Obj</span>
obj1 <span class="fu">=</span> <span class="dt">Obj</span> <span class="st">&quot;hello&quot;</span>

<span class="ot">obj2 ::</span> <span class="dt">Obj</span>
obj2 <span class="fu">=</span> <span class="dt">Obj</span> <span class="dv">1</span>

<span class="ot">app ::</span> <span class="dt">Obj</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
app (<span class="dt">Obj</span> x) <span class="fu">=</span> show x</code></pre></div>
<p>The code is simple, but confusing because it uses <em>forall</em> instead of <em>exists</em> quantifier. It becomes more clear when we rewrite the definition of <code>Obj</code> in GADT syntax.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>

<span class="kw">data</span> <span class="dt">Obj</span> <span class="kw">where</span>
  <span class="dt">Obj</span><span class="ot"> ::</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Obj</span></code></pre></div>
<p>As the type variable <code>a</code> no longer appears on the right hand side, it is considered to be existentially quantified. Also you no longer need <code>ExistentialQuantification</code>. Existentials are subsumed by GADTs.</p>
<p>There is another way to encode existential types without <code>ExistentialQuantification</code>. Because an existential type is a pair of type and a value, we can use the <a href="https://en.wikipedia.org/wiki/Church_encoding">Church encoding</a> for a pair to represent existentials.</p>
<pre><code>{∃X,T} = ∀Y. (∀X. T→Y) → Y</code></pre>
<p>In Haskell, we need to enable <code>RankNTypes</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RankNTypes #-}</span>

<span class="kw">type</span> <span class="dt">Obj</span> <span class="fu">=</span> forall y<span class="fu">.</span> (forall x<span class="fu">.</span> (<span class="dt">Show</span> x) <span class="ot">=&gt;</span> x <span class="ot">-&gt;</span> y) <span class="ot">-&gt;</span> y

<span class="ot">obj ::</span> <span class="dt">Obj</span>
obj f <span class="fu">=</span> f <span class="st">&quot;hello&quot;</span>

<span class="ot">app ::</span> <span class="dt">Obj</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
app obj <span class="fu">=</span> obj (\x <span class="ot">-&gt;</span> show x)</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Short cut fusion</title>
    <link href="http://kseo.github.io//posts/2016-12-18-short-cut-fusion.html" />
    <id>http://kseo.github.io//posts/2016-12-18-short-cut-fusion.html</id>
    <published>2016-12-18T00:00:00Z</published>
    <updated>2016-12-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 18, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/short%20cut%20fusion.html">short cut fusion</a>, <a href="/tags/optimization.html">optimization</a>
      
  </div>

<p>Let’s start with a simple programming task. How do you add integers from 1 to 10? In Java-like language, we use a loop to calculate the sum.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="dt">int</span> sum = <span class="dv">0</span>;
<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= <span class="dv">10</span>; i++) {
  sum += i;
}</code></pre></div>
<p>In Haskell, we can succinctly performs the same calculation using <em>list comprehension</em> and <code>foldr</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</code></pre></div>
<p>The code is short and elegant, but novice Haskell programmers are often concerned with the performance of this program. Indeed, it looks very inefficient on the surface because it first generates a list of integers from 1 to 10 by allocating each con cells, and subsequently deallocates them by folding over the list.</p>
<p>So functional programming is nice, but it is not performant in real world? The answer is no! Our Haskell compiler, GHC is smart enough to optimize this pattern into a simple loop which does not require an explicit list structure. This compiler optimization technique is called <a href="https://wiki.haskell.org/Short_cut_fusion">short cut fusion</a>.</p>
<p>Let’s see how our example is actually transformed into a simple loop step by step.</p>
<p>First, the list comprehension expression <code>[1..10]</code> is a syntactic sugar for <code>from 1 10</code>. The definition of <code>from</code> is as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">from a b <span class="fu">=</span> <span class="kw">if</span> a <span class="fu">&gt;</span> b
           <span class="kw">then</span> []
           <span class="kw">else</span> a <span class="fu">:</span> from (a <span class="fu">+</span> <span class="dv">1</span>) b</code></pre></div>
<p><code>from</code> is a list producing function and we can abstract the definition over <em>cons</em> and <em>nil</em> by parameterizing both as arguments.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">from&#39; a b <span class="fu">=</span> \c n <span class="ot">-&gt;</span> <span class="kw">if</span> a <span class="fu">&gt;</span> b
                    <span class="kw">then</span> n
                    <span class="kw">else</span> c a (from&#39; (a <span class="fu">+</span> <span class="dv">1</span>) b c n)</code></pre></div>
<p>The original <code>from</code> can be obtained in terms of <code>build</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">build g <span class="fu">=</span> g (<span class="fu">:</span>) []

from a b <span class="fu">=</span> build (from&#39; a b )</code></pre></div>
<p>Here <code>build</code> is a dual of <code>foldr</code> which produces a list. You can think of <code>from'</code> as a program with ‘holes’ for constructors, and <code>build</code> plugs those holes with actual constructors.</p>
<p>The key idea of the <em>short cut fusion</em> is that <code>build</code> and <code>foldr</code> cancel each other. To put it another way, when we produce a list that will be consumed immediately, we can fuse them together.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr k z (build g) <span class="fu">=</span> g k z</code></pre></div>
<p>We now can see that the evaluation of <code>foldr (+) 0 [1..10]</code> does not produce an intermediate list.</p>
<pre><code>foldr (+) 0 (from 1 10)
=&gt; foldr (+) 0 (build (from&#39; 1 10))
=&gt; from&#39; 1 10 (+) 0
=&gt; \c n -&gt; (if 1 &gt; 10
            then n
            else c 1 (from&#39; 2 10 c n)) (+) 0
=&gt; if 1 &gt; 10
   then 0
   else 1 + (from&#39; 2 10 (+) 0)
=&gt; 1 + 2 + ... + 9 + 10 + 0
=&gt; 55</code></pre>
<p>Interested readers might like to take a look at the <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/deforestation-short-cut.pdf">original paper</a> for further information.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Type safe continuation passing style</title>
    <link href="http://kseo.github.io//posts/2016-12-17-type-safe-continuation-passing-style.html" />
    <id>http://kseo.github.io//posts/2016-12-17-type-safe-continuation-passing-style.html</id>
    <published>2016-12-17T00:00:00Z</published>
    <updated>2016-12-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 17, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/continuation%20passing%20style.html">continuation passing style</a>, <a href="/tags/type%20safe.html">type safe</a>
      
  </div>

<p>One common mistake in JavaScript programming is to forget to invoke callback in continuation passing style code. For example, the code below may never complete:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="va">async</span>.<span class="at">series</span>([
       <span class="kw">function</span> (callback) <span class="op">{</span>
           <span class="cf">if</span> (..)
              <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;invalid input&quot;</span>)<span class="op">;</span> <span class="co">// BUG: NO callback!</span>
           <span class="cf">else</span>
              <span class="at">callback</span>(<span class="kw">null</span><span class="op">,</span> <span class="st">&#39;ok&#39;</span>)<span class="op">;</span>
       <span class="op">},</span>
       <span class="kw">function</span> (callback) <span class="op">{</span>
           ...
       <span class="op">}</span>
  ]<span class="op">,</span>
  <span class="kw">function</span> (err<span class="op">,</span> result) <span class="op">{</span> <span class="at">handleErrorOrResult</span>(err<span class="op">,</span> result)<span class="op">;}</span> <span class="co">// Might not be reached</span>
)<span class="op">;</span></code></pre></div>
<p>Unfortunately, there is no systematic way to prevent this kind of bug in JavaScript. We can write tests, but it is not practical to write tests which cover all control paths.</p>
<p>But in Haskell, thanks to the powerful type system, we can turn these bugs into type errors! Let’s take a look at the definition of <code>Application</code> from <a href="http://www.yesodweb.com/book/web-application-interface">Web Application Interface</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Application</span> <span class="fu">=</span>
    <span class="dt">Request</span> <span class="ot">-&gt;</span>
    (<span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ResponseReceived</span>) <span class="ot">-&gt;</span>
    <span class="dt">IO</span> <span class="dt">ResponseReceived</span></code></pre></div>
<p>This signature of <code>Application</code> looks similar to <code>bracket</code> function. Wai uses continuation passing style to handle resource management in an exception-safe manner.</p>
<p>There is a bonus here. A valid function of <code>Application</code> must return a <code>ResponseReceived</code>, but we can’t create one by ourselves because there is no constructor available. The only way to acquire an <code>ResponseReceived</code> value is to invoke the callback. Thus if you accidentally forget to invoke callback, it automatically becomes a type error.</p>
<p>The code snippet below returns <code>responseReceived</code> returned from <code>respond</code> to make <code>application</code> type-check. Otherwise, GHC will complain about the type mismatch.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kw">import           </span><span class="dt">Blaze.ByteString.Builder</span> (fromByteString)
<span class="kw">import           </span><span class="dt">Network.HTTP.Types</span>       (status200)
<span class="kw">import           </span><span class="dt">Network.Wai</span>
<span class="kw">import           </span><span class="dt">Network.Wai.Handler.Warp</span> (run)

application _ respond <span class="fu">=</span> <span class="kw">do</span>
  msg <span class="fu">=</span> fromByteString <span class="st">&quot;Hello world!&quot;</span>
  responseReceived <span class="ot">&lt;-</span> respond <span class="fu">$</span> responseBuilder
    status200
    [(<span class="st">&quot;Content-Type&quot;</span>, <span class="st">&quot;text/plain&quot;</span>)]
    msg
  return responseReceived

main <span class="fu">=</span> run <span class="dv">3000</span> application</code></pre></div>
<p>NOTE: We could define <code>Application</code> using <code>RankNTypes</code> GHC extension instead of <code>ResponseReceived</code> type. An old version of <code>Wai</code> actually used this definition of <code>Application</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Application</span> <span class="fu">=</span> <span class="dt">Request</span> <span class="ot">-&gt;</span> (forall b<span class="fu">.</span> (<span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b)</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Datatype-generic programming with bifunctors</title>
    <link href="http://kseo.github.io//posts/2016-12-16-datatype-generic-programming-with-bifunctors.html" />
    <id>http://kseo.github.io//posts/2016-12-16-datatype-generic-programming-with-bifunctors.html</id>
    <published>2016-12-16T00:00:00Z</published>
    <updated>2016-12-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 16, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/datatype-generic.html">datatype-generic</a>, <a href="/tags/bifunctors.html">bifunctors</a>
      
  </div>

<p>In the <em>origami</em> style of programming, higher-order recursion operators such as <em>map</em>, <em>fold</em> and <em>unfold</em> captures the structure of programs. These operators have two aspects: <em>mapping</em> and <em>accumulating</em>.</p>
<p><a href="https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf">The Essence of the Iterator Pattern</a> by Jeremy Gibbons and Bruno C. d. S. Oliveira show that <em>applicative functors</em> and the corresponding <code>traverse</code> operator capture the essence of the <em>ITERATOR</em> pattern providing both mapping and accumulating. This explains why Haskell’s <code>Applicative</code> and <code>Traversable</code> work so well for many data types!</p>
<p>But in this post, instead of reiterating the paper, we are going to review one of the earlier approach which provides recursion operators in datatype-generic way. Surprisingly, what we need is only <a href="https://hackage.haskell.org/package/bifunctors">bifunctors</a>.</p>
<p>This post is in literate Haskell, so let’s start with a list of GHC extensions and imports:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE DeriveFunctor #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Bifunctor</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Bifunctor.TH</span></code></pre></div>
<p><code>Data.Bifunctor.TH</code> provides a <code>TemplateHaskell</code> macro <code>deriveBifunctor</code>, which automatically derives the <code>Bifunctor</code> instance. This is possible because all sum-of-product data types induce bifunctors. Here’s our favorite list data type.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">ListF</span> a r <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a r <span class="kw">deriving</span> <span class="dt">Functor</span>
<span class="ot">&gt;</span> deriveBifunctor <span class="ch">&#39;&#39;</span><span class="dt">ListF</span></code></pre></div>
<p><code>Fix</code> is the fixed point of a <code>Bifunctor</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">Fix</span> s a <span class="fu">=</span> <span class="dt">In</span> {<span class="ot"> out ::</span> s a (<span class="dt">Fix</span> s a) }</code></pre></div>
<p>Then we define <code>List</code> as a fixed point of <code>ListF</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">List</span> <span class="fu">=</span> <span class="dt">Fix</span> <span class="dt">ListF</span></code></pre></div>
<p>To map over an arbitrary data type defined by <code>Fix</code>, we should be able to define a <code>Functor</code> instance of <code>Fix s</code>. It seems like a hard problem at first, but with enough patience and time it is actually possible to define <code>fmap</code> in terms of <code>bimap</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Bifunctor</span> s <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Fix</span> s) <span class="kw">where</span>
<span class="ot">&gt;</span>   fmap f <span class="fu">=</span> <span class="dt">In</span> <span class="fu">.</span> bimap f (fmap f) <span class="fu">.</span> out</code></pre></div>
<p>This looks magical, but we can comprehend the definition by inspecting the types of its components.</p>
<ul>
<li>out :: Fix s a -&gt; s a (Fix s a)</li>
<li>In :: s a (Fix s a) -&gt; Fix s a</li>
<li>fmap :: (a -&gt; b) -&gt; Fix s a -&gt; Fix s b</li>
<li>bimap :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; s a c -&gt; s b d</li>
</ul>
<p>The type of <code>fmap f</code> is <code>Fix s a -&gt; Fix s b</code>, so the type of <code>bimap f (fmap f)</code> is <code>s a (Fix s a) -&gt; s b (Fix s b)</code>. Now we can compose these:</p>
<ul>
<li>out :: Fix s a -&gt; s a (Fix s a)</li>
<li>bimap f (fmap f) :: s a -&gt; s a (Fix s a) -&gt; s b (Fix s b)</li>
<li>In :: s b (Fix s b) -&gt; Fix s b</li>
</ul>
<p>Thus,</p>
<ul>
<li>In . bitmap f (fmap f) . out :: Fix s a -&gt; Fix s b</li>
</ul>
<p><code>fold</code> and <code>unfold</code> can be defined similiarly:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fold ::</span> <span class="dt">Bifunctor</span> s <span class="ot">=&gt;</span> (s a b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Fix</span> s a <span class="ot">-&gt;</span> b
<span class="ot">&gt;</span> fold f <span class="fu">=</span> f <span class="fu">.</span> bimap id (fold f) <span class="fu">.</span> out
<span class="ot">&gt;</span> 
<span class="ot">&gt; unfold ::</span> <span class="dt">Bifunctor</span> s <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> s a b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Fix</span> s a
<span class="ot">&gt;</span> unfold f <span class="fu">=</span> <span class="dt">In</span> <span class="fu">.</span> bimap id (unfold f) <span class="fu">.</span> f</code></pre></div>
<p>Here’s how we use <code>fmap</code> on <code>List</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; nil ::</span> <span class="dt">List</span> a
<span class="ot">&gt;</span> nil <span class="fu">=</span> <span class="dt">In</span> <span class="dt">Nil</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a
<span class="ot">&gt;</span> cons x xs <span class="fu">=</span> <span class="dt">In</span> (<span class="dt">Cons</span> x xs)
<span class="ot">&gt;</span> 
<span class="ot">&gt; l ::</span> <span class="dt">List</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> l <span class="fu">=</span> fmap (<span class="fu">+</span><span class="dv">1</span>) (cons <span class="dv">3</span> (cons <span class="dv">4</span> nil))</code></pre></div>
<p>Tada! These recursive operators are indeed datatype-generic because the defintion of <code>fmap</code>, <code>fold</code> and <code>unfold</code> never use the specific data type we defined. They use only <code>bimap</code> which is parameterized by the shape <code>s</code> of the data. It means we can reuse these functions for other data types without reimplementing them for each type. For example, here’s a definition of <code>Tree</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">TreeF</span> a r <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Branch</span> a r r <span class="kw">deriving</span> <span class="dt">Functor</span>
<span class="ot">&gt;</span> deriveBifunctor <span class="ch">&#39;&#39;</span><span class="dt">TreeF</span>
<span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Tree</span> <span class="fu">=</span> <span class="dt">Fix</span> <span class="dt">TreeF</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; leaf ::</span> <span class="dt">Tree</span> a
<span class="ot">&gt;</span> leaf <span class="fu">=</span> <span class="dt">In</span> <span class="dt">Leaf</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; branch ::</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a
<span class="ot">&gt;</span> branch x l r<span class="fu">=</span> <span class="dt">In</span> (<span class="dt">Branch</span> x l r)</code></pre></div>
<p>To map over a tree, we can just use the same <code>fmap</code> function we defined above!</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; t ::</span> <span class="dt">Tree</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> t <span class="fu">=</span> fmap (<span class="fu">+</span><span class="dv">1</span>) (branch <span class="dv">3</span> leaf (branch <span class="dv">4</span> leaf leaf))</code></pre></div>
<p>This technique of using <em>bifunctors</em> to implement datatype-generic recursive functions is mostly superseded by <code>Applicative</code> and <code>Traversable</code> in Haskell, but I think it is still a good example which shows the real power of <em>bifunctors</em>!</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Golden tests are tasty</title>
    <link href="http://kseo.github.io//posts/2016-12-15-golden-tests-are-tasty.html" />
    <id>http://kseo.github.io//posts/2016-12-15-golden-tests-are-tasty.html</id>
    <published>2016-12-15T00:00:00Z</published>
    <updated>2016-12-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 15, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/tasty.html">tasty</a>, <a href="/tags/golden.html">golden</a>, <a href="/tags/test.html">test</a>
      
  </div>

<p>Haskell programmers love property based testing thanks to glorious <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a> library. Once we specify the program behavior in terms of properties, <em>QuickCheck</em> generates random test cases and checks if the given properties hold for these test cases. Once it finds a failing test case, it automatically shrinks the test case to the minimal value which still violates the property.</p>
<p>However, we, Haskell programmers, often forget that there are other test methodologies. In this post, I am going to introduce <em>gold testing</em> provided by <a href="https://hackage.haskell.org/package/tasty-golden">tasty-golden</a> package.</p>
<p>The idea is simple. A golden test is just an <code>IO</code> action that writes its result to a file. To pass the test, this output file should be identical to the corresponding <em>golden</em> file, which contains the correct result for the test.</p>
<h1 id="a-cast-study-untyped-lambda-calculus">A cast study: untyped lambda calculus</h1>
<p>We have an <a href="https://github.com/kseo/untyped">untyped lambda calculus implementation</a>. It provides <code>run</code> function which evaluates the given lambda calculus script to a <code>String</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">run ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">String</span></code></pre></div>
<p>For testing, we would like to check if this function works correctly for various input scripts. To enumerate a few test scenarios:</p>
<ul>
<li><code>\x.x</code> evaluates to itself because there is no redex in the term.</li>
<li><code>(\x.x)(\x.x)</code> evaluates to <code>(\x.x)</code> by substitution.</li>
<li><code>\x.y</code> throws an error because <code>y</code> is an unbound variable.</li>
</ul>
<p>Of course, we can manually create a test case for each scenario, but this is boring and repetitive. Instead of writing test cases in Haskell, let’s create a script file and its expected output file for each input:</p>
<ul>
<li><p>t1.lc</p>
<pre><code>\x.x</code></pre></li>
<li><p>t1.golden</p>
<pre><code>\x.x</code></pre></li>
<li><p>t2.lc</p>
<pre><code>(\x.x)(\x.x)</code></pre></li>
<li><p>t2.golden</p>
<pre><code>(\x.x)</code></pre></li>
<li><p>t3.lc</p>
<pre><code>(\x.y)</code></pre></li>
<li><p>t3.golden</p>
<pre><code>&quot;untyped lambda-calculus&quot; (line 2, column 1):
unexpected end of input
The variable y has not been bound</code></pre></li>
</ul>
<p>Once we have these files ready, what golden tests do is to read each script file and evaluates the script, and compares the output with the expected output contained in the expected file. If the actual output and the expected output are different, the test fails. We call the expected output file as the <em>golden file</em>.</p>
<p>For convenience, tasty-golden generates the golden files if they are not available. So you don’t need to create golden files initially. You also can regenerate the golden files using the <code>--accept</code> flag. This is useful when you know that your change is valid and want to rebase all the golden files accordingly.</p>
<h1 id="implementation">Implementation</h1>
<p>Here’s the actual code which performs golden tests as described above. <code>listTestFiles</code> enumerates all the script files under <code>test/tests</code> directory and <code>mkGoldenTest</code> creates a golden test from the script file using <code>goldenVsString</code> function provided by tasty-golden.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Language.LambdaCalculus</span>

<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">as</span> <span class="dt">BS</span>
<span class="kw">import </span><span class="dt">System.FilePath</span>
<span class="kw">import </span><span class="dt">System.FilePath.Glob</span>

<span class="kw">import </span><span class="dt">Test.Tasty</span>
<span class="kw">import </span><span class="dt">Test.Tasty.Golden</span> <span class="kw">as</span> <span class="dt">G</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  paths <span class="ot">&lt;-</span> listTestFiles
  goldens <span class="ot">&lt;-</span> mapM mkGoldenTest paths
  defaultMain (testGroup <span class="st">&quot;Tests&quot;</span> goldens)

<span class="ot">listTestFiles ::</span> <span class="dt">IO</span> [FilePath]
listTestFiles <span class="fu">=</span> globDir1 pat <span class="st">&quot;test/tests&quot;</span>
  <span class="kw">where</span> pat <span class="fu">=</span> compile <span class="st">&quot;*.lc&quot;</span>

<span class="ot">mkGoldenTest ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">TestTree</span>
mkGoldenTest path <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> testName <span class="fu">=</span> takeBaseName path
  <span class="kw">let</span> goldenPath <span class="fu">=</span> replaceExtension path <span class="st">&quot;.golden&quot;</span>
  return (goldenVsString testName goldenPath action)
  <span class="kw">where</span>
<span class="ot">    action ::</span> <span class="dt">IO</span> <span class="dt">BS.ByteString</span>
    action <span class="fu">=</span> <span class="kw">do</span>
      script <span class="ot">&lt;-</span> readFile path
      <span class="kw">let</span> actual <span class="fu">=</span> either id id (run script)
      return (BS.pack actual)</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>

</feed>
