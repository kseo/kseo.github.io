<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Haskell for Pragmatic Programmers</title>
    <link href="http://kseo.github.io//atom.xml" rel="self" />
    <link href="http://kseo.github.io/" />
    <id>http://kseo.github.io//atom.xml</id>
    <author>
        <name>Kwang Yul Seo</name>
        <email>kwangyul.seo@gmail.com</email>
    </author>
    <updated>2016-12-21T00:00:00Z</updated>
    <entry>
    <title>foldl vs foldl'</title>
    <link href="http://kseo.github.io//posts/2016-12-21-foldl-vs-foldl%27.html" />
    <id>http://kseo.github.io//posts/2016-12-21-foldl-vs-foldl%27.html</id>
    <published>2016-12-21T00:00:00Z</published>
    <updated>2016-12-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 21, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/fold.html">fold</a>, <a href="/tags/recursion.html">recursion</a>
      
  </div>

<p>Chris Allen <a href="http://lorepub.com/post/2016-12-17-Haskell-Pitfalls">mentioned</a> <code>foldl</code> as one of the newbie traps in Haskell.</p>
<blockquote>
<p>foldl’ is always what you want, don’t use foldl!</p>
</blockquote>
<p>Because <code>foldl</code> always has to examine the whole list, there is no reason to make it lazy. It just uses more memory to do the same thing as <code>foldl'</code>.</p>
<p><a href="http://book.realworldhaskell.org/read/functional-programming.html">Real World Haskell</a> also recommends using <code>foldl'</code> instead of <code>foldl</code>.</p>
<blockquote>
<p>Due to the thunking behavior of foldl, it is wise to avoid this function in real programs: even if it doesn’t fail outright, it will be unnecessarily inefficient. Instead, import Data.List and use foldl’</p>
</blockquote>
<p><a href="https://wiki.haskell.org/Foldr_Foldl_Foldl&#39;#Foldl">Haskell Wiki</a> compares <code>foldr</code>, <code>foldl</code> and <code>foldl'</code> and recommends using either <code>foldr</code> or <code>foldl'</code>.</p>
<blockquote>
<p>foldl’ is the more efficient way to arrive at that result because it doesn’t build a huge thunk.</p>
</blockquote>
<p>But here comes a question. If <code>foldl'</code> is almost always better than <code>foldl</code>, why do we have <code>foldl</code> anyway? It makes sense only when the combining function is non-strict in its <em>first</em> argument. (The example is taken from the Haskell Wiki.)</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(?) ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
_ <span class="fu">?</span> <span class="dv">0</span> <span class="fu">=</span> <span class="dv">0</span>
x <span class="fu">?</span> y <span class="fu">=</span> x<span class="fu">*</span>y

<span class="ot">list ::</span> [<span class="dt">Int</span>]
list <span class="fu">=</span> [<span class="dv">2</span>,<span class="dv">3</span>,undefined,<span class="dv">5</span>,<span class="dv">0</span>]

okey <span class="fu">=</span> foldl (<span class="fu">?</span>) <span class="dv">1</span> list
boom <span class="fu">=</span> foldl&#39; (<span class="fu">?</span>) <span class="dv">1</span> list</code></pre></div>
<p>Evaluation of <code>okey</code>:</p>
<pre><code>okey --&gt;
foldl (?) 1 [2,3,undefined,5,0] --&gt;
foldl (?) (1 ? 2) [3,undefined,5,0] --&gt;
foldl (?) ((1 ? 2) ? 3) [undefined,5,0] --&gt;
foldl (?) (((1 ? 2) ? 3) ? undefined) [5,0] --&gt;
foldl (?) ((((1 ? 2) ? 3) ? undefined) ? 5) [0] --&gt;
foldl (?) (((((1 ? 2) ? 3) ? undefined) ? 5) ? 0) [] --&gt;
((((1 ? 2) ? 3) ? undefined) ? 5) ? 0 --&gt;
0</code></pre>
<p>Evaluation of <code>boom</code>:</p>
<pre><code>boom --&gt;
foldl&#39; (?) 1 [2,3,undefined,5,0] --&gt;
    1 ? 2 --&gt; 2
foldl&#39; (?) 2 [3,undefined,5,0] --&gt;
    2 ? 3 --&gt; 6
foldl&#39; (?) 6 [undefined,5,0] --&gt;
    6 ? undefined --&gt;
*** Exception: Prelude.undefined</code></pre>
<p>This example actually shows why <code>foldl</code> is so useless because it is hard to find a function which is non-strict in its <em>first</em> argument.</p>
<p>Many functions in Haskell are non-strict in its <em>second</em> argument and this is why <code>foldr</code> is useful. For example, <code>(&amp;&amp;)</code> is non-strict in its <em>second</em> argument and <code>and</code> can be efficiently defined using <code>foldr</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&amp;&amp;)                    ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="dt">True</span>  <span class="fu">&amp;&amp;</span> x              <span class="fu">=</span>  x
<span class="dt">False</span> <span class="fu">&amp;&amp;</span> _              <span class="fu">=</span>  <span class="dt">False</span>

and<span class="ot">                     ::</span> [<span class="dt">Bool</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
and                     <span class="fu">=</span>  foldr (<span class="fu">&amp;&amp;</span>) <span class="dt">True</span></code></pre></div>
<p>In conclusion, we should always use <code>foldl'</code> unless we have a very compelling reason to use <code>foldl</code> instead.</p>
<p>But, wait! Let’s check how our beloved <code>sum</code> function is written. Because <code>(+)</code> is strict in both of its arguments, <code>foldl'</code> should have been used. But here’s <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.List.html#sum">the actual code</a> taken from the <code>base</code> package.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sum<span class="ot">                     ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a
<span class="ot">{-# INLINE sum #-}</span>
sum                     <span class="fu">=</span>  foldl (<span class="fu">+</span>) <span class="dv">0</span></code></pre></div>
<p>OMG!</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Non empty list</title>
    <link href="http://kseo.github.io//posts/2016-12-20-non-empty-list.html" />
    <id>http://kseo.github.io//posts/2016-12-20-non-empty-list.html</id>
    <published>2016-12-20T00:00:00Z</published>
    <updated>2016-12-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 20, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/non%20empty%20list.html">non empty list</a>, <a href="/tags/prelude.html">prelude</a>
      
  </div>

<p>Haskell is well known for its safety. A well-typed Haskell program never goes wrong. Is it true? Unfortunately, no. The type system of Haskell is great and it does catch many bugs at compile time, but Haskell’s <code>Prelude</code> is full of partial functions.</p>
<p>For example, <code>head</code> and <code>tail</code> functions of <code>Data.List</code> throws an error when an empty list is given as an argument.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> head []
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> Prelude.head<span class="fu">:</span> empty list</code></pre></div>
<p>That’s why we have a separate <a href="https://hackage.haskell.org/package/safe">safe</a> package which provides alternative safe functions such as <a href="https://www.stackage.org/haddock/lts-7.12/safe-0.3.10/Safe.html#v:headMay">headMay</a> and <a href="https://www.stackage.org/haddock/lts-7.12/safe-0.3.10/Safe.html#v:tailMay">tailMay</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">λ<span class="fu">&gt;</span> headMay []
<span class="dt">Nothing</span>
<span class="ot">it ::</span> <span class="dt">Maybe</span> a</code></pre></div>
<p>What if you know that your list is never empty? Checking the return value of <code>headMay</code> or <code>tailMay</code> soon becomes cumbersome.</p>
<p>Fortunately, Haskell <code>Prelude</code> provides <a href="https://www.stackage.org/haddock/lts-7.12/base-4.9.0.0/Data-List-NonEmpty.html">NonEmpty</a> data type which guarantees that the list is not empty. You can use <code>head</code> and <code>tail</code> functions without worrying about the partiality. It also provides many list functions such as <code>map</code>, <code>reverse</code> and <code>length</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:|</span>, <span class="fu">&lt;|</span>
<span class="kw">data</span> <span class="dt">NonEmpty</span> a <span class="fu">=</span> a <span class="fu">:|</span> [a]

head<span class="ot"> ::</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Encoding existentials</title>
    <link href="http://kseo.github.io//posts/2016-12-19-encoding-existentials.html" />
    <id>http://kseo.github.io//posts/2016-12-19-encoding-existentials.html</id>
    <published>2016-12-19T00:00:00Z</published>
    <updated>2016-12-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 19, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/existential%20type.html">existential type</a>, <a href="/tags/Church%20encoding.html">Church encoding</a>
      
  </div>

<p>Existential types are important because <a href="http://theory.stanford.edu/~jcm/papers/mitch-plotkin-88.pdf">Abstract Types Have Existential Type</a>. Haskell supports existential types though a GHC extension named <code>ExistentialQuantification</code>.</p>
<p>Here’s is an example. This code below creates an abstract data type named <code>Obj</code>. Clients of <code>Obj</code> can use only <code>show</code> function because clients can’t know the hidden representation of <code>Obj</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span>

<span class="kw">data</span> <span class="dt">Obj</span> <span class="fu">=</span> forall a<span class="fu">.</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Obj</span> a

<span class="ot">obj1 ::</span> <span class="dt">Obj</span>
obj1 <span class="fu">=</span> <span class="dt">Obj</span> <span class="st">&quot;hello&quot;</span>

<span class="ot">obj2 ::</span> <span class="dt">Obj</span>
obj2 <span class="fu">=</span> <span class="dt">Obj</span> <span class="dv">1</span>

<span class="ot">app ::</span> <span class="dt">Obj</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
app (<span class="dt">Obj</span> x) <span class="fu">=</span> show x</code></pre></div>
<p>The code is simple, but confusing because it uses <em>forall</em> instead of <em>exists</em> quantifier. It becomes more clear when we rewrite the definition of <code>Obj</code> in GADT syntax.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span>

<span class="kw">data</span> <span class="dt">Obj</span> <span class="kw">where</span>
  <span class="dt">Obj</span><span class="ot"> ::</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Obj</span></code></pre></div>
<p>As the type variable <code>a</code> no longer appears on the right hand side, it is considered to be existentially quantified. Also you no longer need <code>ExistentialQuantification</code>. Existentials are subsumed by GADTs.</p>
<p>There is another way to encode existential types without <code>ExistentialQuantification</code>. Because an existential type is a pair of type and a value, we can use the <a href="https://en.wikipedia.org/wiki/Church_encoding">Church encoding</a> for a pair to represent existentials.</p>
<pre><code>{∃X,T} = ∀Y. (∀X. T→Y) → Y</code></pre>
<p>In Haskell, we need to enable <code>RankNTypes</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RankNTypes #-}</span>

<span class="kw">type</span> <span class="dt">Obj</span> <span class="fu">=</span> forall y<span class="fu">.</span> (forall x<span class="fu">.</span> (<span class="dt">Show</span> x) <span class="ot">=&gt;</span> x <span class="ot">-&gt;</span> y) <span class="ot">-&gt;</span> y

<span class="ot">obj ::</span> <span class="dt">Obj</span>
obj f <span class="fu">=</span> f <span class="st">&quot;hello&quot;</span>

<span class="ot">app ::</span> <span class="dt">Obj</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
app obj <span class="fu">=</span> obj (\x <span class="ot">-&gt;</span> show x)</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Short cut fusion</title>
    <link href="http://kseo.github.io//posts/2016-12-18-short-cut-fusion.html" />
    <id>http://kseo.github.io//posts/2016-12-18-short-cut-fusion.html</id>
    <published>2016-12-18T00:00:00Z</published>
    <updated>2016-12-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 18, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/short%20cut%20fusion.html">short cut fusion</a>, <a href="/tags/optimization.html">optimization</a>
      
  </div>

<p>Let’s start with a simple programming task. How do you add integers from 1 to 10? In Java-like language, we use a loop to calculate the sum.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="dt">int</span> sum = <span class="dv">0</span>;
<span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= <span class="dv">10</span>; i++) {
  sum += i;
}</code></pre></div>
<p>In Haskell, we can succinctly performs the same calculation using <em>list comprehension</em> and <code>foldr</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr (<span class="fu">+</span>) <span class="dv">0</span> [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</code></pre></div>
<p>The code is short and elegant, but novice Haskell programmers are often concerned with the performance of this program. Indeed, it looks very inefficient on the surface because it first generates a list of integers from 1 to 10 by allocating each con cells, and subsequently deallocates them by folding over the list.</p>
<p>So functional programming is nice, but it is not performant in real world? The answer is no! Our Haskell compiler, GHC is smart enough to optimize this pattern into a simple loop which does not require an explicit list structure. This compiler optimization technique is called <a href="https://wiki.haskell.org/Short_cut_fusion">short cut fusion</a>.</p>
<p>Let’s see how our example is actually transformed into a simple loop step by step.</p>
<p>First, the list comprehension expression <code>[1..10]</code> is a syntactic sugar for <code>from 1 10</code>. The definition of <code>from</code> is as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">from a b <span class="fu">=</span> <span class="kw">if</span> a <span class="fu">&gt;</span> b
           <span class="kw">then</span> []
           <span class="kw">else</span> a <span class="fu">:</span> from (a <span class="fu">+</span> <span class="dv">1</span>) b</code></pre></div>
<p><code>from</code> is a list producing function and we can abstract the definition over <em>cons</em> and <em>nil</em> by parameterizing both as arguments.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">from&#39; a b <span class="fu">=</span> \c n <span class="ot">-&gt;</span> <span class="kw">if</span> a <span class="fu">&gt;</span> b
                    <span class="kw">then</span> n
                    <span class="kw">else</span> c a (from&#39; (a <span class="fu">+</span> <span class="dv">1</span>) b c n)</code></pre></div>
<p>The original <code>from</code> can be obtained in terms of <code>build</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">build g <span class="fu">=</span> g (<span class="fu">:</span>) []

from a b <span class="fu">=</span> build (from&#39; a b )</code></pre></div>
<p>Here <code>build</code> is a dual of <code>foldr</code> which produces a list. You can think of <code>from'</code> as a program with ‘holes’ for constructors, and <code>build</code> plugs those holes with actual constructors.</p>
<p>The key idea of the <em>short cut fusion</em> is that <code>build</code> and <code>foldr</code> cancel each other. To put it another way, when we produce a list that will be consumed immediately, we can fuse them together.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr k z (build g) <span class="fu">=</span> g k z</code></pre></div>
<p>We now can see that the evaluation of <code>foldr (+) 0 [1..10]</code> does not produce an intermediate list.</p>
<pre><code>foldr (+) 0 (from 1 10)
=&gt; foldr (+) 0 (build (from&#39; 1 10))
=&gt; from&#39; 1 10 (+) 0
=&gt; \c n -&gt; (if 1 &gt; 10
            then n
            else c 1 (from&#39; 2 10 c n)) (+) 0
=&gt; if 1 &gt; 10
   then 0
   else 1 + (from&#39; 2 10 (+) 0)
=&gt; 1 + 2 + ... + 9 + 10 + 0
=&gt; 55</code></pre>
<p>Interested readers might like to take a look at the <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/deforestation-short-cut.pdf">original paper</a> for further information.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Type safe continuation passing style</title>
    <link href="http://kseo.github.io//posts/2016-12-17-type-safe-continuation-passing-style.html" />
    <id>http://kseo.github.io//posts/2016-12-17-type-safe-continuation-passing-style.html</id>
    <published>2016-12-17T00:00:00Z</published>
    <updated>2016-12-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 17, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/continuation%20passing%20style.html">continuation passing style</a>, <a href="/tags/type%20safe.html">type safe</a>
      
  </div>

<p>One common mistake in JavaScript programming is to forget to invoke callback in continuation passing style code. For example, the code below may never complete:</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="va">async</span>.<span class="at">series</span>([
       <span class="kw">function</span> (callback) <span class="op">{</span>
           <span class="cf">if</span> (..)
              <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;invalid input&quot;</span>)<span class="op">;</span> <span class="co">// BUG: NO callback!</span>
           <span class="cf">else</span>
              <span class="at">callback</span>(<span class="kw">null</span><span class="op">,</span> <span class="st">&#39;ok&#39;</span>)<span class="op">;</span>
       <span class="op">},</span>
       <span class="kw">function</span> (callback) <span class="op">{</span>
           ...
       <span class="op">}</span>
  ]<span class="op">,</span>
  <span class="kw">function</span> (err<span class="op">,</span> result) <span class="op">{</span> <span class="at">handleErrorOrResult</span>(err<span class="op">,</span> result)<span class="op">;}</span> <span class="co">// Might not be reached</span>
)<span class="op">;</span></code></pre></div>
<p>Unfortunately, there is no systematic way to prevent this kind of bug in JavaScript. We can write tests, but it is not practical to write tests which cover all control paths.</p>
<p>But in Haskell, thanks to the powerful type system, we can turn these bugs into type errors! Let’s take a look at the definition of <code>Application</code> from <a href="http://www.yesodweb.com/book/web-application-interface">Web Application Interface</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Application</span> <span class="fu">=</span>
    <span class="dt">Request</span> <span class="ot">-&gt;</span>
    (<span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ResponseReceived</span>) <span class="ot">-&gt;</span>
    <span class="dt">IO</span> <span class="dt">ResponseReceived</span></code></pre></div>
<p>This signature of <code>Application</code> looks similar to <code>bracket</code> function. Wai uses continuation passing style to handle resource management in an exception-safe manner.</p>
<p>There is a bonus here. A valid function of <code>Application</code> must return a <code>ResponseReceived</code>, but we can’t create one by ourselves because there is no constructor available. The only way to acquire an <code>ResponseReceived</code> value is to invoke the callback. Thus if you accidentally forget to invoke callback, it automatically becomes a type error.</p>
<p>The code snippet below returns <code>responseReceived</code> returned from <code>respond</code> to make <code>application</code> type-check. Otherwise, GHC will complain about the type mismatch.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kw">import           </span><span class="dt">Blaze.ByteString.Builder</span> (fromByteString)
<span class="kw">import           </span><span class="dt">Network.HTTP.Types</span>       (status200)
<span class="kw">import           </span><span class="dt">Network.Wai</span>
<span class="kw">import           </span><span class="dt">Network.Wai.Handler.Warp</span> (run)

application _ respond <span class="fu">=</span> <span class="kw">do</span>
  msg <span class="fu">=</span> fromByteString <span class="st">&quot;Hello world!&quot;</span>
  responseReceived <span class="ot">&lt;-</span> respond <span class="fu">$</span> responseBuilder
    status200
    [(<span class="st">&quot;Content-Type&quot;</span>, <span class="st">&quot;text/plain&quot;</span>)]
    msg
  return responseReceived

main <span class="fu">=</span> run <span class="dv">3000</span> application</code></pre></div>
<p>NOTE: We could define <code>Application</code> using <code>RankNTypes</code> GHC extension instead of <code>ResponseReceived</code> type. An old version of <code>Wai</code> actually used this definition of <code>Application</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Application</span> <span class="fu">=</span> <span class="dt">Request</span> <span class="ot">-&gt;</span> (forall b<span class="fu">.</span> (<span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b)</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Datatype-generic programming with bifunctors</title>
    <link href="http://kseo.github.io//posts/2016-12-16-datatype-generic-programming-with-bifunctors.html" />
    <id>http://kseo.github.io//posts/2016-12-16-datatype-generic-programming-with-bifunctors.html</id>
    <published>2016-12-16T00:00:00Z</published>
    <updated>2016-12-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 16, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/datatype-generic.html">datatype-generic</a>, <a href="/tags/bifunctors.html">bifunctors</a>
      
  </div>

<p>In the <em>origami</em> style of programming, higher-order recursion operators such as <em>map</em>, <em>fold</em> and <em>unfold</em> captures the structure of programs. These operators have two aspects: <em>mapping</em> and <em>accumulating</em>.</p>
<p><a href="https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf">The Essence of the Iterator Pattern</a> by Jeremy Gibbons and Bruno C. d. S. Oliveira show that <em>applicative functors</em> and the corresponding <code>traverse</code> operator capture the essence of the <em>ITERATOR</em> pattern providing both mapping and accumulating. This explains why Haskell’s <code>Applicative</code> and <code>Traversable</code> work so well for many data types!</p>
<p>But in this post, instead of reiterating the paper, we are going to review one of the earlier approach which provides recursion operators in datatype-generic way. Surprisingly, what we need is only <a href="https://hackage.haskell.org/package/bifunctors">bifunctors</a>.</p>
<p>This post is in literate Haskell, so let’s start with a list of GHC extensions and imports:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE DeriveFunctor #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE TemplateHaskell #-}</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Bifunctor</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Bifunctor.TH</span></code></pre></div>
<p><code>Data.Bifunctor.TH</code> provides a <code>TemplateHaskell</code> macro <code>deriveBifunctor</code>, which automatically derives the <code>Bifunctor</code> instance. This is possible because all sum-of-product data types induce bifunctors. Here’s our favorite list data type.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">ListF</span> a r <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a r <span class="kw">deriving</span> <span class="dt">Functor</span>
<span class="ot">&gt;</span> deriveBifunctor <span class="ch">&#39;&#39;</span><span class="dt">ListF</span></code></pre></div>
<p><code>Fix</code> is the fixed point of a <code>Bifunctor</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">Fix</span> s a <span class="fu">=</span> <span class="dt">In</span> {<span class="ot"> out ::</span> s a (<span class="dt">Fix</span> s a) }</code></pre></div>
<p>Then we define <code>List</code> as a fixed point of <code>ListF</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">List</span> <span class="fu">=</span> <span class="dt">Fix</span> <span class="dt">ListF</span></code></pre></div>
<p>To map over an arbitrary data type defined by <code>Fix</code>, we should be able to define a <code>Functor</code> instance of <code>Fix s</code>. It seems like a hard problem at first, but with enough patience and time it is actually possible to define <code>fmap</code> in terms of <code>bimap</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Bifunctor</span> s <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Fix</span> s) <span class="kw">where</span>
<span class="ot">&gt;</span>   fmap f <span class="fu">=</span> <span class="dt">In</span> <span class="fu">.</span> bimap f (fmap f) <span class="fu">.</span> out</code></pre></div>
<p>This looks magical, but we can comprehend the definition by inspecting the types of its components.</p>
<ul>
<li>out :: Fix s a -&gt; s a (Fix s a)</li>
<li>In :: s a (Fix s a) -&gt; Fix s a</li>
<li>fmap :: (a -&gt; b) -&gt; Fix s a -&gt; Fix s b</li>
<li>bimap :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; s a c -&gt; s b d</li>
</ul>
<p>The type of <code>fmap f</code> is <code>Fix s a -&gt; Fix s b</code>, so the type of <code>bimap f (fmap f)</code> is <code>s a (Fix s a) -&gt; s b (Fix s b)</code>. Now we can compose these:</p>
<ul>
<li>out :: Fix s a -&gt; s a (Fix s a)</li>
<li>bimap f (fmap f) :: s a -&gt; s a (Fix s a) -&gt; s b (Fix s b)</li>
<li>In :: s b (Fix s b) -&gt; Fix s b</li>
</ul>
<p>Thus,</p>
<ul>
<li>In . bitmap f (fmap f) . out :: Fix s a -&gt; Fix s b</li>
</ul>
<p><code>fold</code> and <code>unfold</code> can be defined similiarly:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fold ::</span> <span class="dt">Bifunctor</span> s <span class="ot">=&gt;</span> (s a b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Fix</span> s a <span class="ot">-&gt;</span> b
<span class="ot">&gt;</span> fold f <span class="fu">=</span> f <span class="fu">.</span> bimap id (fold f) <span class="fu">.</span> out
<span class="ot">&gt;</span> 
<span class="ot">&gt; unfold ::</span> <span class="dt">Bifunctor</span> s <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> s a b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Fix</span> s a
<span class="ot">&gt;</span> unfold f <span class="fu">=</span> <span class="dt">In</span> <span class="fu">.</span> bimap id (unfold f) <span class="fu">.</span> f</code></pre></div>
<p>Here’s how we use <code>fmap</code> on <code>List</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; nil ::</span> <span class="dt">List</span> a
<span class="ot">&gt;</span> nil <span class="fu">=</span> <span class="dt">In</span> <span class="dt">Nil</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; cons ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a
<span class="ot">&gt;</span> cons x xs <span class="fu">=</span> <span class="dt">In</span> (<span class="dt">Cons</span> x xs)
<span class="ot">&gt;</span> 
<span class="ot">&gt; l ::</span> <span class="dt">List</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> l <span class="fu">=</span> fmap (<span class="fu">+</span><span class="dv">1</span>) (cons <span class="dv">3</span> (cons <span class="dv">4</span> nil))</code></pre></div>
<p>Tada! These recursive operators are indeed datatype-generic because the defintion of <code>fmap</code>, <code>fold</code> and <code>unfold</code> never use the specific data type we defined. They use only <code>bimap</code> which is parameterized by the shape <code>s</code> of the data. It means we can reuse these functions for other data types without reimplementing them for each type. For example, here’s a definition of <code>Tree</code>:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">TreeF</span> a r <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Branch</span> a r r <span class="kw">deriving</span> <span class="dt">Functor</span>
<span class="ot">&gt;</span> deriveBifunctor <span class="ch">&#39;&#39;</span><span class="dt">TreeF</span>
<span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Tree</span> <span class="fu">=</span> <span class="dt">Fix</span> <span class="dt">TreeF</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; leaf ::</span> <span class="dt">Tree</span> a
<span class="ot">&gt;</span> leaf <span class="fu">=</span> <span class="dt">In</span> <span class="dt">Leaf</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; branch ::</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a
<span class="ot">&gt;</span> branch x l r<span class="fu">=</span> <span class="dt">In</span> (<span class="dt">Branch</span> x l r)</code></pre></div>
<p>To map over a tree, we can just use the same <code>fmap</code> function we defined above!</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; t ::</span> <span class="dt">Tree</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> t <span class="fu">=</span> fmap (<span class="fu">+</span><span class="dv">1</span>) (branch <span class="dv">3</span> leaf (branch <span class="dv">4</span> leaf leaf))</code></pre></div>
<p>This technique of using <em>bifunctors</em> to implement datatype-generic recursive functions is mostly superseded by <code>Applicative</code> and <code>Traversable</code> in Haskell, but I think it is still a good example which shows the real power of <em>bifunctors</em>!</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Golden tests are tasty</title>
    <link href="http://kseo.github.io//posts/2016-12-15-golden-tests-are-tasty.html" />
    <id>http://kseo.github.io//posts/2016-12-15-golden-tests-are-tasty.html</id>
    <published>2016-12-15T00:00:00Z</published>
    <updated>2016-12-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 15, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/tasty.html">tasty</a>, <a href="/tags/golden.html">golden</a>, <a href="/tags/test.html">test</a>
      
  </div>

<p>Haskell programmers love property based testing thanks to glorious <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a> library. Once we specify the program behavior in terms of properties, <em>QuickCheck</em> generates random test cases and checks if the given properties hold for these test cases. Once it finds a failing test case, it automatically shrinks the test case to the minimal value which still violates the property.</p>
<p>However, we, Haskell programmers, often forget that there are other test methodologies. In this post, I am going to introduce <em>gold testing</em> provided by <a href="https://hackage.haskell.org/package/tasty-golden">tasty-golden</a> package.</p>
<p>The idea is simple. A golden test is just an <code>IO</code> action that writes its result to a file. To pass the test, this output file should be identical to the corresponding <em>golden</em> file, which contains the correct result for the test.</p>
<h1 id="a-cast-study-untyped-lambda-calculus">A cast study: untyped lambda calculus</h1>
<p>We have an <a href="https://github.com/kseo/untyped">untyped lambda calculus implementation</a>. It provides <code>run</code> function which evaluates the given lambda calculus script to a <code>String</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">run ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">String</span></code></pre></div>
<p>For testing, we would like to check if this function works correctly for various input scripts. To enumerate a few test scenarios:</p>
<ul>
<li><code>\x.x</code> evaluates to itself because there is no redex in the term.</li>
<li><code>(\x.x)(\x.x)</code> evaluates to <code>(\x.x)</code> by substitution.</li>
<li><code>\x.y</code> throws an error because <code>y</code> is an unbound variable.</li>
</ul>
<p>Of course, we can manually create a test case for each scenario, but this is boring and repetitive. Instead of writing test cases in Haskell, let’s create a script file and its expected output file for each input:</p>
<ul>
<li><p>t1.lc</p>
<pre><code>\x.x</code></pre></li>
<li><p>t1.golden</p>
<pre><code>\x.x</code></pre></li>
<li><p>t2.lc</p>
<pre><code>(\x.x)(\x.x)</code></pre></li>
<li><p>t2.golden</p>
<pre><code>(\x.x)</code></pre></li>
<li><p>t3.lc</p>
<pre><code>(\x.y)</code></pre></li>
<li><p>t3.golden</p>
<pre><code>&quot;untyped lambda-calculus&quot; (line 2, column 1):
unexpected end of input
The variable y has not been bound</code></pre></li>
</ul>
<p>Once we have these files ready, what golden tests do is to read each script file and evaluates the script, and compares the output with the expected output contained in the expected file. If the actual output and the expected output are different, the test fails. We call the expected output file as the <em>golden file</em>.</p>
<p>For convenience, tasty-golden generates the golden files if they are not available. So you don’t need to create golden files initially. You also can regenerate the golden files using the <code>--accept</code> flag. This is useful when you know that your change is valid and want to rebase all the golden files accordingly.</p>
<h1 id="implementation">Implementation</h1>
<p>Here’s the actual code which performs golden tests as described above. <code>listTestFiles</code> enumerates all the script files under <code>test/tests</code> directory and <code>mkGoldenTest</code> creates a golden test from the script file using <code>goldenVsString</code> function provided by tasty-golden.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Language.LambdaCalculus</span>

<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">as</span> <span class="dt">BS</span>
<span class="kw">import </span><span class="dt">System.FilePath</span>
<span class="kw">import </span><span class="dt">System.FilePath.Glob</span>

<span class="kw">import </span><span class="dt">Test.Tasty</span>
<span class="kw">import </span><span class="dt">Test.Tasty.Golden</span> <span class="kw">as</span> <span class="dt">G</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  paths <span class="ot">&lt;-</span> listTestFiles
  goldens <span class="ot">&lt;-</span> mapM mkGoldenTest paths
  defaultMain (testGroup <span class="st">&quot;Tests&quot;</span> goldens)

<span class="ot">listTestFiles ::</span> <span class="dt">IO</span> [FilePath]
listTestFiles <span class="fu">=</span> globDir1 pat <span class="st">&quot;test/tests&quot;</span>
  <span class="kw">where</span> pat <span class="fu">=</span> compile <span class="st">&quot;*.lc&quot;</span>

<span class="ot">mkGoldenTest ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">TestTree</span>
mkGoldenTest path <span class="fu">=</span> <span class="kw">do</span>
  <span class="kw">let</span> testName <span class="fu">=</span> takeBaseName path
  <span class="kw">let</span> goldenPath <span class="fu">=</span> replaceExtension path <span class="st">&quot;.golden&quot;</span>
  return (goldenVsString testName goldenPath action)
  <span class="kw">where</span>
<span class="ot">    action ::</span> <span class="dt">IO</span> <span class="dt">BS.ByteString</span>
    action <span class="fu">=</span> <span class="kw">do</span>
      script <span class="ot">&lt;-</span> readFile path
      <span class="kw">let</span> actual <span class="fu">=</span> either id id (run script)
      return (BS.pack actual)</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>How QuickCheck generates random functions</title>
    <link href="http://kseo.github.io//posts/2016-12-14-how-quick-check-generate-random-functions.html" />
    <id>http://kseo.github.io//posts/2016-12-14-how-quick-check-generate-random-functions.html</id>
    <published>2016-12-14T00:00:00Z</published>
    <updated>2016-12-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 14, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/QuickCheck.html">QuickCheck</a>, <a href="/tags/test.html">test</a>
      
  </div>

<p>In <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a>, test data is produced by <em>test generators</em> whose types are of the form <code>Gen a</code>. <code>Gen a</code> is a generator for values of type <code>a</code>. A type can define a default test data generator by defining an instance of the class <code>Arbitrary</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Arbitrary</span> a <span class="kw">where</span>
<span class="ot">  arbitrary   ::</span> <span class="dt">Gen</span> a
  <span class="fu">...</span></code></pre></div>
<p>We can define instances of <code>Arbitrary</code> using the combinators provided by <em>QuickCheck</em>. For example, the instances of <code>Bool</code> and <code>Ordering</code> are defined using <code>choose</code> and <code>elements</code> respectively. <code>choose</code> generates a random element in the given inclusive range and <code>elements xs</code> generates an arbitrary element of the list <code>xs</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Bool</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span> choose (<span class="dt">False</span>,<span class="dt">True</span>)
  shrink <span class="dt">True</span> <span class="fu">=</span> [<span class="dt">False</span>]
  shrink <span class="dt">False</span> <span class="fu">=</span> []

<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Ordering</span> <span class="kw">where</span>
  arbitrary <span class="fu">=</span> elements [<span class="dt">LT</span>, <span class="dt">EQ</span>, <span class="dt">GT</span>]
  shrink <span class="dt">GT</span> <span class="fu">=</span> [<span class="dt">EQ</span>, <span class="dt">LT</span>]
  shrink <span class="dt">LT</span> <span class="fu">=</span> [<span class="dt">EQ</span>]
  shrink <span class="dt">EQ</span> <span class="fu">=</span> []</code></pre></div>
<p>Simple and easy! But how about a function? Can we generate a function in the same way? The answer is surprisingly yes, but you need another type class named <code>CoArbitrary</code>.</p>
<p>Before explaining how <code>CoArbitrary</code> works, we need to check how <code>Gen</code> is defined:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | A generator for values of type @a@.</span>
<span class="kw">newtype</span> <span class="dt">Gen</span> a <span class="fu">=</span> <span class="dt">MkGen</span>{
<span class="ot">  unGen ::</span> <span class="dt">QCGen</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="co">-- ^ Run the generator on a particular seed.</span>
                             <span class="co">-- If you just want to get a random value out, consider using &#39;generate&#39;.</span>
  }</code></pre></div>
<p>Internally, <code>Gen a</code> is a function which takes 2 arguments (<code>QCGen</code> and <code>Int</code>) and returns <code>a</code>. Here <code>QCGen</code> is a newtype wrapper around either <code>StdGen</code> or <code>TFGen</code>.</p>
<p>So <code>Gen (a -&gt; b)</code> expands to <code>QCGen -&gt; Int -&gt; a -&gt; b</code>. By reordering parameters, this is equivalent to <code>a -&gt; Int -&gt; QCGen -&gt; b</code>, which represents <code>a -&gt; Gen b</code>. Thus by defining</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">promote ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Gen</span> b) <span class="ot">-&gt;</span> <span class="dt">Gen</span> (a<span class="ot">-&gt;</span>b)</code></pre></div>
<p>we can produce a generator for a <em>function type</em>, provided that we can construct a generator for the <em>result type</em> which somehow depends on the argument value.</p>
<p>So we need <code>coarbitrary</code> which modifies a generator in a way depending on its first parameter.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">CoArbitrary</span> a <span class="kw">where</span>
<span class="ot">  coarbitrary ::</span> a <span class="ot">-&gt;</span> <span class="dt">Gen</span> b <span class="ot">-&gt;</span> <span class="dt">Gen</span> b</code></pre></div>
<p>To actually define an instance of <code>CoArbitrary</code>, we need a helper function <code>variant</code>, which perturbs the generator. It creates a new generator that produces different pseudo-random results than the original.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Modifies a generator using an integer seed.</span>
<span class="ot">variant ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</code></pre></div>
<p>Now we can define instances of <code>CoArbitrary</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">CoArbitrary</span> <span class="dt">Bool</span> <span class="kw">where</span>
  coarbitrary <span class="dt">False</span> <span class="fu">=</span> variant <span class="dv">0</span>
  coarbitrary <span class="dt">True</span> <span class="fu">=</span> variant <span class="dv">1</span>

<span class="kw">instance</span> <span class="dt">CoArbitrary</span> a <span class="ot">=&gt;</span> <span class="dt">CoArbitrary</span> (<span class="dt">Maybe</span> a) <span class="kw">where</span>
  coarbitrary <span class="dt">Nothing</span>  <span class="fu">=</span> variant <span class="dv">0</span>
  coarbitrary (<span class="dt">Just</span> x) <span class="fu">=</span> variant <span class="dv">1</span> <span class="fu">.</span> coarbitrary x</code></pre></div>
<p>With all the pieces in place, we can finally define an <code>Arbitrary</code> for the function type <code>a -&gt; b</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Coarbitrary</span> a, <span class="dt">Arbitrary</span> b) <span class="ot">=&gt;</span> <span class="dt">Arbitrary</span> (a <span class="ot">-&gt;</span> b) <span class="kw">where</span>
  arbitrary <span class="fu">=</span> promote (\a <span class="ot">-&gt;</span> coarbitrary a arbitrary)</code></pre></div>
<p>To see how this works:</p>
<ol style="list-style-type: decimal">
<li><code>\a -&gt; coarbitrary a arbitrary</code> has type <code>a -&gt; Gen b</code></li>
<li><code>promote</code> has type <code>(a -&gt; Gen b) -&gt; Gen (a-&gt;b)</code></li>
<li>So, the entire expression has type <code>Gen (a-&gt;b)</code></li>
</ol>
<p>The current implementation of <em>QuickCheck</em> is a bit different as it is generalized to <code>Monad</code>, but When <code>m</code> is the function instance of <code>Monad</code>, <code>promote</code> is the same as we derived here.</p>
<pre><code>promote :: Monad m =&gt; m (Gen a) -&gt; Gen (m a)</code></pre>
<h1 id="references">References</h1>
<ul>
<li><a href="http://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf">QuickCheck: A Lightweight Tool for Random Testing of Haskell Programs</a> by Koen Claessen and John Hughes</li>
<li><a href="http://stackoverflow.com/a/16220336/2028189">StackOverflow: How to generate random, typed functions</a></li>
</ul>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Scott encoding of Algebraic Data Types</title>
    <link href="http://kseo.github.io//posts/2016-12-13-scott-encoding.html" />
    <id>http://kseo.github.io//posts/2016-12-13-scott-encoding.html</id>
    <published>2016-12-13T00:00:00Z</published>
    <updated>2016-12-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 13, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/scott%20encoding.html">scott encoding</a>, <a href="/tags/algebraic%20data%20type.html">algebraic data type</a>
      
  </div>

<p>This article is written in literate Haskell.</p>
<p>It is well known that algebraic data types can be encoded in a functional programming language by higher order functions. The Church encoding is the most famous one, but there is a lesser known encoding, called Scott encoding. The Scott encoding is generally considered as <a href="https://ifl2014.github.io/submissions/ifl2014_submission_13.pdf">better</a>.</p>
<p>In this article, I will show you some examples of Scott-encoded algebraic data types. Here I will use named functions intead of anonymous functions because the named function makes the notation of recursive algorithms easier.</p>
<p>Before move on, we need to turn on GHC extension <code>RankNTypes</code>. If you want to know how Rank-N types are related to the Scott encoding, see <a href="https://ocharles.org.uk/blog/guest-posts/2014-12-18-rank-n-types.html">24 Days of GHC Extensions: Rank N Types</a>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE RankNTypes #-}</span></code></pre></div>
<h1 id="pair">Pair</h1>
<p><code>Pair</code> is a simplest example of a container type. Because it is a non-recursive type, the Church and Scott encoding overlap in this case. This is the standard encoding used for pairs in λ-calculus courses.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">PairS</span> a b <span class="fu">=</span> <span class="dt">PairS</span> {<span class="ot"> unpairS ::</span> forall r<span class="fu">.</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r }</code></pre></div>
<p>Containers can be expressed by using closures (partial applications). <code>pairS</code> takes 3 arguments. We have a closure by applying only 2 arguments.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; pairS ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">PairS</span> a b
<span class="ot">&gt;</span> pairS a b <span class="fu">=</span> <span class="dt">PairS</span> (\p <span class="ot">-&gt;</span> p a b)</code></pre></div>
<p>Now it is time to define selection functions. <code>fstS</code> and <code>sndS</code> are implemented by passing a continuation (the function in which the continuation continues). It is a 2 argument function which returns either the first or the second argument. <code>fstS</code> returns the first argument and <code>sndS</code> returns the second argument.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fstS ::</span> <span class="dt">PairS</span> a b <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> fstS (<span class="dt">PairS</span> p) <span class="fu">=</span> p (\x _ <span class="ot">-&gt;</span> x)
<span class="ot">&gt;</span> 
<span class="ot">&gt; sndS ::</span> <span class="dt">PairS</span> a b <span class="ot">-&gt;</span> b
<span class="ot">&gt;</span> sndS (<span class="dt">PairS</span> p) <span class="fu">=</span> p (\_ y <span class="ot">-&gt;</span> y)</code></pre></div>
<p>Other functions such as <code>swapS</code> can be implemented in terms of <code>pairS</code>, <code>fstS</code> and <code>sndS</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; swapS ::</span> <span class="dt">PairS</span> a b <span class="ot">-&gt;</span> <span class="dt">PairS</span> b a
<span class="ot">&gt;</span> swapS p <span class="fu">=</span> pairS (sndS p) (fstS p)</code></pre></div>
<h1 id="peano-numbers">Peano numbers</h1>
<p><code>NumS</code> is the simplest recursive data type which represents Peano numbers.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">NumS</span> <span class="fu">=</span> <span class="dt">NumS</span> {<span class="ot"> unnumS ::</span> forall r<span class="fu">.</span> (<span class="dt">NumS</span> <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r }</code></pre></div>
<p><code>NumS</code> has two constructors. <code>zeroS</code> is the non recursive constructor that represents the value zero. <code>succS</code> is the recursive constructor which yields the successor of such a Peano number.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; zeroS ::</span> <span class="dt">NumS</span>
<span class="ot">&gt;</span> zeroS <span class="fu">=</span> <span class="dt">NumS</span> (\s z <span class="ot">-&gt;</span> z)
<span class="ot">&gt;</span> 
<span class="ot">&gt; succS ::</span> <span class="dt">NumS</span> <span class="ot">-&gt;</span> <span class="dt">NumS</span>
<span class="ot">&gt;</span> succS n <span class="fu">=</span> <span class="dt">NumS</span> (\s z <span class="ot">-&gt;</span> s n)</code></pre></div>
<p><code>unnumS</code> is the deconstructor which takes 2 continuations and a <code>NumS</code>. The continuations determine what we reduce the <code>NumS</code> into depending on which constructor is found.</p>
<p>For convinence, <code>unnumS'</code> is defined to have the <code>NumS</code> argument be the last arugment to the <code>unnumS</code> function.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; unnumS&#39; ::</span> (<span class="dt">NumS</span> <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> <span class="dt">NumS</span> <span class="ot">-&gt;</span> r
<span class="ot">&gt;</span> unnumS&#39; s z (<span class="dt">NumS</span> f) <span class="fu">=</span> f s z</code></pre></div>
<p>When we find the num is a successor, then we know that the num is not empty, so we reduce it to <code>False</code>. When we find it is the zero, we reduce it to <code>True</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; isZero ::</span> <span class="dt">NumS</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> isZero <span class="fu">=</span> unnumS&#39; (\_ <span class="ot">-&gt;</span> <span class="dt">False</span>) <span class="dt">True</span></code></pre></div>
<p><code>addS</code> is slightly more complex, but it can also be defined using the same techinque. You can recognize that it is a pattern mathcing in disguse.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; addS ::</span> <span class="dt">NumS</span> <span class="ot">-&gt;</span> <span class="dt">NumS</span> <span class="ot">-&gt;</span> <span class="dt">NumS</span>
<span class="ot">&gt;</span> addS n m <span class="fu">=</span>
<span class="ot">&gt;</span>     unnumS&#39; (\s <span class="ot">-&gt;</span> succS (addS s m))
<span class="ot">&gt;</span>             m n</code></pre></div>
<h1 id="list">List</h1>
<p>We can apply the same transformation to <code>ListS</code> type.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">ListS</span> a <span class="fu">=</span>
<span class="ot">&gt;</span>    <span class="dt">ListS</span> {
<span class="ot">&gt;      unconsS ::</span> forall r<span class="fu">.</span> (a <span class="ot">-&gt;</span> <span class="dt">ListS</span> a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> r
<span class="ot">&gt;</span>    }
<span class="ot">&gt;</span> 
<span class="ot">&gt; nilS ::</span> <span class="dt">ListS</span> a
<span class="ot">&gt;</span> nilS <span class="fu">=</span> <span class="dt">ListS</span> (\co ni <span class="ot">-&gt;</span> ni)
<span class="ot">&gt;</span> 
<span class="ot">&gt; consS ::</span> a <span class="ot">-&gt;</span> <span class="dt">ListS</span> a <span class="ot">-&gt;</span> <span class="dt">ListS</span> a
<span class="ot">&gt;</span> consS x xs <span class="fu">=</span> <span class="dt">ListS</span> (\co ni <span class="ot">-&gt;</span> co x xs)
<span class="ot">&gt;</span> 
<span class="ot">&gt; unconsS&#39; ::</span> (a <span class="ot">-&gt;</span> <span class="dt">ListS</span> a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> <span class="dt">ListS</span> a <span class="ot">-&gt;</span> r
<span class="ot">&gt;</span> unconsS&#39; co ni (<span class="dt">ListS</span> f) <span class="fu">=</span> f co ni
<span class="ot">&gt;</span> 
<span class="ot">&gt; isNullS ::</span> <span class="dt">ListS</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> isNullS <span class="fu">=</span> unconsS&#39; (\_ _ <span class="ot">-&gt;</span> <span class="dt">False</span>) <span class="dt">True</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; mapS ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">ListS</span> a <span class="ot">-&gt;</span> <span class="dt">ListS</span> b
<span class="ot">&gt;</span> mapS f <span class="fu">=</span>
<span class="ot">&gt;</span>   unconsS&#39; (\x xs <span class="ot">-&gt;</span> consS (f x) (mapS f xs))
<span class="ot">&gt;</span>            nilS</code></pre></div>
<h1 id="references">References</h1>
<p>Interested readers might like to take a look at the following papers for more information:</p>
<ul>
<li><a href="http://www.nlda-tw.nl/janmartin/papers/jmjansenLambdapaper.pdf">Comprehensive Encoding of Data Types and Algorithms in the λ-Calculus (Functional Pearl)</a> by JAN MARTIN JANSEN</li>
<li><a href="https://ifl2014.github.io/submissions/ifl2014_submission_13.pdf">Church Encoding of Data Types Considered Harmful for Implementations (Functional Pearl)</a> by Pieter Koopman, Rinus Plasmeijer and Jan Martin Jansen</li>
</ul>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>unfold and fold</title>
    <link href="http://kseo.github.io//posts/2016-12-12-unfold-and-fold.html" />
    <id>http://kseo.github.io//posts/2016-12-12-unfold-and-fold.html</id>
    <published>2016-12-12T00:00:00Z</published>
    <updated>2016-12-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a href="https://twitter.com/share" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>

<article>
  <div class="info">
      Posted on December 12, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/unfold.html">unfold</a>, <a href="/tags/fold.html">fold</a>, <a href="/tags/category%20theory.html">category theory</a>
      
  </div>

<h1 id="unfold">unfold</h1>
<p>Every functional programmer loves <em>fold</em>. fold is <a href="http://www.cs.nott.ac.uk/~pszgmh/fold.pdf">universal and expressive</a>. But <em>fold</em> has a secret twin brother named <em>unfold</em> which undoes what <em>fold</em> does. In this post, we will see what <em>unfold</em> is and how it is related to <em>fold</em>.</p>
<p><code>unfoldr</code> builds a list from a seed value while <code>foldr</code> reduces a list to a summary value.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unfoldr ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, b)) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a]</code></pre></div>
<p><code>unfoldr</code> takes the element and returns <code>Nothing</code> if it is done producing the list or returns <code>Just (a, b)</code>, in which case, <code>a</code> is a prepended to the list and <code>b</code> is used as the next element in a recursive call.</p>
<p>For example, we can define <code>iterate</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">iterate f <span class="fu">==</span> unfoldr (\x <span class="ot">-&gt;</span> <span class="dt">Just</span> (x, f x))</code></pre></div>
<p>Another simple use of <code>unfoldr</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> unfoldr (\b <span class="ot">-&gt;</span> <span class="kw">if</span> b <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Nothing</span> <span class="kw">else</span> <span class="dt">Just</span> (b, b<span class="fu">-</span><span class="dv">1</span>)) <span class="dv">10</span>
[<span class="dv">10</span>,<span class="dv">9</span>,<span class="dv">8</span>,<span class="dv">7</span>,<span class="dv">6</span>,<span class="dv">5</span>,<span class="dv">4</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]</code></pre></div>
<p>As the name suggests, <em>unfold</em> is the categorical dual of <em>fold</em>. (Maybe it should be <em>cofold</em> instead of <em>unfold</em>.) It means we can get the signature of <code>foldr</code> by reversing the arrows of <code>unfoldr</code>, and vice versa.</p>
<p>Let’s try this.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unfoldr ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, b)) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> [a])
foldr<span class="ot">   ::</span> (<span class="dt">Maybe</span> (a, b) <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> ([a] <span class="ot">-&gt;</span> b)</code></pre></div>
<p>Oops! It is not our beloved <code>foldr</code> function whose signature is:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</code></pre></div>
<h1 id="type-isomorphisms">Type isomorphisms</h1>
<p>But don’t be disappointed! We can show that they represent the same thing by using type isomorphisms:</p>
<pre><code>(a → b → b) → b → ([a] → b)</code></pre>
<blockquote>
<p>by a -&gt; b -&gt; c ~= (a, b) -&gt; c</p>
</blockquote>
<pre><code>((a, b) → b) → b → ([a] → b)</code></pre>
<blockquote>
<p>by a ~= () -&gt; a</p>
</blockquote>
<pre><code>((a, b) → b) → (() -&gt; b) → ([a] → b)</code></pre>
<blockquote>
<p>by a -&gt; b -&gt; c ~= (a, b) -&gt; c</p>
</blockquote>
<pre><code>(((a, b) → b), (() -&gt; b)) → ([a] → b)</code></pre>
<blockquote>
<p>by ((a -&gt; c), (b -&gt; c)) ~= Either a b -&gt; c</p>
</blockquote>
<pre><code>((Either (a, b) ()) → b) → ([a] → b)</code></pre>
<blockquote>
<p>by Either a () ~= Maybe a</p>
</blockquote>
<pre><code>(Maybe (a, b) -&gt; b) → ([a] → b)</code></pre>
<p>Now we can clearly see that <em>unfold</em> is the dual of <em>fold</em>. If you want to learn more on the relationship between <em>fold</em> and <em>unfold</em>, see Conal Elliott’s <a href="http://conal.net/talks/folds-and-unfolds.pdf">Folds and unfolds all around us</a>.</p>
<h1 id="implementation">Implementation</h1>
<p>Here’s an implementation of <code>unfoldr</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unfoldr ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, b)) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> [a])
unfoldr f b <span class="fu">=</span> <span class="kw">case</span> f b <span class="kw">of</span>
                <span class="dt">Just</span> (a, b&#39;) <span class="ot">-&gt;</span> a <span class="fu">:</span> unfoldr f b&#39;
                <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>

</feed>
