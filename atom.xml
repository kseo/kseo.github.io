<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Haskell for Pragmatic Programmers</title>
    <link href="http://kseo.github.io//atom.xml" rel="self" />
    <link href="http://kseo.github.io/" />
    <id>http://kseo.github.io//atom.xml</id>
    <author>
        <name>Kwang Yul Seo</name>
        <email>kwangyul.seo@gmail.com</email>
    </author>
    <updated>2016-12-10T00:00:00Z</updated>
    <entry>
    <title>Encodings of lens</title>
    <link href="http://kseo.github.io//posts/2016-12-10-encodings-of-lense.html" />
    <id>http://kseo.github.io//posts/2016-12-10-encodings-of-lense.html</id>
    <published>2016-12-10T00:00:00Z</published>
    <updated>2016-12-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <div class="info">
      Posted on December 10, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Lens.html">Lens</a>
      
  </div>

<p>There are variety of libraries offering lens on the hackage. These include <a href="https://hackage.haskell.org/package/data-accessor">data-accessor</a>, <a href="https://hackage.haskell.org/package/fclabels">fclabels</a>, <a href="https://hackage.haskell.org/package/lenses">lenses</a>, <a href="https://hackage.haskell.org/package/data-lens">data-lens</a> and <a href="https://www.stackage.org/haddock/lts-7.12/lens-4.14/Control-Lens.html">lens</a>. Though they represent the same idea, their encodings of lens are not compatible. This article is an attempt to understand various encodings used to represent the idea of lens.</p>
<h1 id="lens-as-a-getter-and-a-setter">Lens as a getter and a setter</h1>
<p>The most intuitive way to encode lens is to represent it as a collection of a <em>getter</em> and a <em>setter</em>. <code>Lens s a</code> represents a <em>focus</em> to an <code>a</code> inside an <code>s</code> structure.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Lens</span> s a <span class="fu">=</span> <span class="dt">Lens</span>
  {<span class="ot"> get ::</span> s <span class="ot">-&gt;</span> a
  ,<span class="ot"> set ::</span> a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
  }</code></pre></div>
<p>We can define a lens to the first element of a pair as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fstL ::</span> <span class="dt">Lens</span> (a,b) a
fstL <span class="fu">=</span> <span class="dt">Lens</span> {
    get <span class="fu">=</span> \(x,y) <span class="ot">-&gt;</span> x
  , set <span class="fu">=</span> \x (_,y) <span class="ot">-&gt;</span> (x,y)
  }</code></pre></div>
<p>Similarly, we can define <code>snd</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sndL ::</span> <span class="dt">Lens</span> (a,b) b
sndL <span class="fu">=</span> <span class="dt">Lens</span> {
    get <span class="fu">=</span> \(x,y) <span class="ot">-&gt;</span> y
  , set <span class="fu">=</span> \y (x,_) <span class="ot">-&gt;</span> (x,y)
  }</code></pre></div>
<p>Having defined this, it is easy to access and modify a pair:</p>
<pre><code>&gt; get fstL (1,2)
1
&gt; set fstL 3 (1,2)
(3,2)</code></pre>
<p>We can also implement <code>update</code> in terms of <code>get</code> and <code>set</code> by getting the value, applying a function and setting it again.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">update ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
update l f s <span class="fu">=</span> set l (f (get l s)) s</code></pre></div>
<p>This <code>update</code> function works fine for a small data structure such as pairs, but becomes expensive for large data structures as it needs to visit all the way down to the <em>focus</em> twice every time it updates.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> update fstL (<span class="fu">+</span><span class="dv">1</span>) (<span class="dv">1</span>,<span class="dv">2</span>)
(<span class="dv">2</span>,<span class="dv">2</span>)</code></pre></div>
<p>Lenses are composable with <code>compose</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">compose ::</span> <span class="dt">Lens</span> b c <span class="ot">-&gt;</span> <span class="dt">Lens</span> a b <span class="ot">-&gt;</span> <span class="dt">Lens</span> a c
compose bc ab <span class="fu">=</span> <span class="dt">Lens</span>
  { get <span class="fu">=</span> get bc <span class="fu">.</span> get ab
  , set <span class="fu">=</span> update ab <span class="fu">.</span> set bc
  }</code></pre></div>
<p>We can now modify nested pairs:</p>
<pre><code>&gt; update (sndL `compose` fstL) (*2) ((3,4),5)
((3,8),5)</code></pre>
<h1 id="lens-as-a-getter-and-an-updater">Lens as a getter and an updater</h1>
<p>A slight variation to the previous lens encoding is to represent a lens with a <em>getter</em> and an <em>updater</em> instead of a <em>getter</em> and a <em>setter</em>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Lens</span> s a <span class="fu">=</span> <span class="dt">Lens</span>
  {<span class="ot"> get ::</span> s <span class="ot">-&gt;</span> a
  ,<span class="ot"> update ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
  }</code></pre></div>
<p>The performance of this encoding is better than the previous one because we no longer need to visit the <em>focus</em> twice for an single update. <code>fstL</code> and <code>sndL</code> directly implement <code>update</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fstL ::</span> <span class="dt">Lens</span> (a,b) a
fstL <span class="fu">=</span> <span class="dt">Lens</span> {
    get <span class="fu">=</span> \(x,y) <span class="ot">-&gt;</span> x
  , update <span class="fu">=</span> \f (x,y) <span class="ot">-&gt;</span> (f x,y)
  }

<span class="ot">sndL ::</span> <span class="dt">Lens</span> (a,b) b
sndL <span class="fu">=</span> <span class="dt">Lens</span> {
    get <span class="fu">=</span> \(x,y) <span class="ot">-&gt;</span> y
  , update <span class="fu">=</span> \f (x,y) <span class="ot">-&gt;</span> (x, f y)
  }</code></pre></div>
<p>But what about <code>set</code>? We can easily define <code>set</code> in terms of <code>update</code> using <code>const</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">set ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
set l a s <span class="fu">=</span> update l (const a) s</code></pre></div>
<p>Composition of two lenses are similarly defined:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">compose ::</span> <span class="dt">Lens</span> b c <span class="ot">-&gt;</span> <span class="dt">Lens</span> a b <span class="ot">-&gt;</span> <span class="dt">Lens</span> a c
compose bc ab <span class="fu">=</span> <span class="dt">Lens</span>
  { get <span class="fu">=</span> get bc <span class="fu">.</span> get ab
  , update <span class="fu">=</span> update ab <span class="fu">.</span> update bc
  }</code></pre></div>
<h1 id="cps-based-lens-aka-van-laarhoven-lens">CPS based lens (aka van Laarhoven lens)</h1>
<p>This encoding is called <em>a CPS based lens</em> as the type looks like a continuation passing style function, which would be <code>(b -&gt; r) -&gt; (a -&gt; r)</code> though the return type is <code>f a</code> instead of any <code>r</code>. It is also called <a href="http://www.twanvl.nl/blog/haskell/cps-functional-references">van Laarhoven lens</a> named after <strong>Twan van Laarhoven</strong> who first discovered this encoding.</p>
<p>This is the most popular lens encoding as it is used by the famous Edward Kmett’s <a href="https://www.stackage.org/haddock/lts-7.12/lens-4.14/Control-Lens.html">lens</a> library.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE Rank2Types #-}</span>

<span class="kw">type</span> <span class="dt">Lens</span> s a <span class="fu">=</span> forall f<span class="fu">.</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> f s)</code></pre></div>
<p>It is hard to understand the type at first sight. There are no longer identifiable setter or getter in the type signature. Instead, we have a functor <code>f</code> in the signature.</p>
<p>As expected from the clue, we can derive <code>get</code> and <code>update</code> by applying different functors to the type.</p>
<p>First, we derive <code>get</code> by applying <code>Const</code> functor:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Applicative</span>

<span class="ot">get ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a
get l <span class="fu">=</span> getConst <span class="fu">.</span> l <span class="dt">Const</span></code></pre></div>
<p>Also we can derive <code>update</code> by applying <code>Identity</code> functor:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Identity</span>

<span class="ot">update ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
update l m <span class="fu">=</span> runIdentity <span class="fu">.</span> l (<span class="dt">Identity</span> <span class="fu">.</span> m)</code></pre></div>
<p><code>set</code> function can be implemented in terms of <code>get</code> and <code>update</code> as usual:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">set ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
set l b a <span class="fu">=</span> update l (const b) a</code></pre></div>
<p>Fortunately, defining a lens in var Laarhoven lens encoding is not hard. For example, we can define <code>fstL</code> using <code>fmap</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fstL ::</span> <span class="dt">Lens</span> (a,b) a
fstL f (x,y) <span class="fu">=</span> fmap (\a <span class="ot">-&gt;</span> (a, y)) (f x)</code></pre></div>
<p>Or we can define <code>sndL</code> more succinctly using <code>TupleSections</code> and <code>(&lt;$&gt;)</code> operator:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">sndL ::</span> <span class="dt">Lens</span> (a,b) b
sndL x (a,b) <span class="fu">=</span> (a,) <span class="fu">&lt;$&gt;</span> x b</code></pre></div>
<p>As this job of defining a lens is so mechanical, lens library provides a <a href="https://hackage.haskell.org/package/lens-4.15.1/docs/Control-Lens-TH.html#v:makeLenses">TemplateHaskell macro</a> to generate lenses from a record.</p>
<p>Let’s see how <code>get</code> works by actually evaluating <code>get fstL (1,2)</code>:</p>
<pre><code>get fstL (1,2)
=&gt; getConst . (fstL Const) (1,2)
=&gt; getConst . (\x (a,b) -&gt; (,b) &lt;$&gt; x a) (1,2)
=&gt; getConst . (\(a,b) -&gt; (,b) &lt;$&gt; Const a) (1,2)
=&gt; getConst . ((,2) &lt;$&gt; Const 1)
=&gt; getConst . (Const 1)
=&gt; 1</code></pre>
<p>One particularly nice property of var Laarhoven lens is that composition of two lens is just the function composition operator <code>(.)</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">compose ::</span> <span class="dt">Lens</span> b c <span class="ot">-&gt;</span> <span class="dt">Lens</span> a b <span class="ot">-&gt;</span> <span class="dt">Lens</span> a c
compose r s <span class="fu">=</span> s <span class="fu">.</span> r</code></pre></div>
<p>So we can simply use the <code>(.)</code> to compose two lenses instead of custom <code>compose</code> function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> update (fstL <span class="fu">.</span> sndL) (<span class="fu">*</span><span class="dv">2</span>) ((<span class="dv">3</span>,<span class="dv">4</span>),<span class="dv">5</span>)
((<span class="dv">3</span>,<span class="dv">8</span>),<span class="dv">5</span>)</code></pre></div>
<p>However, the order of composition is reversed due to the nature of CPS based encoding. This is a bit confusing at first, but it makes sense when we think of it as a property referencing in an OO language.</p>
<pre><code>pair.(fstL.sndL) *= 2</code></pre>
<p>This style of composition is also possible with previous two encodings if we use Haskell’s type classes to overload <code>(.)</code> and <code>id</code> as described in <a href="http://www.twanvl.nl/blog/haskell/overloading-functional-references">Overloading functional references</a>. But van Laarhoven lens is still simpler as we don’t need to hide the <code>(.)</code> operator of the <code>Prelude</code>.</p>
<h1 id="isomorphism-lens">Isomorphism lens</h1>
<p>There is a yet another encoding of lens called <a href="http://www.twanvl.nl/blog/haskell/isomorphism-lenses">Isomorphism lens</a> which was also discovered by van Laarhoven.</p>
<blockquote>
<p>A lens from type s to a is a bijection between s and a pair of a and some residual r.</p>
</blockquote>
<p>To put it more succinctly,</p>
<pre><code>type Lens s a = exists r. s &lt;-&gt; (a,r)</code></pre>
<p>Because Haskell has no <code>exists</code> keyword, we can represent the encoding with a <code>newtype</code> wrapper:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE Rank2Types #-}</span>
<span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span>

<span class="co">-- Isomorphisms/bijections between type @a@ and @b@</span>
<span class="kw">data</span> <span class="dt">Iso</span> a b <span class="fu">=</span> <span class="dt">Iso</span> {<span class="ot"> fw ::</span> a <span class="ot">-&gt;</span> b,<span class="ot"> bw ::</span> b <span class="ot">-&gt;</span> a }

<span class="co">-- Lenses with a data wrapper, in practice you might want to unpack the Iso type</span>
<span class="kw">data</span> <span class="dt">Lens</span> s a <span class="fu">=</span> forall r<span class="fu">.</span> <span class="dt">Lens</span> (<span class="dt">Iso</span> s (a,r))</code></pre></div>
<p>This encoding captures the intuition of what lens does extremely well. Suppose we have a record type <code>s</code>, and want to take out a field of type <code>a</code>. When we do that, there is some residual, which is <code>s - a</code>. So <code>s</code> and <code>(a, s - a)</code> is must be isomorphic.</p>
<p>We can define <code>get</code> and <code>update</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Bifunctor</span>

<span class="ot">get ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a
get (<span class="dt">Lens</span> l) <span class="fu">=</span> fst <span class="fu">.</span> fw l

<span class="ot">update ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> s)
update (<span class="dt">Lens</span> l) f <span class="fu">=</span> bw l <span class="fu">.</span> first f <span class="fu">.</span> fw l</code></pre></div>
<p><code>set</code> function is the same as before:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">set ::</span> <span class="dt">Lens</span> s a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s
set l b a <span class="fu">=</span> update l (const b) a</code></pre></div>
<p>Isomorphism lens has the nice property that we can derive lens laws directly from the isomorphism law.</p>
<blockquote>
<p>fw i . bw i = bw i . fw i = id</p>
</blockquote>
<p>See <a href="http://www.twanvl.nl/blog/haskell/isomorphism-lenses">van Laarhoven’s article</a> to see how we can derive three lens law.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Objects versus Abstract Data Types</title>
    <link href="http://kseo.github.io//posts/2016-06-14-objects-vs-abstract-data-types.html" />
    <id>http://kseo.github.io//posts/2016-06-14-objects-vs-abstract-data-types.html</id>
    <published>2016-06-14T00:00:00Z</published>
    <updated>2016-06-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <div class="info">
      Posted on June 14, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/objects.html">objects</a>, <a href="/tags/abstract%20data%20types.html">abstract data types</a>
      
  </div>

<p>William R. Cook’s essay titled <a href="http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf">On Understanding Data Abstraction, Revisited</a> explains the differences between two forms of data abstraction, <em>objects</em> and <em>abstract data types</em>. His another paper, <a href="https://www.cs.utexas.edu/users/wcook/papers/OOPvsADT/CookOOPvsADT90.pdf">Object-Oriented Programming Versus Abstract Data Types</a> shows why distinguishing these two data abstractions are important:</p>
<blockquote>
<p>Object-oriented programming and abstract data types can also be viewed as complementary implementation techniques: objects are centered around the constructors of a data abstraction, while abstract data types are organized around the operations. These differences have consequences relating to extensibility, efficiency, typing, and verification; in many cases the strengths of one paradigm are the weaknesses of the other. Most object-oriented programming languages support aspects of both techniques, not a unification of them, so an understanding of their relative merits is useful in designing programs.</p>
</blockquote>
<p>Haskell type classes are also discussed in Cook’s essay. He described Haskell type classes as a powerful mechanism for parameterization and extensibility because type classes are unique in that they have properties of both objects and abstract data types:</p>
<ul>
<li>Type classes do not allow different instances to interoperate, but they allow multiple type class instances within a single program.</li>
<li>Type classes are similar to object interfaces in allowing a method to operate on any value that has the necessary operations.</li>
<li>Type classes are based on algebraic signatures as in abstract data types, but they do not enforce any hiding of representations.</li>
</ul>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Learn Haskell to be a better programmer</title>
    <link href="http://kseo.github.io//posts/2016-06-01-learn-haskell-to-be-a-better-programmer.html" />
    <id>http://kseo.github.io//posts/2016-06-01-learn-haskell-to-be-a-better-programmer.html</id>
    <published>2016-06-01T00:00:00Z</published>
    <updated>2016-06-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <div class="info">
      Posted on June  1, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/category%20theory.html">category theory</a>, <a href="/tags/composition.html">composition</a>
      
  </div>

<p>Haskell is notorious for being hard to learn. Pure functions, lazy evaluation, Haskell type system are just start.</p>
<p>To use Haskell effectively, it is necessary to learn the abstract concepts borrowed from the category theory such as Functor, Applicative Functor and Monad. You need to understand these concepts throughly because most of Haskell code is written using these abstract non-sense.</p>
<p>Of course, it is still possible to write IO code and use <code>Maybe</code>, <code>Either</code> and <code>List</code> types without understanding Monad. But then why do you want to learn Haskell anyway? If you avoid learning these concpets, you can’t learn much from Haskell. It would be much beneficial to learn other more practical languages.</p>
<p>Before explaining why you should learn Haskell, let’s ask a question. What’s the essence of programming?</p>
<p>Programming is basically instructing the computer to some labor. For example, “Load the value at memory x into the register, add 1 to it, and store the value back to the memory” is a program.</p>
<p>But a program is not just a sequence of instructions. It is a solution to our real problem. What makes programming interesting is that the problems we solve as a programmer is much bigger in size than simply loading a value from the memory and doing some arithmetic.</p>
<p>So programming is to divide a big problem that can’t be solved at once into many small problems, solve them independently, and compose the resulting small programs into a program that solves the original problem. In other words, the essence of programming is recomposition after decomposition. See Bartosz Milewski’s <a href="https://bartoszmilewski.com/2014/11/04/category-the-essence-of-composition/">Category: The Essence of Composition</a>.</p>
<p>Here comes the most important property of programming, which is called <em>composability</em>. We need to solve many complex problems which are similar but not exactly same. If we can compose small reusable programs into a new program which solves the new problem, the productivity of a programmer will be dramatically increased.</p>
<p>The changes of programming paradigm in the history can be explained as our continous endeavor to enhance the composability. For example, the shift from assembly programming with goto to structure programming emphasizing subroutine and loop was necessary as the problem size increases. We desparately needed a better way to compose programs.</p>
<p>But as the complexity of problem drastically increased again in 80-90s, we needed a new programming paradigm called object-oriented programming. Classes and objects, encapsulation and information hiding were another endeavor to imporve the composability of programs.</p>
<p>Now in 2010s, functional programming is gaining attention. The complexity of problems we have today is enormous and we need new tools and concepts to cope with ever increasing complexity. Classes are not enough. We need more composability.</p>
<p>Haskell provides new tools and concepts which can help organize code better. Concepts like Functor, Applicative Functor, Monad, Arrow and Lense all provide new means to compose programs. See Gabriel Gonzalez’s <a href="http://www.haskellforall.com/2012/08/the-category-design-pattern.html">The category design pattern</a>.</p>
<p>In fact, you already know some of these concepts. For example, ES6’s Promise, C#’s null propagation operator, Python’s list comprehension all share the same monadic structure. But you probably never noticed the common structure lying behind these different language features. After you learn Haskell, you will begin to see the common structure you’ve never imagined before.</p>
<p>In summary, the essence of programming is <em>composition</em>. Haskell provides new tools and concepts to compose programs. Learning Haskell improves your code organizational skills and make you prepared to handle more complex problems. <a href="http://learnyouahaskell.com/chapters">Learn you a Haskell for great good!</a></p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Fay + Node.js</title>
    <link href="http://kseo.github.io//posts/2014-03-11-fay-with-nodejs.html" />
    <id>http://kseo.github.io//posts/2014-03-11-fay-with-nodejs.html</id>
    <published>2014-03-11T00:00:00Z</published>
    <updated>2014-03-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <div class="info">
      Posted on March 11, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Fay.html">Fay</a>, <a href="/tags/node.js.html">node.js</a>
      
  </div>

<p><a href="https://github.com/faylang/fay">Fay</a> is a proper subset of Haskell that compiles to JavaScript. Thus it is by definition a statically typed lazy pure functional language. If you want a more thorough introduction to Fay, please read Paul Callaghan’s <a href="https://pragprog.com/magazines/2012-12/web-programming-in-haskell">Web Programming in Haskell</a> and <a href="https://ocharles.org.uk/blog/posts/2013-12-23-24-days-of-hackage-fay.html">Oliver Charles’s 24 Days of Hackage: fay</a>.</p>
<p>The original intention of Fay is to use Haskell on the client side. If you use a Haskell web framework such as Yesod or Snap, using Fay you can use the same language on both client and server sides and some code can actually be shared.</p>
<p>However, because Fay is simply a subset of Haskell that compiles to JavaScript with no dependencies on the client side, you can use it on the server side too in combination with Node.js. I am not saying it is actually a good idea to write server code in Fay, but it is at least fun to investigate the feasibility. Here is <a href="https://gist.github.com/kseo/9477930">a web server example</a> written in Fay.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE EmptyDataDecls #-}</span>
<span class="kw">module</span> <span class="dt">Hello</span> <span class="kw">where</span></code></pre></div>
<p><code>EmptyDataDecls</code> is required because JavaScript types are represented by empty data declarations in Fay.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">FFI</span></code></pre></div>
<p>FFI module provides a foreign function interface.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Http</span>
<span class="kw">data</span> <span class="dt">HttpServer</span>
<span class="kw">data</span> <span class="dt">Request</span>
<span class="kw">data</span> <span class="dt">Response</span></code></pre></div>
<p><code>Http</code>, <code>HttpServer</code>, <code>Request</code> and <code>Response</code> are JavaScript types we use in this example. They are represented by empty data declarations.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">requireHttp ::</span> <span class="dt">Fay</span> <span class="dt">Http</span>
requireHttp <span class="fu">=</span> ffi <span class="st">&quot;require(&#39;http&#39;)&quot;</span></code></pre></div>
<p>This is a simple example of a FFI declaration. It returns the result of <code>require('http')</code> as a <code>Http</code> instance. Fay is a monad which is similar to IO monad. Because a FFI function often has side effects, Fay monad is used to represent this.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">createServer ::</span> <span class="dt">Http</span> <span class="ot">-&gt;</span> (<span class="dt">Request</span> <span class="ot">-&gt;</span> <span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()) <span class="ot">-&gt;</span> <span class="dt">Fay</span> <span class="dt">HttpServer</span>
createServer <span class="fu">=</span> ffi <span class="st">&quot;%1.createServer(%2)&quot;</span>
 
<span class="ot">consoleLog ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()
consoleLog <span class="fu">=</span> ffi <span class="st">&quot;console.log(%1)&quot;</span>
 
<span class="ot">listen ::</span> <span class="dt">HttpServer</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()
listen <span class="fu">=</span> ffi <span class="st">&quot;%1.listen(%2, %3)&quot;</span>
  
<span class="ot">writeHead ::</span> <span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()
writeHead <span class="fu">=</span> ffi <span class="st">&quot;%1.writeHead(%2, %3)&quot;</span>
  
<span class="ot">end ::</span> <span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fay</span> ()
end <span class="fu">=</span> ffi <span class="st">&quot;%1.end(%2)&quot;</span></code></pre></div>
<p>These FFI declarations use <code>%1</code>, <code>%2</code> that corresponds to the arguments we specify in the type. Most Fay types are automatically serialized and deserialized. Note that we can only use point free style in FFI functions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">Fay</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  http <span class="ot">&lt;-</span> requireHttp
  server <span class="ot">&lt;-</span> createServer http (\req res <span class="ot">-&gt;</span> <span class="kw">do</span>
    writeHead res <span class="dv">200</span> <span class="st">&quot;{ &#39;Content-Type&#39;: &#39;text/plain&#39; }&quot;</span>
    end res <span class="st">&quot;Hello World\n&quot;</span>
    )
  listen server <span class="dv">1337</span> <span class="st">&quot;127.0.0.1&quot;</span>
  consoleLog <span class="st">&quot;Server running at http://127.0.0.1:1337/&quot;</span></code></pre></div>
<p><code>main</code> is the entry point to our web server example. Its return type is <code>Fay ()</code> because a Fay program can’t do anything without interacting with the world outside. Because we already wrapped all the Node.js APIs we use, we can program as if we write a normal Haskell program.</p>
<p>Compare our Fay web server program with the original Node.js program. Except for the FFI bindings, the main code is almost the same as before. However, our version is much more type-safe!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">var http <span class="fu">=</span> require(<span class="ch">&#39;http&#39;</span>);
http<span class="fu">.</span>createServer(function (req, res) {
  res<span class="fu">.</span>writeHead(<span class="dv">200</span>, {<span class="ch">&#39;Content-Type&#39;</span><span class="fu">:</span> <span class="ch">&#39;text/plain&#39;</span>});
  res<span class="fu">.</span>end(<span class="ch">&#39;Hello World\n&#39;</span>);
})<span class="fu">.</span>listen(<span class="dv">1337</span>, <span class="ch">&#39;127.0.0.1&#39;</span>);
console<span class="fu">.</span>log(<span class="ch">&#39;Server running at http://127.0.0.1:1337/&#39;</span>);</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Evaluation Strategy: Haskell vs Scala</title>
    <link href="http://kseo.github.io//posts/2014-03-02-evaluation-strategy-haskell-vs-scala.html" />
    <id>http://kseo.github.io//posts/2014-03-02-evaluation-strategy-haskell-vs-scala.html</id>
    <published>2014-03-02T00:00:00Z</published>
    <updated>2014-03-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <div class="info">
      Posted on March  2, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Scala.html">Scala</a>, <a href="/tags/evaluation%20strategy.html">evaluation strategy</a>
      
  </div>

<p>Haskell is a non-strict language, and GHC uses a strategy called laziness which combines non-strictness and sharing for efficiency.</p>
<p>Thus, you can easily implement <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:const">const</a> which never uses the second argument.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">const x y <span class="fu">=</span> x</code></pre></div>
<p>With this definition, it is okay to pass <code>undefined</code> as the second argument of <code>const</code> because <code>y</code> is not never evaluated. But in Haskell, you can also make an argument strict using the <a href="https://ocharles.org.uk/blog/posts/2014-12-05-bang-patterns.html">BangPatterns GHC extension</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">const x <span class="fu">!</span>y <span class="fu">=</span> x</code></pre></div>
<p>Interestingly, the situation is reversed in Scala whose default evaluation strategy is strict.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">const</span>(x: Int, y:Int) = x</code></pre></div>
<p>You can make an argument non-strict by putting the <code>=&gt;</code> symbol between the variable name and the type.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">const</span>(x: Int, y: =&gt; Int) = x</code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Parametric Polymorphism and Girard-Reynolds Isomorphism</title>
    <link href="http://kseo.github.io//posts/2014-02-21-parametric-polymorphism-and-girard-reynolds-isomorphism.html" />
    <id>http://kseo.github.io//posts/2014-02-21-parametric-polymorphism-and-girard-reynolds-isomorphism.html</id>
    <published>2014-02-21T00:00:00Z</published>
    <updated>2014-02-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <div class="info">
      Posted on February 21, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Combinatory%20logic.html">Combinatory logic</a>, <a href="/tags/Curry-Howard%20Isomorphism.html">Curry-Howard Isomorphism</a>, <a href="/tags/Djinn.html">Djinn</a>, <a href="/tags/Girard-Reynolds.html">Girard-Reynolds</a>, <a href="/tags/Hindley-Milner.html">Hindley-Milner</a>, <a href="/tags/Intuitonistic%20logic.html">Intuitonistic logic</a>, <a href="/tags/lambda%20calculus.html">lambda calculus</a>, <a href="/tags/Lennart%20Augustsson.html">Lennart Augustsson</a>, <a href="/tags/Phil%20Gossett.html">Phil Gossett</a>
      
  </div>

<p><a href="https://www.youtube.com/watch?v=h0OkptwfX4g">A talk</a> by Phil Gossett given in Google’s Advanced Programming Language series is the best explanation of Curry-Howard isomorphism I’ve seen.</p>
<p><a href="http://www.youtube.com/watch?v=h0OkptwfX4g" title="Advanced Topics in Programming Languages Series: Parametric Polymorphism and the Girard-Reynolds Isomorphism"><img src="http://img.youtube.com/vi/h0OkptwfX4g/0.jpg" alt="IMAGE ALT TEXT" /></a></p>
<p>He briefly mentioned the origin of type system at the beginning and explained Hindley-Milner, Type Classes (Wadler-Blott), Curry-Howard and Girard-Reynolds. Especially, he showed the relationship between parametricity and Girard-Reynolds isomorphism.</p>
<p>He finished his talk by describing Lennart Augustsson’s <a href="https://hackage.haskell.org/package/djinn">Djinn</a>, which is small program that takes a (Haskell) type and gives you back a function of that type if one exists.</p>
<p>In his talk, he gave some examples of Curry-Howard isomorphism.</p>
<ul>
<li>Intuitonistic logic &lt;-&gt; Combinatory logic (-&gt; Lambda Calculus)</li>
<li>Girard representation theorem &lt;-&gt; Reynolds abstraction theorem</li>
<li>F2 &lt;-&gt; P2</li>
</ul>
<p>BTW, there are a few technical errors in the talk. Please refer to <a href="http://wadler.blogspot.kr/2007/04/google-tech-talk-parametric.html">Wadler’s comment</a> on the talk.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Learning Agda to be a better Haskell programmer</title>
    <link href="http://kseo.github.io//posts/2014-02-21-learning-agda-to-be-a-better-haskell-programmer.html" />
    <id>http://kseo.github.io//posts/2014-02-21-learning-agda-to-be-a-better-haskell-programmer.html</id>
    <published>2014-02-21T00:00:00Z</published>
    <updated>2014-02-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <div class="info">
      Posted on February 21, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Agda.html">Agda</a>, <a href="/tags/dependent%20type.html">dependent type</a>
      
  </div>

<p>In my previous post <a href="http://kseo.github.io/posts/2014-02-17-learning-prolog-to-be-a-better-haskell-programmer.html">Learning Prolog to be a better Haskell programmer</a>, I advocated learning Prolog is quite helpful to get more intuitions on Haskell type-level programming.</p>
<p>I think a good next step is to learn a dependent typed programming language such as <a href="http://wiki.portal.chalmers.se/agda/pmwiki.php">Agda</a> or <a href="https://code.google.com/archive/p/epigram/">Epigram</a>. As learning Haskell is a good way to develop oneself as a better Java programmer, learning a dependent typed programming language is a good way to develop oneself as a better Haskell programmer.</p>
<p>Among many dependent typed programming languages, I recommend Agda simply because its surface syntax is quite similar to that of Haskell. Because dependent typed programming languages in general are not mature enough to perform day-to-day programming task and most of them are more or less equivalent in powers, choosing a syntactically familiar language helps you understand more advanced type system behind the syntax.</p>
<p>As the name “dependent type” implies, the biggest difference lies in the type system. While Haskell’s type system strictly splits values and types, Agda blurs the distinction between types and values. Type level programming in Haskell with type families or functional dependencies is esoteric at best, but type level programming in Agda is a norm.</p>
<p>For example, it is possible to define a type of lists of a certain length. In this setting, it is a type error to pass an empty list to head.</p>
<div class="sourceCode"><pre class="sourceCode agda"><code class="sourceCode agda"><span class="kw">data</span> Vec <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> Nat <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="kw">where</span>
     [] <span class="ot">:</span> Vec A zero
     <span class="ot">_</span>::<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> A <span class="ot">-&gt;</span> Vec A n <span class="ot">-&gt;</span> Vec A <span class="ot">(</span>suc n<span class="ot">)</span>
 
head <span class="ot">:</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}{</span>n <span class="ot">:</span> Nat<span class="ot">}</span> <span class="ot">-&gt;</span> Vec A <span class="ot">(</span>suc n<span class="ot">)</span> <span class="ot">-&gt;</span> A
head <span class="ot">(</span>x :: xs<span class="ot">)</span> <span class="ot">=</span> x</code></pre></div>
<p>Please refer to <a href="http://www.cse.chalmers.se/~ulfn/darcs/AFP08/LectureNotes/AgdaIntro.pdf">Dependently Typed Programming in Agda</a> and <a href="https://www.youtube.com/playlist?p=B7F836675DCE009C">Daniel Peebles’s introduction on Agda</a> for more information on Agda.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Learning Prolog to be a better Haskell programmer</title>
    <link href="http://kseo.github.io//posts/2014-02-17-learning-prolog-to-be-a-better-haskell-programmer.html" />
    <id>http://kseo.github.io//posts/2014-02-17-learning-prolog-to-be-a-better-haskell-programmer.html</id>
    <published>2014-02-17T00:00:00Z</published>
    <updated>2014-02-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <div class="info">
      Posted on February 17, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/prolog.html">prolog</a>, <a href="/tags/type-level%20programming.html">type-level programming</a>, <a href="/tags/functional%20dependencies.html">functional dependencies</a>, <a href="/tags/type%20families.html">type families</a>
      
  </div>

<p>While learning some advanced topics of the Haskell type system, I found type level programming is reminiscent of logic programming.</p>
<p>For example, <a href="http://www.cse.chalmers.se/~hallgren/Papers/wm01.html">Fun with Functional Dependencies</a> shows how to implement insertion sort using functional dependencies in a programming style similar to Prolog. <a href="https://wiki.haskell.org/Simonpj/Talk:FunWithTypeFuns">Fun with Type Functions</a> also shows a similar example using type families.</p>
<p>This similarity is not a coincidence because of the correspondence between a logic system and a type system, which is known as <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curry-Howard isomorphism</a>.</p>
<p>Lesson: Learn Prolog to be a better Haskell programmer!</p>
<h2 id="references">References</h2>
<p>There is <a href="https://mail.haskell.org/pipermail/haskell-cafe/2010-June/079412.html">a discussion</a> on the Haskell-cafe.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Data.Map vs Data.IntMap</title>
    <link href="http://kseo.github.io//posts/2014-02-12-data-map-vs-data-intmap.html" />
    <id>http://kseo.github.io//posts/2014-02-12-data-map-vs-data-intmap.html</id>
    <published>2014-02-12T00:00:00Z</published>
    <updated>2014-02-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <div class="info">
      Posted on February 12, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/Data.Map.html">Data.Map</a>, <a href="/tags/Data.IntMap.html">Data.IntMap</a>
      
  </div>

<p>A map is the one of most widely used data structures in many applications. Thus, many language runtimes provide an efficient implementation of a map. In a purely functional programming language, map is usually implemented as a balanced binary tree. Haskell is no exception here and the implementation of Haskell’s <code>Data.Map</code> is based on size balanced binary trees described in</p>
<ul>
<li>Stephen Adams, <a href="http://www.swiss.ai.mit.edu/~adams/BB/">“Efficient sets: a balancing act”</a>, Journal of Functional Programming 3(4):553-562, October 1993, .</li>
<li>J. Nievergelt and E.M. Reingold, “Binary search trees of bounded balance”, SIAM journal of computing 2(1), March 1973.</li>
</ul>
<p><code>Data.Map</code> is parameterized over key and value types, so that you can use any type you want as long as key is an instance of <code>Ord</code> type class. So, for example, you can use <code>Int</code> as the key type and store any type you want.</p>
<p>However, Haskell also provides a special version <code>Data.IntMap</code> for <code>Int</code> key. It seems redundant at first, but <code>Data.IntMap</code> is different from <code>Data.Map</code> in that it supports efficient merging of two maps. The implementation of <code>Data.IntMap</code> is described in</p>
<ul>
<li>Chris Okasaki and Andy Gill, <a href="http://citeseer.ist.psu.edu/okasaki98fast.html">“Fast Mergeable Integer Maps”</a>, Workshop on ML, September 1998, pages 77-86,</li>
<li>D.R. Morrison, “/PATRICIA — Practical Algorithm To Retrieve Information Coded In Alphanumeric/”, Journal of the ACM, 15(4), October 1968, pages 514-534.</li>
</ul>
<p>The author of <code>Data.IntMap</code> mentions that insertions and deletions of <code>Data.IntMap</code> when compared to a generic size-balanced map implementation are also much faster. This observation suggests that we should use <code>Data.IntMap</code> whenever possible whether or not we need union or intersection of twp maps.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Record wildcards</title>
    <link href="http://kseo.github.io//posts/2014-02-10-record-wildcards.html" />
    <id>http://kseo.github.io//posts/2014-02-10-record-wildcards.html</id>
    <published>2014-02-10T00:00:00Z</published>
    <updated>2014-02-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<article>
  <div class="info">
      Posted on February 10, 2014
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/Haskell.html">Haskell</a>, <a href="/tags/record%20wildcards.html">record wildcards</a>, <a href="/tags/language%20extension.html">language extension</a>
      
  </div>

<p>Haskell record syntax is a bit verbose. For records with many fields, it is tiresome to write each field individually in a record pattern, as in</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">C</span> <span class="fu">=</span> <span class="dt">C</span> {<span class="ot">a ::</span> <span class="dt">Int</span>,<span class="ot"> b ::</span> <span class="dt">Int</span>,<span class="ot"> c ::</span> <span class="dt">Int</span>,<span class="ot"> d ::</span> <span class="dt">Int</span>}

f (<span class="dt">C</span> {a <span class="fu">=</span> <span class="dv">1</span>, b <span class="fu">=</span> b, c <span class="fu">=</span> c, d <span class="fu">=</span> d}) <span class="fu">=</span> b <span class="fu">+</span> c <span class="fu">+</span> d</code></pre></div>
<p><a href="https://ocharles.org.uk/blog/posts/2014-12-04-record-wildcards.html">Record wildcard syntax</a> lets us use <code>..</code> in a record pattern, which simplifies pattern <code>f=f</code> to <code>f</code>. The above pattern can be rewritten with record wildcards syntax</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f (<span class="dt">C</span> {a <span class="fu">=</span> <span class="dv">1</span>, <span class="fu">..</span>}) <span class="fu">=</span> b <span class="fu">+</span> c <span class="fu">+</span> d</code></pre></div>
<p>This simple example does not show the merit of record wildcards vividly. Let’s see a real world example. <a href="http://hackage.haskell.org/package/hs-java">hs-java</a> is a package written by Ilya V. Portnov, which provides data types for Java .class files format and functions to assemble/disassemble Java bytecode.</p>
<p>The datatype for a JVM class file is <code>Class</code>, which has many fields as in</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Class</span> stage <span class="fu">=</span> <span class="dt">Class</span> {
<span class="ot">  magic ::</span> <span class="dt">Word32</span>,                         <span class="co">-- ^ Magic value: 0xCAFEBABE</span>
<span class="ot">  minorVersion ::</span> <span class="dt">Word16</span>,
<span class="ot">  majorVersion ::</span> <span class="dt">Word16</span>,
<span class="ot">  constsPoolSize ::</span> <span class="dt">Word16</span>,                <span class="co">-- ^ Number of items in constants pool</span>
<span class="ot">  constsPool ::</span> <span class="dt">Pool</span> stage,                <span class="co">-- ^ Constants pool itself</span>
<span class="ot">  accessFlags ::</span> <span class="dt">AccessFlags</span> stage,        <span class="co">-- ^ See @JVM.Types.AccessFlag@</span>
<span class="ot">  thisClass ::</span> <span class="dt">Link</span> stage <span class="dt">B.ByteString</span>,    <span class="co">-- ^ Constants pool item index for this class</span>
<span class="ot">  superClass ::</span> <span class="dt">Link</span> stage <span class="dt">B.ByteString</span>,   <span class="co">-- ^ --/-- for super class, zero for java.lang.Object</span>
<span class="ot">  interfacesCount ::</span> <span class="dt">Word16</span>,               <span class="co">-- ^ Number of implemented interfaces</span>
<span class="ot">  interfaces ::</span> [<span class="dt">Link</span> stage <span class="dt">B.ByteString</span>], <span class="co">-- ^ Constants pool item indexes for implemented interfaces</span>
<span class="ot">  classFieldsCount ::</span> <span class="dt">Word16</span>,              <span class="co">-- ^ Number of class fileds</span>
<span class="ot">  classFields ::</span> [<span class="dt">Field</span> stage],            <span class="co">-- ^ Class fields</span>
<span class="ot">  classMethodsCount ::</span> <span class="dt">Word16</span>,             <span class="co">-- ^ Number of class methods</span>
<span class="ot">  classMethods ::</span> [<span class="dt">Method</span> stage],          <span class="co">-- ^ Class methods</span>
<span class="ot">  classAttributesCount ::</span> <span class="dt">Word16</span>,          <span class="co">-- ^ Number of class attributes</span>
<span class="ot">  classAttributes ::</span> <span class="dt">Attributes</span> stage      <span class="co">-- ^ Class attributes</span>
  }</code></pre></div>
<p>It is declared as an instance of <a href="http://hackage.haskell.org/package/binary-0.7.1.0/docs/Data-Binary.html">Binary</a> class for serialization. Its put method uses the record wildcards syntax not to repeat field names as in the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Binary</span> (<span class="dt">Class</span> <span class="dt">File</span>) <span class="kw">where</span>
  put (<span class="dt">Class</span> {<span class="fu">..</span>}) <span class="fu">=</span> <span class="kw">do</span>
    put magic
    put minorVersion
    put majorVersion
    putPool constsPool
    put accessFlags
    put thisClass
    put superClass
    put interfacesCount
    forM_ interfaces put
    put classFieldsCount
    forM_ classFields put
    put classMethodsCount
    forM_ classMethods put
    put classAttributesCount
    forM_ (attributesList classAttributes) put</code></pre></div>
<p>You can see the real difference by comparing this with a more verbose version which does not use record wildcards.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Binary</span> (<span class="dt">Class</span> <span class="dt">File</span>) <span class="kw">where</span>
  put (<span class="dt">Class</span> {magic<span class="fu">=</span>magic, minorVersion<span class="fu">=</span>minorVersion, majorVersion<span class="fu">=</span>majorVersion, constsPool<span class="fu">=</span>constsPool, accessFlags<span class="fu">=</span>accessFlags, thisCla    ss<span class="fu">=</span>thisClass, superClass<span class="fu">=</span>superClass, interfacesCount<span class="fu">=</span>interfacesCount, interfaces<span class="fu">=</span>interfaces, classFieldsCount<span class="fu">=</span>classFieldsCount, classFie    lds<span class="fu">=</span>classFields, classMethodsCount<span class="fu">=</span>classMethodsCount, classMethods<span class="fu">=</span>classMethods, classAttributesCount<span class="fu">=</span>classAttributesCount, classAttributes<span class="fu">=</span>classAttributes}) <span class="fu">=</span> <span class="kw">do</span>
 <span class="fu">...</span></code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
    this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>

</feed>
