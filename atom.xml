<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Haskell for Pragmatic Programmers</title>
    <link href="http://kseo.github.io//atom.xml" rel="self" />
    <link href="http://kseo.github.io/" />
    <id>http://kseo.github.io//atom.xml</id>
    <author>
        <name>Kwang Yul Seo</name>
        <email>kwangyul.seo@gmail.com</email>
    </author>
    <updated>2017-01-12T00:00:00Z</updated>
    <entry>
    <title>Indexed Monads</title>
    <link href="http://kseo.github.io//posts/2017-01-12-indexed-monads.html" />
    <id>http://kseo.github.io//posts/2017-01-12-indexed-monads.html</id>
    <published>2017-01-12T00:00:00Z</published>
    <updated>2017-01-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January 12, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/indexed.html">indexed</a>, <a href="/tags/monad.html">monad</a>
      
  </div>

<p>In this post, I am going to introduce <em>indexed monads</em>, which generalize monads with additional type parameters carrying the information about the computational effects.</p>
<h1 id="motivation">Motivation</h1>
<p>The State monad represents computations with a state that can be queried and updated. For example, an <code>Int</code> state is queried and updated during the computation of <code>c</code> in the following example. While the value of the state is changed from <code>0</code> to <code>1</code>, the type of the state remains the same during the entire computation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.State</span>

test1 <span class="fu">=</span> runState c (<span class="dv">0</span><span class="ot">::</span><span class="dt">Int</span>) <span class="kw">where</span>
         c <span class="fu">=</span> <span class="kw">do</span>
             v <span class="ot">&lt;-</span> get
             put (succ v)
             return v
<span class="co">-- (0, 1)</span></code></pre></div>
<p>This is okay in most cases, but we sometimes want to express a computation where not only the value but also the type of the state can be changed. The vanilla State monad is not general enough to express this requirement.</p>
<h1 id="indexed-monads">Indexed Monads</h1>
<p>Indexed monads are a generalization of monads that index each monadic type by an initial (type)state and a final (type)state. <code>m</code> is a type constructor for three type arguments, <code>p</code>, <code>q</code> and <code>a</code>. The argument <code>a</code> is the type of values produced by the monadic computation. <code>p</code> and <code>q</code> represent the types of the state before and after the computation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">IxMonad</span> m <span class="kw">where</span>
<span class="ot">    ireturn ::</span> a <span class="ot">-&gt;</span> m p p a
<span class="ot">    ibind ::</span> m p q a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m q r b) <span class="ot">-&gt;</span> m p r b</code></pre></div>
<p><code>ireturn</code> and <code>ibind</code> must meet the monad laws as the ordinary monads do. <code>ibind</code> is required to be associative and <code>ireturn</code> to be the left and the right unit of <code>ibind</code>.</p>
<p>All ordinary monads can be injected into <code>IxMonad</code> with a newtype wrapper <code>MW</code>. It is a <em>phantom type</em> as the type parameters <code>p</code> and <code>q</code> are not used on the right hand-side of <code>MW</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">MW</span> m p q a <span class="fu">=</span> <span class="dt">MW</span> {<span class="ot"> unMW::</span> m a }

<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">IxMonad</span> (<span class="dt">MW</span> m) <span class="kw">where</span>
    ireturn <span class="fu">=</span> <span class="dt">MW</span> <span class="fu">.</span> return
    ibind (<span class="dt">MW</span> m) f <span class="fu">=</span> <span class="dt">MW</span> (m <span class="fu">&gt;&gt;=</span> unMW <span class="fu">.</span> f)</code></pre></div>
<p>Here is an example of using the ordinary <code>State</code> monad wrapped with <code>MW</code>. <code>iget</code> and <code>iput</code> wraps the result with <code>MW</code> newtype wrapper.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">iget ::</span> (<span class="dt">MonadState</span> s m) <span class="ot">=&gt;</span> <span class="dt">MW</span> m s s s
iget <span class="fu">=</span> <span class="dt">MW</span> get

<span class="ot">iput ::</span> (<span class="dt">MonadState</span> s m) <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">MW</span> m s s ()
iput <span class="fu">=</span> <span class="dt">MW</span> <span class="fu">.</span> put

test2 <span class="fu">=</span> runState (unMW c) (<span class="dv">0</span><span class="ot">::</span><span class="dt">Int</span>) <span class="kw">where</span>
         c <span class="fu">=</span> iget <span class="ot">`ibind`</span> (
               \v <span class="ot">-&gt;</span> iput (succ v) <span class="ot">`ibind`</span> (
                 \_ <span class="ot">-&gt;</span> ireturn v))
<span class="co">-- (0, 1)</span></code></pre></div>
<h1 id="indexed-state-monad">Indexed State Monad</h1>
<p><code>IxStateT</code> defines an indexed state monad where <code>si</code> and <code>so</code> represents the input and the output state type respectively. The definition of <code>IxStateT</code> is similar to that of <code>StateT</code> except that the type of the state can be changed during the computation.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">IxStateT</span> m si so v <span class="fu">=</span> <span class="dt">IxStateT</span> {<span class="ot"> runIxStateT::</span> si <span class="ot">-&gt;</span> m (so,v) }

<span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">IxMonad</span> (<span class="dt">IxStateT</span> m) <span class="kw">where</span>
  ireturn x <span class="fu">=</span> <span class="dt">IxStateT</span> (\si <span class="ot">-&gt;</span> return (si,x))
  ibind (<span class="dt">IxStateT</span> m) f <span class="fu">=</span> <span class="dt">IxStateT</span> (\si <span class="ot">-&gt;</span> m si <span class="fu">&gt;&gt;=</span> (\ (sm,x) <span class="ot">-&gt;</span> runIxStateT (f x) sm))

<span class="ot">vsget ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">IxStateT</span> m si si si
vsget <span class="fu">=</span> <span class="dt">IxStateT</span> (\si <span class="ot">-&gt;</span> return (si,si))

<span class="ot">vsput ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> so <span class="ot">-&gt;</span> <span class="dt">IxStateT</span> m si so ()
vsput x <span class="fu">=</span> <span class="dt">IxStateT</span> (\si <span class="ot">-&gt;</span> return (x,()))</code></pre></div>
<p>The following example gets an <code>Int</code> from the state and puts a <code>String</code> into the state. We can see that the type of the state is changed from <code>Int</code> to <code>String</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">test3 <span class="fu">=</span> runIxStateT c (<span class="dv">0</span><span class="ot">::</span><span class="dt">Int</span>) <span class="fu">&gt;&gt;=</span> print <span class="kw">where</span>
         c <span class="fu">=</span> vsget <span class="ot">`ibind`</span> (
               \v <span class="ot">-&gt;</span> vsput (show v) <span class="ot">`ibind`</span> (
                 \_ <span class="ot">-&gt;</span> vsget <span class="ot">`ibind`</span> (
                   \v&#39; <span class="ot">-&gt;</span> ireturn (v,v&#39;))))
<span class="co">-- (&quot;A&quot;,(0,&quot;0&quot;))</span></code></pre></div>
<h1 id="do-notation">Do notation</h1>
<p>The <code>IxMonad</code> examples above looks ugly as we couldn’t use the do notation. Fortunately, <code>-XRebindableSyntax</code> extension allows us to overload the do-notation by providing alternative definitions that are local to the module.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RebindableSyntax #-}</span>

<span class="kw">import </span><span class="dt">Prelude</span> <span class="kw">hiding</span> ((&gt;&gt;=), (&gt;&gt;), return)
<span class="kw">import </span><span class="dt">IxState</span>

return<span class="ot"> ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IxStateT</span> m si si a
return <span class="fu">=</span> ireturn

<span class="ot">(&gt;&gt;=) ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">IxStateT</span> m p q a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IxStateT</span> m q r b) <span class="ot">-&gt;</span> <span class="dt">IxStateT</span> m p r b
(<span class="fu">&gt;&gt;=</span>) <span class="fu">=</span> ibind

<span class="ot">(&gt;&gt;) ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">IxStateT</span> m p q a <span class="ot">-&gt;</span> <span class="dt">IxStateT</span> m q r b <span class="ot">-&gt;</span> <span class="dt">IxStateT</span> m p r b
v <span class="fu">&gt;&gt;</span> w <span class="fu">=</span> v <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> w

<span class="ot">c ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">IxStateT</span> m <span class="dt">Int</span> <span class="dt">String</span> (<span class="dt">Int</span>, <span class="dt">String</span>)
c <span class="fu">=</span> <span class="kw">do</span>
  v <span class="ot">&lt;-</span> vsget
  vsput (show v)
  v&#39; <span class="ot">&lt;-</span> vsget
  return (v, v&#39;)</code></pre></div>
<h1 id="other-definitions">Other definitions</h1>
<p>There are multiple ways to define indexed monads. The one used here is from Robert Atkey’s <a href="http://bentnib.org/paramnotions-jfp.pdf">Parameterised Notions of Computation</a>.</p>
<p>Other definitions include:</p>
<ul>
<li>McBride: <a href="https://personal.cis.strath.ac.uk/conor.mcbride/Kleisli.pdf">Kleisli Arrows of Outrageous Fortune</a></li>
<li>Orchard: <a href="http://www.cl.cam.ac.uk/~dao29/ixmonad/ixmonad-fita14.pdf">Fun with indexed monads</a></li>
</ul>
<h1 id="references">References</h1>
<ol style="list-style-type: decimal">
<li>Oleg Kiselyov’s <a href="http://okmij.org/ftp/Computation/monads.html#param-monad">Parameterized `monad’</a></li>
<li><a href="http://dev.stephendiehl.com/hask/#indexed-monads">Indexed Monad section</a> of Stephen Diehl’s What I Wish I Knew When Learning Haskell</li>
</ol>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-12-indexed-monads.html";
    this.page.identifier = "/posts/2017-01-12-indexed-monads.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Double-barrelled Continuation Passing Style Interpreter</title>
    <link href="http://kseo.github.io//posts/2017-01-10-double-barrelled-continuation-passing-style-interpreter.html" />
    <id>http://kseo.github.io//posts/2017-01-10-double-barrelled-continuation-passing-style-interpreter.html</id>
    <published>2017-01-10T00:00:00Z</published>
    <updated>2017-01-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January 10, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/double-barrelled.html">double-barrelled</a>, <a href="/tags/CPS.html">CPS</a>, <a href="/tags/interpreter.html">interpreter</a>
      
  </div>

<p>In the <a href="https://kseo.github.io/posts/2017-01-09-continuation-passing-style-interpreter.html">Continuation Passing Style Interpreter</a>, we wrote a continuation-passing style interpreter for a small functional language and implemented the <em>escape expression</em> which is the binder form of Scheme’s <em>call/cc</em>.</p>
<p>Though <em>call/cc</em> is a powerful control operator, it is generally considered as a <a href="http://okmij.org/ftp/continuations/against-callcc.html">bad abstraction</a> as a core language feature. So, in this post, we will drop escape expressions and add ML-style exceptions.</p>
<p>Exceptions can be used to effect non-local transfers of control. By using an <em>exception handler</em> we may “catch” a raised exception and continue evaluation. For example,</p>
<pre><code>1 + (raise 2)
handle \x -&gt; x + 3</code></pre>
<p>evaluates to <code>5</code> because <code>2</code> raised by <code>raise 2</code> is passed to the exception handler <code>\x -&gt; x + 3</code>.</p>
<p>To support exceptions in our interpreter, <code>eval</code> function is modified to take two continuations: an exception-handler continuation, and a return continuation. This is the so-called <em>double-barrelled continuation-passing style</em> introduced in <a href="http://www.cs.bham.ac.uk/~hxt/research/HOSC-double-barrel.pdf">Comparing Control Constructs by Double-barrelled CPS</a>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eval ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
eval env term h k <span class="fu">=</span> <span class="kw">case</span> term <span class="kw">of</span>
  <span class="dt">Var</span> n <span class="ot">-&gt;</span> k <span class="fu">$</span> env <span class="fu">!!</span> n
  <span class="dt">Lam</span> a <span class="ot">-&gt;</span> k <span class="fu">$</span> <span class="dt">VClosure</span> (\v k&#39; <span class="ot">-&gt;</span> eval (v <span class="fu">:</span> env) a h k&#39;)
  <span class="dt">App</span> a b <span class="ot">-&gt;</span>
    eval env a h <span class="fu">$</span> \(<span class="dt">VClosure</span> c) <span class="ot">-&gt;</span>
    eval env b h <span class="fu">$</span> \v <span class="ot">-&gt;</span>
    c v k

  <span class="dt">Lit</span> n <span class="ot">-&gt;</span> k <span class="fu">$</span> <span class="dt">VInt</span> n
  <span class="dt">Prim</span> p a b <span class="ot">-&gt;</span> eval env a h <span class="fu">$</span> \v1 <span class="ot">-&gt;</span>
                eval env b h <span class="fu">$</span> \v2 <span class="ot">-&gt;</span>
                k <span class="fu">$</span> evalPrim p v1 v2

<span class="ot">evalExpr ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
evalExpr e <span class="fu">=</span> eval emptyEnv e (\x <span class="ot">-&gt;</span> error <span class="st">&quot;uncaught exception&quot;</span>) id</code></pre></div>
<p><code>h</code> is the exception-handler continuation and it is simply passed along the application of <code>eval</code>. <code>evalExpr</code> is also modified to handle an uncaught exception.</p>
<p>Once our interpreter is transformed into a double-barrelled continuation-passing style, it is easy to add handle and raise expressions. First, let’s extend <code>Expr</code> with <code>Handle</code> and <code>Raise</code> nodes.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="fu">...</span>
  <span class="fu">|</span> <span class="dt">Handle</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Raise</span> <span class="dt">Expr</span>
  <span class="fu">...</span></code></pre></div>
<p>Then extend <code>eval</code> function with two additional AST nodes.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eval ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
eval env term h k <span class="fu">=</span> <span class="kw">case</span> term <span class="kw">of</span>
  <span class="fu">...</span>
  <span class="dt">Raise</span> a <span class="ot">-&gt;</span> eval env a h h
  <span class="dt">Handle</span> a b <span class="ot">-&gt;</span>
    <span class="kw">let</span> h&#39; x <span class="fu">=</span> eval (x <span class="fu">:</span> env) b h k
    <span class="kw">in</span> eval env a h&#39; k</code></pre></div>
<p><code>Raise</code> evaluates <code>a</code> with both continuations set to the error-handler continuation <code>h</code>. So the value is passed to the current error-handler.</p>
<p><code>Handle</code> sets up a new error-handler <code>h'</code> which evaluates <code>b</code> with the environment extended with the raised value <code>x</code>. Note that <code>a</code> is evaluated with the error-handler set to <code>h'</code> so that any exception raised while evaluating <code>a</code> is passed to <code>h'</code>.</p>
<p>Let’s run the example above!</p>
<pre><code>λ&gt; evalExpr $ (Prim Add (Lit 1) (Raise (Lit 2))) `Handle` (Prim Add (Var 0) (Lit 3))
5</code></pre>
<p>Yay, it works again!</p>
<p>If you would like to know why we can’t implement exceptions using <em>call/cc</em> alone, please read Oleg Kiselyov’s article <a href="http://okmij.org/ftp/continuations/undelimited.html#delim-vs-undelim">Vast difference between delimited and undelimited continuations</a>.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-10-double-barrelled-continuation-passing-style-interpreter.html";
    this.page.identifier = "/posts/2017-01-10-double-barrelled-continuation-passing-style-interpreter.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Continuation Passing Style Interpreter</title>
    <link href="http://kseo.github.io//posts/2017-01-09-continuation-passing-style-interpreter.html" />
    <id>http://kseo.github.io//posts/2017-01-09-continuation-passing-style-interpreter.html</id>
    <published>2017-01-09T00:00:00Z</published>
    <updated>2017-01-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January  9, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/CPS.html">CPS</a>, <a href="/tags/interpreter.html">interpreter</a>
      
  </div>

<p>Lisp programmers learn Lisp by writing various flavors of Lisp interpreters. Two famous Lisp books, <a href="https://www.amazon.com/Lisp-Small-Pieces-Christian-Queinnec/dp/0521545668">Lisp in Small Pieces</a> and <a href="http://www.eopl3.com/">Essentials of Programming Languages</a>, teach us how to write Lisp interpreters in Lisp. Both books start with a direct style interpreter which is easy to implement. But they soon rewrite the interpreter in a continuation passing style because advanced control structures such as <em>abort</em> and <em>call/cc</em> can be implemented more easily in this style.</p>
<p>In this post, we will follow the tradition of Lisp and will write a continuation passing style interpreter for a small functional language in Haskell. Then we will see how easily we can add <em>escape expression</em> to the language by extending the interpreter.</p>
<h1 id="direct-style-interpreter">Direct-style Interpreter</h1>
<p>Our first interpreter is a straightforward implementation of the enriched lambda calculus <code>Expr</code>. It extends the lambda calculus with integer literals and primitive operators.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Lam</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Lit</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Prim</span> <span class="dt">PrimOp</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">data</span> <span class="dt">PrimOp</span> <span class="fu">=</span> <span class="dt">Add</span> <span class="fu">|</span> <span class="dt">Mul</span>
  <span class="kw">deriving</span> <span class="dt">Show</span></code></pre></div>
<p>The central component of our interpreter is a function <code>eval</code> that produces the value of an expression <code>term</code> in an environment <code>env</code>. <code>n</code> in <code>Var n</code> is the <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">De Bruijn index</a>. The <a href="http://dev.stephendiehl.com/fun/005_evaluation.html">Evaluation</a> chapter of Stephen Diehl’s <a href="http://dev.stephendiehl.com/fun/index.html">Write You a Haskell</a> explains the details of this direct-style interpreter. There is one difference here. Our version uses a higher-order function to represent lambda expression (<code>VClosure</code>).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Value</span>
  <span class="fu">=</span> <span class="dt">VInt</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">VClosure</span> (<span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>)

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Value</span> <span class="kw">where</span>
  show (<span class="dt">VInt</span> i) <span class="fu">=</span> show i
  show <span class="dt">VClosure</span>{} <span class="fu">=</span> <span class="st">&quot;&lt;&lt;closure&gt;&gt;&quot;</span>

<span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> [<span class="dt">Value</span>]

<span class="ot">eval ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
eval env term <span class="fu">=</span> <span class="kw">case</span> term <span class="kw">of</span>
  <span class="dt">Var</span> n <span class="ot">-&gt;</span> env <span class="fu">!!</span> n
  <span class="dt">Lam</span> a <span class="ot">-&gt;</span> <span class="dt">VClosure</span> (\v <span class="ot">-&gt;</span> eval (v <span class="fu">:</span> env) a)
  <span class="dt">App</span> a b <span class="ot">-&gt;</span>
    <span class="kw">let</span> <span class="dt">VClosure</span> c <span class="fu">=</span> eval env a <span class="kw">in</span>
    <span class="kw">let</span> v <span class="fu">=</span> eval env b <span class="kw">in</span>
    c v

  <span class="dt">Lit</span> n <span class="ot">-&gt;</span> <span class="dt">VInt</span> n
  <span class="dt">Prim</span> p a b <span class="ot">-&gt;</span> (evalPrim p) (eval env a) (eval env b)

<span class="ot">evalPrim ::</span> <span class="dt">PrimOp</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
evalPrim <span class="dt">Add</span> (<span class="dt">VInt</span> a) (<span class="dt">VInt</span> b) <span class="fu">=</span> <span class="dt">VInt</span> (a <span class="fu">+</span> b)
evalPrim <span class="dt">Mul</span> (<span class="dt">VInt</span> a) (<span class="dt">VInt</span> b) <span class="fu">=</span> <span class="dt">VInt</span> (a <span class="fu">*</span> b)

<span class="ot">emptyEnv ::</span> <span class="dt">Env</span>
emptyEnv <span class="fu">=</span> []

<span class="ot">evalExpr ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
evalExpr <span class="fu">=</span> eval emptyEnv</code></pre></div>
<h1 id="continuation-passing-style-interpreter">Continuation-passing-style Interpreter</h1>
<p>We can think of a continuation as what to do next in a program. In direct-style, a callee returns a value to the caller. Thus the caller of the function determines what to do next and the continuation is implicitly present in the caller. In continuation-passing-style, the continuation is passed as an argument of a function and the callee determines what to do next by invoking the continuation. A function in continuation-passing-style never returns.</p>
<p>We can transform our interpreter into a continuation-passing-style by adding a continuation argument <code>Cont</code> to <code>eval</code> and <code>VClosure</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Cont</span> <span class="fu">=</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>

<span class="kw">data</span> <span class="dt">Value</span>
  <span class="fu">=</span> <span class="fu">...</span>
  <span class="fu">|</span> <span class="dt">VClosure</span> (<span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>)

<span class="ot">eval ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
eval env term k <span class="fu">=</span> <span class="kw">case</span> term <span class="kw">of</span>
  <span class="dt">Var</span> n <span class="ot">-&gt;</span> k <span class="fu">$</span> env <span class="fu">!!</span> n
  <span class="dt">Lam</span> a <span class="ot">-&gt;</span> k <span class="fu">$</span> <span class="dt">VClosure</span> (\v k&#39; <span class="ot">-&gt;</span> eval (v <span class="fu">:</span> env) a k&#39;)
  <span class="dt">App</span> a b <span class="ot">-&gt;</span>
    eval env a <span class="fu">$</span> \(<span class="dt">VClosure</span> c) <span class="ot">-&gt;</span>
    eval env b <span class="fu">$</span> \v <span class="ot">-&gt;</span>
    c v k

  <span class="dt">Lit</span> n <span class="ot">-&gt;</span> k <span class="fu">$</span> <span class="dt">VInt</span> n
  <span class="dt">Prim</span> p a b <span class="ot">-&gt;</span> eval env a <span class="fu">$</span> \v1 <span class="ot">-&gt;</span>
                eval env b <span class="fu">$</span> \v2 <span class="ot">-&gt;</span>
                k <span class="fu">$</span> evalPrim p v1 v2

<span class="ot">evalExpr ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
evalExpr e <span class="fu">=</span> eval emptyEnv e id</code></pre></div>
<p>In <code>Var</code>, <code>Lit</code> and <code>Lam</code> cases, <code>eval</code> simply applies the value to the continuation. In <code>App</code> case, <code>eval</code> evaluates the function first and then subsequently evaluates the argument. The evaluation order is enforced as only one value can be passed to the continuation. <code>c v</code> applies the argument to the function and its result is passed to the original continuation <code>k</code>. <code>Prim</code> case similarly enforces the left-to-right evaluation order.</p>
<p><code>evalExpr</code> passes <code>id</code> as the initial continuation which merely returns the value back.</p>
<h1 id="escape-expression">Escape Expression</h1>
<p>Because all the control paths are explicit in continuation-passing-style, we can easily add control operators to our interpreter. Let’s extend our interpreter with <em>escape expressions</em> that was first introduced in <a href="http://surface.syr.edu/cgi/viewcontent.cgi?article=1012&amp;context=lcsmith_other">Definitional interpreters for higher-order programming languages</a>.</p>
<pre><code>escape x in r</code></pre>
<p>is an escape expression, whose <em>escape variable</em> is <code>x</code> and whose <em>body</em> is <code>r</code>. If <code>x</code> is applied to <code>a</code> in <code>r</code>, the body is aborted and <code>a</code> is returned. Otherwise, the evaluation of <code>r</code> proceeds normally.</p>
<pre><code>escape x in (1 + 3) * (4 + x 10)</code></pre>
<p>evaluates to <code>10</code> because <code>x</code> is applied to <code>10</code> inside the escape expression.</p>
<p>The implementation of the escape expression is one-liner. <code>eval</code> of <code>Escape a</code> adds a closure to the environment and then evaluates the expression. This closure is a reified continuation which ignores the current continuation and passes the argument as a value to the saved continuation of the escape expression.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="fu">...</span>
  <span class="fu">|</span> <span class="dt">Escape</span> <span class="dt">Expr</span>
  <span class="fu">...</span>

<span class="ot">eval ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
eval env term k <span class="fu">=</span> <span class="kw">case</span> term <span class="kw">of</span>
  <span class="fu">...</span>
  <span class="dt">Escape</span> a <span class="ot">-&gt;</span> eval (<span class="dt">VClosure</span> (\v _ <span class="ot">-&gt;</span> k v) <span class="fu">:</span> env) a k</code></pre></div>
<pre><code>λ&gt; evalExpr $ Escape (Prim Mul (Prim Add (Lit 1) (Lit 3)) (Prim Add (Lit 4) (App (Var 0) (Lit 10))))
10</code></pre>
<p>Yay, it works!</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-09-continuation-passing-style-interpreter.html";
    this.page.identifier = "/posts/2017-01-09-continuation-passing-style-interpreter.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Visible Type Application in GHC 8</title>
    <link href="http://kseo.github.io//posts/2017-01-08-visible-type-application-ghc8.html" />
    <id>http://kseo.github.io//posts/2017-01-08-visible-type-application-ghc8.html</id>
    <published>2017-01-08T00:00:00Z</published>
    <updated>2017-01-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January  8, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/TypeApplications.html">TypeApplications</a>
      
  </div>

<p>GHC 8.0 introduced a new GHC extension named <a href="https://ghc.haskell.org/trac/ghc/wiki/TypeApplication">TypeApplications</a> which allows us to give explicit type arguments to a polymorphic function.</p>
<p>To see what <code>TypeApplications</code> does, we need to understand how polymorphism in Haskell is implemented under the hood. In Haskell, a polymorphic function is translated into a function which takes both type arguments and value arguments. For example,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">id<span class="ot"> ::</span> a <span class="ot">-&gt;</span> a
id x <span class="fu">=</span> x</code></pre></div>
<p>is translated into</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">id<span class="ot"> ::</span> forall a <span class="fu">.</span> a <span class="ot">-&gt;</span> a
id <span class="fu">@</span>a x <span class="fu">=</span> x</code></pre></div>
<p>Here <code>@a</code> is the type argument. The specialization of <code>id</code> to <code>idString</code> is represented by passing <code>@String</code> type argument to <code>id</code> function.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">idString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
idString <span class="fu">=</span> id <span class="fu">@</span><span class="dt">String</span></code></pre></div>
<p>This is not an ad-hoc way to implement polymorphism. The trick of passing around type parameters as ordinary function arguments was devised by <em>System F</em> (as known as the <em>polymorphic lambda calculus</em>) and GHC uses System F as its internal representation. An interested reader might want to take a look at Gabriel Gonzalez’s <a href="http://www.haskellforall.com/2015/10/polymorphism-for-dummies.html">Polymorphism for dummies</a> for other examples.</p>
<p>Before GHC 8.0, the type application was invisible. There was no way to pass the type parameter such as <code>@String</code> and <code>@Int</code> explicitly. GHC infers the type from the argument type, or we had to specify the type using type annotations.</p>
<pre><code>λ&gt; id &quot;a&quot;
&quot;a&quot;
λ&gt; id (3 :: Int)
3</code></pre>
<p><code>TypeApplications</code> extension allows us to give explicit type arguments.</p>
<pre><code>λ&gt; :set -XTypeApplications
λ&gt; id @String &quot;a&quot;
&quot;a&quot;
λ&gt; id @Int 3
3</code></pre>
<p>This is useful in resolving ambiguity in type classes or type families. The show/read problem from <a href="https://kseo.github.io/posts/2017-01-04-type-defaulting-in-haskell.html">Type defaulting in Haskell</a> was not typeable due to ambiguity, but we can easily remove ambiguity by giving an explicit type argument.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeApplications #-}</span>

<span class="ot">f ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
f s <span class="fu">=</span> show (read <span class="fu">@</span><span class="dt">Int</span> s)</code></pre></div>
<p>The type argument is not limited to concrete types. As we can pass a variable to a function as an argument, it is possible to pass a type variable to a function as a type argument if it is explicitly quantified with <code>ExplicitForAll</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ExplicitForAll      #-}</span>
<span class="ot">{-# LANGUAGE TypeApplications    #-}</span>

<span class="ot">incShow ::</span> forall a <span class="fu">.</span> (<span class="dt">Read</span> a, <span class="dt">Show</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
incShow <span class="fu">=</span> show <span class="fu">.</span> (<span class="fu">+</span><span class="dv">1</span>) <span class="fu">.</span> read <span class="fu">@</span>a</code></pre></div>
<pre><code>λ&gt; incShow @Double &quot;3.0&quot;
&quot;4.0&quot;`</code></pre>
<p>In the following example, <code>g False</code> would be ill-typed because GHC can’t infer the proper type. Adding the explicit type <code>@Char</code> resolves the problem.</p>
<pre><code>type family F a
type instance F Char = Bool

g :: F a -&gt; a
g _ = undefined

f :: Char
f = g True

h = g False -- will cause an error
h&#39; = g @Char False</code></pre>
<p>Some of these cases can be solved with type annotations, but it can be cumbersome in complicated examples. Visible type applications generally provide a more succinct way to resolve ambiguity.</p>
<p>If you would like to know the technical details of <code>TypeApplications</code>, please refer to <a href="https://www.seas.upenn.edu/~sweirich/papers/type-app-extended.pdf">Visible Type Application (Extended version)</a>.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-08-visible-type-application-ghc8.html";
    this.page.identifier = "/posts/2017-01-08-visible-type-application-ghc8.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Strict Identity Monad</title>
    <link href="http://kseo.github.io//posts/2017-01-07-strict-identity-monad.html" />
    <id>http://kseo.github.io//posts/2017-01-07-strict-identity-monad.html</id>
    <published>2017-01-07T00:00:00Z</published>
    <updated>2017-01-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January  7, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/identity%20monad.html">identity monad</a>, <a href="/tags/lazy.html">lazy</a>, <a href="/tags/strict.html">strict</a>
      
  </div>

<p>In my <a href="https://kseo.github.io/posts/2016-12-28-lazy-vs-strict-state-monad.html">previous post</a>, I explained the difference between the lazy and strict state monads. What I didn’t mention in the post is that the state monad is not special in this regard. Other monads also can have both lazy and strict variants. For example, <a href="https://www.stackage.org/lts-7.12/package/transformers-0.5.2.0">transformers</a> package provides both flavors of monads for <code>RWS</code> and <code>Writer</code> monads too.</p>
<p>It is also possible to have identity monads with either lazy or strict semantics. <em>transformers</em> package provides only the lazy variant, but it is not hard to image a strict variant of the identity monad. Here’s the definition of <code>Control.Monad.StrictIdentity</code> defined in <a href="https://hackage.haskell.org/package/strict-identity">strict-identity</a> package.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">StrictIdentity</span> a <span class="fu">=</span>  <span class="dt">StrictIdentity</span> {<span class="ot">runStrictIdentity_ ::</span> a }

<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">StrictIdentity</span> <span class="kw">where</span>
    return <span class="fu">!</span>a <span class="fu">=</span> <span class="dt">StrictIdentity</span> <span class="fu">$!</span> a
    (<span class="fu">!</span>m) <span class="fu">&gt;&gt;=</span> (<span class="fu">!</span>k)  <span class="fu">=</span> k <span class="fu">$!</span> runStrictIdentity  m</code></pre></div>
<p>The strict identity monad when bound to a function always evaluate its argument. We can see that both <a href="https://ocharles.org.uk/blog/posts/2014-12-05-bang-patterns.html">BangPatterns</a> and the strict application operator <code>($!)</code> are used to enforce strict evaluation of arguments.</p>
<p>In this sense, <a href="https://www.stackage.org/haddock/lts-7.12/parallel-3.2.1.0/Control-Parallel-Strategies.html#t:Eval">Eval</a> monad from <code>Control.Parallel.Strategies</code> is also an identity monad. It enforces the strict evaluation of the argument with pattern matching.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Eval</span> a <span class="fu">=</span> <span class="dt">Done</span> a

<span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Eval</span> <span class="kw">where</span>
  return x <span class="fu">=</span> <span class="dt">Done</span> x
  <span class="dt">Done</span> x <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> k x   <span class="co">-- Note: pattern &#39;Done x&#39; makes &#39;&gt;&gt;=&#39; strict</span></code></pre></div>
<p>In <a href="https://kseo.github.io/posts/2017-01-05-implementing-a-call-by-value-interpreter-in-haskell.html">Implementing a call-by-value interpreter in Haskell</a>, I mistakenly used the lazy identity monad to force the evaluation order. We need to keep in mind that transforming a program into a monadic form does not automatically guarantees the evaluation order unless the monad is strict.</p>
<p><strong>UPDATE</strong>: Calling arbitrary monads lazy or strict is not appropriate as each monad has varying degree of strictness. For example, the <code>StrictIdentity</code> is more strict than the <code>Eval</code> monad. See <a href="https://www.reddit.com/r/haskell/comments/5mp9e8/kwangs_haskell_blog_strict_identity_monad/">the Reddit discussion thread</a> for details.</p>
<pre><code>λ&gt; Control.Monad.StrictIdentity.runStrictIdentity $ do x &lt;- return undefined; return 1
*** Exception: Prelude.undefined
λ&gt; Control.Parallel.Strategies.runEval $ do x &lt;- return undefined; return 1
1</code></pre>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-07-strict-identity-monad.html";
    this.page.identifier = "/posts/2017-01-07-strict-identity-monad.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Implementing a call-by-value interpreter in Haskell</title>
    <link href="http://kseo.github.io//posts/2017-01-05-implementing-a-call-by-value-interpreter-in-haskell.html" />
    <id>http://kseo.github.io//posts/2017-01-05-implementing-a-call-by-value-interpreter-in-haskell.html</id>
    <published>2017-01-05T00:00:00Z</published>
    <updated>2017-01-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January  5, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/call-by-value.html">call-by-value</a>, <a href="/tags/interpreter.html">interpreter</a>, <a href="/tags/Strict.html">Strict</a>
      
  </div>

<p>Call-by-value is the most commonly used evaluation strategy in which all arguments to a function are reduced to normal form before they are bound inside lambda. Languages such as Java, C++, Scala and F# all use this evaluation model. A notable exception is Haskell, which uses call-by-need evaluation in which expressions are represented as <em>thunks</em> which are passed into a function unevaluated and only evaluated when needed.</p>
<p>This difference in evaluation model poses some challenges in writing a call-by-value interpreter in Haskell. In this post, I am going to explain how we can implement a call-by-value interpreter using various methods.</p>
<p>Let’s start the discussion by writing a lambda calculus interpreter.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Lam</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Lit</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Prim</span> <span class="dt">PrimOp</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Bot</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">data</span> <span class="dt">Value</span>
  <span class="fu">=</span> <span class="dt">VInt</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">VClosure</span> <span class="dt">Expr</span> <span class="dt">Env</span>

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Value</span> <span class="kw">where</span>
  show (<span class="dt">VInt</span> i) <span class="fu">=</span> show i
  show <span class="dt">VClosure</span>{} <span class="fu">=</span> <span class="st">&quot;&lt;&lt;closure&gt;&gt;&quot;</span>

<span class="kw">data</span> <span class="dt">PrimOp</span> <span class="fu">=</span> <span class="dt">Add</span> <span class="fu">|</span> <span class="dt">Mul</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> [<span class="dt">Value</span>]

<span class="ot">eval ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
eval env term <span class="fu">=</span> <span class="kw">case</span> term <span class="kw">of</span>
  <span class="dt">Var</span> n <span class="ot">-&gt;</span> env <span class="fu">!!</span> n
  <span class="dt">Lam</span> a <span class="ot">-&gt;</span> <span class="dt">VClosure</span> a env
  <span class="dt">App</span> a b <span class="ot">-&gt;</span>
    <span class="kw">let</span> <span class="dt">VClosure</span> c env&#39; <span class="fu">=</span> eval env a <span class="kw">in</span>
    <span class="kw">let</span> v <span class="fu">=</span> eval env b <span class="kw">in</span>
    eval (v <span class="fu">:</span> env&#39;) c

  <span class="dt">Lit</span> n <span class="ot">-&gt;</span> <span class="dt">VInt</span> n
  <span class="dt">Prim</span> p a b <span class="ot">-&gt;</span> (evalPrim p) (eval env a) (eval env b)
  <span class="dt">Bot</span> <span class="ot">-&gt;</span> error <span class="st">&quot;Evaluation would not terminate&quot;</span>

<span class="ot">evalPrim ::</span> <span class="dt">PrimOp</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
evalPrim <span class="dt">Add</span> (<span class="dt">VInt</span> a) (<span class="dt">VInt</span> b) <span class="fu">=</span> <span class="dt">VInt</span> (a <span class="fu">+</span> b)
evalPrim <span class="dt">Mul</span> (<span class="dt">VInt</span> a) (<span class="dt">VInt</span> b) <span class="fu">=</span> <span class="dt">VInt</span> (a <span class="fu">*</span> b)

<span class="ot">emptyEnv ::</span> <span class="dt">Env</span>
emptyEnv <span class="fu">=</span> []

<span class="co">-- (\x y -&gt; x) 10 bot</span>
<span class="ot">test ::</span> <span class="dt">Value</span>
test <span class="fu">=</span> eval emptyEnv <span class="fu">$</span> <span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Lam</span> (<span class="dt">Lam</span> (<span class="dt">Var</span> <span class="dv">1</span>))) (<span class="dt">Lit</span> <span class="dv">10</span>)) <span class="dt">Bot</span></code></pre></div>
<p>Can you guess the evaluation order implemented by this interpreter? Because <code>test</code> is equivalent to <code>(\x y -&gt; x) 10 undefined</code>, it would be <code>undefined</code> in a call-by-value language.</p>
<p>Let’s evaluate <code>test</code> on GHCi.</p>
<pre><code>λ&gt; test
10</code></pre>
<p>The evaluation order implemented by our interpreter is call-by-need because the defining language, Haskell, uses the call-by-need evaluation order and our interpreter depends on this. Transforming our interpreter into a call-by-value interpreter is not trivial because we need to find and fix every place where lazy evaluation is used in our interpreter.</p>
<p>In his seminar paper <a href="http://surface.syr.edu/cgi/viewcontent.cgi?article=1012&amp;context=lcsmith_other">Definitional interpreters for higher-order programming languages</a>, John C. Reynolds showed how to remove this order dependence by CPS transformation. <del>But in Haskell, we can use monads to enforce the evaluation order. This is not a coincidence because there is a <a href="https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/the-essence-of-functional-programming.pdf">close relationship</a> between computational monads and generalized CPS.</del></p>
<p><strong>UPDATE: There is a technical mistake in the original article. The Identity monad does not make any difference here. I should have used either a strict variant of Identity monad or the Cont monad to force strict evaluation.</strong></p>
<p>Here’s a monadic version of our interpreter.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Monad.Identity</span>

<span class="kw">data</span> <span class="dt">Expr</span>
  <span class="fu">=</span> <span class="dt">Var</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Lam</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Lit</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">Prim</span> <span class="dt">PrimOp</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
  <span class="fu">|</span> <span class="dt">Bot</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">data</span> <span class="dt">Value</span>
  <span class="fu">=</span> <span class="dt">VInt</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">VClosure</span> <span class="dt">Expr</span> <span class="dt">Env</span>

<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Value</span> <span class="kw">where</span>
  show (<span class="dt">VInt</span> i) <span class="fu">=</span> show i
  show <span class="dt">VClosure</span>{} <span class="fu">=</span> <span class="st">&quot;&lt;&lt;closure&gt;&gt;&quot;</span>

<span class="kw">data</span> <span class="dt">PrimOp</span> <span class="fu">=</span> <span class="dt">Add</span> <span class="fu">|</span> <span class="dt">Mul</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">type</span> <span class="dt">Env</span> <span class="fu">=</span> [<span class="dt">Value</span>]

<span class="ot">eval ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> m <span class="dt">Value</span>
eval env term <span class="fu">=</span> <span class="kw">case</span> term <span class="kw">of</span>
  <span class="dt">Var</span> n <span class="ot">-&gt;</span> return <span class="fu">$</span> env <span class="fu">!!</span> n
  <span class="dt">Lam</span> a <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">VClosure</span> a env
  <span class="dt">App</span> a b <span class="ot">-&gt;</span> <span class="kw">do</span>
    <span class="dt">VClosure</span> c env&#39; <span class="ot">&lt;-</span> eval env a
    v <span class="ot">&lt;-</span> eval env b
    eval (v <span class="fu">:</span> env&#39;) c

  <span class="dt">Lit</span> n <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">VInt</span> n
  <span class="dt">Prim</span> p a b <span class="ot">-&gt;</span> evalPrim p <span class="fu">&lt;$&gt;</span> eval env a <span class="fu">&lt;*&gt;</span> eval env b
  <span class="dt">Bot</span> <span class="ot">-&gt;</span> error <span class="st">&quot;Evaluation would not terminate&quot;</span>

<span class="ot">evalPrim ::</span> <span class="dt">PrimOp</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
evalPrim <span class="dt">Add</span> (<span class="dt">VInt</span> a) (<span class="dt">VInt</span> b) <span class="fu">=</span> <span class="dt">VInt</span> (a <span class="fu">+</span> b)
evalPrim <span class="dt">Mul</span> (<span class="dt">VInt</span> a) (<span class="dt">VInt</span> b) <span class="fu">=</span> <span class="dt">VInt</span> (a <span class="fu">*</span> b)

<span class="ot">emptyEnv ::</span> <span class="dt">Env</span>
emptyEnv <span class="fu">=</span> []

<span class="co">-- (\x y -&gt; x) 10 bot</span>
<span class="ot">test ::</span> <span class="dt">Value</span>
test <span class="fu">=</span> runIdentity <span class="fu">$</span> eval emptyEnv <span class="fu">$</span> <span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Lam</span> (<span class="dt">Lam</span> (<span class="dt">Var</span> <span class="dv">1</span>))) (<span class="dt">Lit</span> <span class="dv">10</span>)) <span class="dt">Bot</span></code></pre></div>
<p>Let’s evaluate <code>test</code> again.</p>
<pre><code>λ&gt; test
10</code></pre>
<p>Oops. What went wrong? The problem is that our interpreter does not enforce the evaluation of the argument in <code>App a b</code> case of <code>eval</code>. <code>v &lt;- eval env b</code> just binds a thunk to <code>v</code> and it won’t be evaluated until it is actually needed. To fix the problem, we need to force the evaluation of the argument using <em>bang patterns</em>.</p>
<p><strong>UPDATE: This bang pattern is not necessary if we used a strict monad.</strong></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE BangPatterns #-}</span>

<span class="fu">...</span>

<span class="ot">eval ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> m <span class="dt">Value</span>
eval env term <span class="fu">=</span> <span class="kw">case</span> term <span class="kw">of</span>
  <span class="dt">Var</span> n <span class="ot">-&gt;</span> return <span class="fu">$</span> env <span class="fu">!!</span> n
  <span class="dt">Lam</span> a <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">VClosure</span> a env
  <span class="dt">App</span> a b <span class="ot">-&gt;</span> <span class="kw">do</span>
    <span class="dt">VClosure</span> c env&#39; <span class="ot">&lt;-</span> eval env a
    <span class="fu">!</span>v <span class="ot">&lt;-</span> eval env b
    eval (v <span class="fu">:</span> env&#39;) c

  <span class="dt">Lit</span> n <span class="ot">-&gt;</span> return <span class="fu">$</span> <span class="dt">VInt</span> n
  <span class="dt">Prim</span> p a b <span class="ot">-&gt;</span> evalPrim p <span class="fu">&lt;$&gt;</span> eval env a <span class="fu">&lt;*&gt;</span> eval env b
  <span class="dt">Bot</span> <span class="ot">-&gt;</span> error <span class="st">&quot;Evaluation would not terminate&quot;</span>

<span class="fu">...</span></code></pre></div>
<p>Finally, we can see that evaluating <code>test</code> throws an error.</p>
<pre><code>λ&gt; test
*** Exception: Evaluation would not terminate</code></pre>
<p>The moral of this story is that it is really hard to correctly implement a call-by-value interpreter in Haskell. There is high chance of making a mistake. For example, let’s add a division operator to our interpreter.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">PrimOp</span> <span class="fu">=</span> <span class="dt">Add</span> <span class="fu">|</span> <span class="dt">Mul</span> <span class="fu">|</span> <span class="dt">Div</span>
  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="ot">evalPrim ::</span> <span class="dt">PrimOp</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>
evalPrim <span class="dt">Add</span> (<span class="dt">VInt</span> a) (<span class="dt">VInt</span> b) <span class="fu">=</span> <span class="dt">VInt</span> (a <span class="fu">+</span> b)
evalPrim <span class="dt">Mul</span> (<span class="dt">VInt</span> a) (<span class="dt">VInt</span> b) <span class="fu">=</span> <span class="dt">VInt</span> (a <span class="fu">*</span> b)
evalPrim <span class="dt">Div</span> (<span class="dt">VInt</span> a) (<span class="dt">VInt</span> b) <span class="fu">=</span> <span class="dt">VInt</span> (a <span class="ot">`div`</span> b)

<span class="co">-- (\x y -&gt; x) 10 (20 / 0)</span>
<span class="ot">test ::</span> <span class="dt">Value</span>
test <span class="fu">=</span> runIdentity <span class="fu">$</span> eval emptyEnv <span class="fu">$</span> <span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Lam</span> (<span class="dt">Lam</span> (<span class="dt">Var</span> <span class="dv">1</span>))) (<span class="dt">Lit</span> <span class="dv">10</span>)) (<span class="dt">Prim</span> <span class="dt">Div</span> (<span class="dt">Lit</span> <span class="dv">20</span>) (<span class="dt">Lit</span> <span class="dv">0</span>))</code></pre></div>
<p>Evaluating <code>test</code> must throw an divide-by-zero error because its second argument is <code>20 / 0</code>. But GHCi shows that we reverted back to cal-by-need.</p>
<pre><code>λ&gt; test
10</code></pre>
<p>This happens because the data constructor <code>VInt</code> is not strict. <code>20 / 0</code> is evaluated to <code>VInt undefined</code> instead of <code>undefined</code>. To make it call-by-value again, we need to add another bang pattern to <code>VInt</code> data constructor as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Value</span>
  <span class="fu">=</span> <span class="dt">VInt</span> <span class="fu">!</span><span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">VClosure</span> <span class="dt">Expr</span> <span class="dt">Env</span></code></pre></div>
<p>Fortunately, we can avoid this tricky business and make our first interpreter call-by-value by just adding <a href="https://ghc.haskell.org/trac/ghc/wiki/StrictPragma">Strict</a> language extension introduced in GHC 8. <code>Strict</code> pragma allows us to switch the default evaluation strategy to call-by-value on a per module basis. This saves us huge efforts because writing a call-by-value interpreter in a call-by-value language is an easy task!</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE Strict #-}</span></code></pre></div>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-05-implementing-a-call-by-value-interpreter-in-haskell.html";
    this.page.identifier = "/posts/2017-01-05-implementing-a-call-by-value-interpreter-in-haskell.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Type defaulting in Haskell</title>
    <link href="http://kseo.github.io//posts/2017-01-04-type-defaulting-in-haskell.html" />
    <id>http://kseo.github.io//posts/2017-01-04-type-defaulting-in-haskell.html</id>
    <published>2017-01-04T00:00:00Z</published>
    <updated>2017-01-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January  4, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/type%20defaulting.html">type defaulting</a>
      
  </div>

<p>Type defaulting is introduced to solve the ambiguous type problems caused by type classes.</p>
<p>Consider the following classic example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">show<span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>
read<span class="ot"> ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a

<span class="ot">f ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
f s <span class="fu">=</span> show (read s)</code></pre></div>
<p><code>f</code> appears to be well-typed, but GHC complains about the ambiguous type variable. The problem is that there is nothing to specify the type of the intermediate subexpression <code>(read s)</code>. <code>read</code> can parse an <code>Int</code>, a <code>String</code> or any other type that is an instance of <code>Read</code>. The compiler can’t arbitrarily choose a type because the choice of the type affects the program behavior. We can avoid the ambiguity by specifying the type explicitly:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
f s <span class="fu">=</span> show (read<span class="ot"> s ::</span> <span class="dt">Int</span>)</code></pre></div>
<p>However, the restriction above becomes quite cumbersome when we need to handle numeric types. For example,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">negate<span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a
show<span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>

(show (negate <span class="dv">4</span>))</code></pre></div>
<p>The expression <code>(show (negate 4))</code> is ambiguous because the literal <code>4</code> is of <code>Num a =&gt; a</code> type in Haskell. <code>4</code> can be an <code>Int</code>, a <code>Float</code> or any other type that is an instance of <code>Num</code>, so the compiler can’t choose any particular type for the same reason above. But the Haskell Committee thought that this is too much restriction. After much debates, they compromised and added an ad-hoc rule for choosing a particular default type. <a href="https://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf">A History of Haskell</a> mentions the rationale behind this decision:</p>
<blockquote>
<p>Performing numerical calculations on constants is one of the very first things a Haskell programmer does, and furthermore there is more reason to expect numeric operations to behave in similar ways for different types than there is for non-numeric operations.</p>
</blockquote>
<p>The default type of <code>Num</code> is <code>Integer</code>, so the Haskell compiler infers the type of <code>(negate 4)</code> as <code>Integer</code> instead of rejecting it as an invalid program.</p>
<p>Haskell default rule can be summarized as:</p>
<pre><code>default Num Integer
default Real Integer
default Enum Integer
default Integral Integer
default Fractional Double
default RealFrac Double
default Floating Double
default RealFloat Double</code></pre>
<p>The type defaulting rule is very conservative. Defaults are limited to Prelude numeric classes and cannot be applied to user-defined classes. Our first example <code>f</code> is invalid because <code>Read</code> is not a numeric type class. But, sometimes, we would like to change the default type for the type classes. So Haskell lets us specify a list of types in a special top-level <em>default</em> declaration.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">default (<span class="dt">Int</span>, <span class="dt">Float</span>)</code></pre></div>
<p>The restriction is still too tight. According to the rule, even innocuously looking <code>show []</code> is not typeable because GHC can’t decide the type of <code>[a]</code>. So compiling the following program causes an ambiguous type error.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class="fu">=</span> show []</code></pre></div>
<p>But every Haskell programmer knows that <code>show []</code> works fine in GHCi from experience. We don’t know the exact type chosen because the output is always <code>&quot;[]&quot;</code> regardless of the type. But it works anyway. What happened here?</p>
<pre><code>λ&gt; show []
&quot;[]&quot;</code></pre>
<p>In fact, GHCi extends Haskell’s type-defaulting rules by including <code>Show</code>, <code>Eq</code> and <code>Ord</code> in addition to numeric type classes. <a href="https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/interactive-evaluation.html">Type defaulting in GHCi</a> explains the details. It also adds the unit type <code>()</code> to the standard list of types which are tried when doing type defaulting. So the type of <code>[]</code> in <code>show []</code> becomes <code>[()]</code> according to the extended type defaulting rules in GHCi.</p>
<p>Type defaulting in Haskell is one of the controversial language features. It is confusing to novice Haskell programmers because the defaulting rule is very ad-hoc. Interested readers might want to take a look several enhancement <a href="https://prime.haskell.org/wiki/Defaulting">proposals</a> being discussed in Haskell Prime Wiki.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-04-type-defaulting-in-haskell.html";
    this.page.identifier = "/posts/2017-01-04-type-defaulting-in-haskell.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Writing an interpreter using fold</title>
    <link href="http://kseo.github.io//posts/2017-01-03-writing-an-interpreter-using-fold.html" />
    <id>http://kseo.github.io//posts/2017-01-03-writing-an-interpreter-using-fold.html</id>
    <published>2017-01-03T00:00:00Z</published>
    <updated>2017-01-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January  3, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/fold.html">fold</a>, <a href="/tags/interpreter.html">interpreter</a>, <a href="/tags/catamorphism.html">catamorphism</a>
      
  </div>

<p><em>fold</em> is a Swiss Army knife in functional programming. It is <a href="http://www.cs.nott.ac.uk/~pszgmh/fold.pdf">expressive</a> enough to write an interpreter for a simple functional programming language.</p>
<p>Let’s start with a simple arithmetic language.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">Const</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>           <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
<span class="ot">&gt;</span>           <span class="fu">|</span> <span class="dt">Mul</span> <span class="dt">Expr</span> <span class="dt">Expr</span></code></pre></div>
<p>Writing an interpreter for this language is trivial.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; interp ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> interp (<span class="dt">Const</span> x) <span class="fu">=</span> x
<span class="ot">&gt;</span> interp (<span class="dt">Add</span> e1 e2) <span class="fu">=</span> interp e1 <span class="fu">+</span> interp e2
<span class="ot">&gt;</span> interp (<span class="dt">Mul</span> e1 e2) <span class="fu">=</span> interp e1 <span class="fu">*</span> interp e2</code></pre></div>
<p>Writing a pretty printer is also easy.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; pretty ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
<span class="ot">&gt;</span> pretty (<span class="dt">Const</span> x) <span class="fu">=</span> show x
<span class="ot">&gt;</span> pretty (<span class="dt">Add</span> e1 e2) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> pretty e1 <span class="fu">++</span> <span class="st">&quot; + &quot;</span> <span class="fu">++</span> pretty e2 <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
<span class="ot">&gt;</span> pretty (<span class="dt">Mul</span> e1 e2) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> pretty e1 <span class="fu">++</span> <span class="st">&quot; * &quot;</span> <span class="fu">++</span> pretty e2 <span class="fu">++</span> <span class="st">&quot;)&quot;</span></code></pre></div>
<p>Sensitive readers might have noticed the duplication of code in <code>interp</code> and <code>pretty</code>. Yes, recursion on the structure of <code>Expr</code> is repeated.</p>
<p>We can extract recursion as <code>foldExpr</code> and algorithms as <code>ExprA</code>. <code>foldExpr</code> does recursion on the structure of <code>Expr</code> regardless of the algorithm being used.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">ExprA</span> a <span class="fu">=</span> <span class="dt">ExprA</span>
<span class="ot">&gt;</span>   {<span class="ot"> val ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span>   ,<span class="ot"> add ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span>   ,<span class="ot"> mul ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span>   }
<span class="ot">&gt;</span> 
<span class="ot">&gt; foldExpr ::</span> <span class="dt">ExprA</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> foldExpr alg (<span class="dt">Const</span> i)   <span class="fu">=</span> val alg i
<span class="ot">&gt;</span> foldExpr alg (<span class="dt">Add</span> e1 e2) <span class="fu">=</span> add alg (foldExpr alg e1) (foldExpr alg e2)
<span class="ot">&gt;</span> foldExpr alg (<span class="dt">Mul</span> e1 e2) <span class="fu">=</span> mul alg (foldExpr alg e1) (foldExpr alg e2)</code></pre></div>
<p>Now it is possible to define the interpreter just by giving <code>val</code>, <code>add</code> and <code>mul</code> functions.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; interpA ::</span> <span class="dt">ExprA</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> interpA <span class="fu">=</span> <span class="dt">ExprA</span>
<span class="ot">&gt;</span>   { val <span class="fu">=</span> id
<span class="ot">&gt;</span>   , add <span class="fu">=</span> (<span class="fu">+</span>)
<span class="ot">&gt;</span>   , mul <span class="fu">=</span> (<span class="fu">*</span>)
<span class="ot">&gt;</span>   }</code></pre></div>
<p>The same goes for pretty printer.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prettyA ::</span> <span class="dt">ExprA</span> <span class="dt">String</span>
<span class="ot">&gt;</span> prettyA <span class="fu">=</span> <span class="dt">ExprA</span>
<span class="ot">&gt;</span>   { val <span class="fu">=</span> show
<span class="ot">&gt;</span>   , add <span class="fu">=</span> \a b <span class="ot">-&gt;</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> a <span class="fu">++</span> <span class="st">&quot; + &quot;</span> <span class="fu">++</span> b <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
<span class="ot">&gt;</span>   , mul <span class="fu">=</span> \a b <span class="ot">-&gt;</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> a <span class="fu">++</span> <span class="st">&quot; * &quot;</span> <span class="fu">++</span> b <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
<span class="ot">&gt;</span>   }</code></pre></div>
<p>Here is our <code>interp'</code> function defined in terms of <code>foldExpr</code> and <code>interpA</code>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; interp&#39; ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> interp&#39; <span class="fu">=</span> foldExpr interpA</code></pre></div>
<p>We successfully isolated algorithms from recursion, but we are still not satisfied. <code>ExprA</code> is mostly duplication of <code>Expr</code> and defining <code>foldExpr</code> is boilerplate.</p>
<p>We can fix this by introducing <em>F-algebras</em> and <em>catamorphisms</em>. Interested readers might want to take a look at Bartosz Milewski’s <a href="https://bartoszmilewski.com/2013/06/10/understanding-f-algebras/">Understanding F-Algebras</a> article.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-03-writing-an-interpreter-using-fold.html";
    this.page.identifier = "/posts/2017-01-03-writing-an-interpreter-using-fold.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Hindley-Milner type inference with constraints</title>
    <link href="http://kseo.github.io//posts/2017-01-02-hindley-milner-inference-with-constraints.html" />
    <id>http://kseo.github.io//posts/2017-01-02-hindley-milner-inference-with-constraints.html</id>
    <published>2017-01-02T00:00:00Z</published>
    <updated>2017-01-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on January  2, 2017
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/type%20inference.html">type inference</a>, <a href="/tags/Hindley-Milner.html">Hindley-Milner</a>, <a href="/tags/constraints.html">constraints</a>
      
  </div>

<p>Algorithm W is the best known algorithm for implementing Hindley-Milner type inference. But it is a bit complicated as it intermingles two separate processes: constraint generation and solving.</p>
<p>There is an alternative approach based on <em>constraints generation</em>. In this approach, constraints are collected by bottom-up traversal, and then solved independently. Heeren’s <a href="http://soft.vub.ac.be/~cfscholl/Capita-Selecta-2015/papers/2002%20Heeren.pdf">Generalizing Hindley-Milner Type Inference Algorithms</a> paper describes the algorithm in details.</p>
<p>Here’s <a href="https://github.com/kseo/poly_constraints">my implementation</a> of Heeren’s algorithm. I forked Stephen Diehls’s <a href="https://github.com/sdiehl/write-you-a-haskell/tree/master/chapter7/poly_constraints">Poly</a> and modified <a href="https://github.com/kseo/poly_constraints/blob/master/src/Infer.hs">the type checker</a> to use the Heeren’s algorithm.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2017-01-02-hindley-milner-inference-with-constraints.html";
    this.page.identifier = "/posts/2017-01-02-hindley-milner-inference-with-constraints.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>
<entry>
    <title>Type inference algorithms of Haskell-like languages</title>
    <link href="http://kseo.github.io//posts/2016-12-31-type-inference-algorithms-of-haskell-like-languages.html" />
    <id>http://kseo.github.io//posts/2016-12-31-type-inference-algorithms-of-haskell-like-languages.html</id>
    <published>2016-12-31T00:00:00Z</published>
    <updated>2016-12-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<a class="twitter-share-button"
    href="https://twitter.com/intent/tweet?via=kwangyulseo">Tweet</a>

<article>
  <div class="info">
      Posted on December 31, 2016
      
          by Kwang Yul Seo
      
  </div>
  <div class="info">
      
      Tags: <a href="/tags/type%20inference.html">type inference</a>, <a href="/tags/type%20system.html">type system</a>, <a href="/tags/Haskell.html">Haskell</a>
      
  </div>

<p>I collected papers on the type inference algorithms used by Haskell-like languages.</p>
<h1 id="haskell">Haskell</h1>
<p>Haskell supports advanced type system features such as GADTs, type classes and type families. The current type checker implemented by GHC is described in <a href="https://www.microsoft.com/en-us/research/publication/outsideinx-modular-type-inference-with-local-assumptions/">OutsideIn(X): Modular type inference with local assumptions</a>.</p>
<h1 id="purescript">PureScript</h1>
<p>The type checker of PureScript is inspired by the following papers. It supports type classes, row polymorphism, higher kinded polymorphism (rank N types). There are no soundness proofs yet.</p>
<ul>
<li><a href="https://people.mpi-sws.org/~neelk/bidir.pdf">Complete and Easy Bidirectional Typechecking for Higher-Rank Polymorphism</a></li>
<li><a href="https://www.microsoft.com/en-us/research/publication/hmf-simple-type-inference-for-first-class-polymorphism/">HMF: Simple Type Inference for First-Class Polymorphism</a></li>
<li><a href="https://www.microsoft.com/en-us/research/publication/koka-programming-with-row-polymorphic-effect-types/">Koka: Programming with Row-polymorphic Effect Types</a></li>
</ul>
<h1 id="elm">Elm</h1>
<p>Elm’s type checker is an implementation of Pottier and Rem’s <a href="http://gallium.inria.fr/~fpottier/publis/emlti-final.pdf">The Essence of ML Type Inference</a> with two extensions:</p>
<ul>
<li>A limited set of built-in type classes (i.e. number, appendable, comparable)</li>
<li>Records based on <a href="https://www.microsoft.com/en-us/research/publication/extensible-records-with-scoped-labels/">Extensible records with scoped labels</a></li>
</ul>
<p>There is no support for type classes or higher kinded polymorphism yet.</p>
<div id="disqus_thread"></div>
<script>

/**
 *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
 *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
var disqus_config = function () {
    this.page.url = "https://kseo.github.io/posts/2016-12-31-type-inference-algorithms-of-haskell-like-languages.html";
    this.page.identifier = "/posts/2016-12-31-type-inference-algorithms-of-haskell-like-languages.html";
};
(function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = '//kwangs-haskell-blog.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

</article>
]]></summary>
</entry>

</feed>
