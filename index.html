<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="keywords" content="Haskell, functional programming, category theory, type theory">
        <title>Kwang's Haskell Blog - Home</title>
        <link rel="stylesheet" type="text/css" href="./css/default.css" />
        <link rel="stylesheet" type="text/css" href="./css/syntax.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="./">Kwang's Haskell Blog</a>
            </div>
            <div id="navigation">
                <a href="./">Home</a>
                <a href="./about.html">About</a>
                <a href="./contact.html">Contact</a>
                <a href="./archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <img src="./images/haskell-logo.png" style="float: right; margin: 10px;" />


<h4><a href="./posts/2017-01-25-write-your-own-stream-processing-library-part1.html">Write your own stream processing library Part1</a></h4> - January 25, 2017
<article>

    <p><a href="https://hackage.haskell.org/package/pipes">pipes</a> and <a href="https://hackage.haskell.org/package/conduit">conduit</a> are two competing libraries for handling stream data processing in Haskell. Though both libraries provide excellent tutorials on the usage of the libraries, the implementation details are impenetrable to most Haskell programmers.</p>
<p>The best way to understand how these streaming libraries work is to write a minimalistic version by ourselves. In this post, I will show you how we can write a small streaming data library with <em>coroutine</em>. Our implementation is based on Mario Blazevic’s excellent article <a href="https://themonadreader.files.wordpress.com/2011/10/issue19.pdf">Coroutine Pipelines</a>.</p>


</article>
<a href="./posts/2017-01-25-write-your-own-stream-processing-library-part1.html">Read more</a>

<h4><a href="./posts/2017-01-24-generating-the-docker-client-with-servant-client.html">Generating the Docker client with servant-client</a></h4> - January 24, 2017
<article>

    <p><a href="http://haskell-servant.readthedocs.io/en/stable/">Servant</a> provides a type-level DSL for declaring web APIs. Once we write the specification with the DSL, we can do various things including:</p>
<ul>
<li>Write servers (this part of servant can be considered a web framework),</li>
<li>Obtain client functions (in Haskell),</li>
<li>Generate client functions for other programming languages,</li>
<li>Generate documentation for your web applications</li>
</ul>
<p>The primary use case of Servant is to write servers, but we can use <a href="https://hackage.haskell.org/package/servant-client">servant-client</a> to generate client functions for the pre-existing web servers too! In this post, I will show you how we can generate client functions for the <a href="https://docs.docker.com/engine/api/">Docket remote API</a> automatically with servant-client.</p>


</article>
<a href="./posts/2017-01-24-generating-the-docker-client-with-servant-client.html">Read more</a>

<h4><a href="./posts/2017-01-23-custom-connection-manager-for-http-client.html">Custom connection manager for http-client</a></h4> - January 23, 2017
<article>

    <p><a href="https://www.stackage.org/haddock/lts-7.12/http-client-0.4.31.2/Network-HTTP-Client.html">http-client</a> provides the low-level API for HTTP client. In this post, I will explain how to create custom connection managers. If you want to know the basics of the library, read <a href="https://haskell-lang.org/library/http-client">Making HTTP requests</a> first.</p>


</article>
<a href="./posts/2017-01-23-custom-connection-manager-for-http-client.html">Read more</a>

<h4><a href="./posts/2017-01-21-writer-monad.html">Writer monad</a></h4> - January 21, 2017
<article>

    <p>The <em>Writer monad</em> represents computations which produce a stream of data in addition to the computed values. It is commonly used by code generators to emit code.</p>


</article>
<a href="./posts/2017-01-21-writer-monad.html">Read more</a>

<h4><a href="./posts/2017-01-20-how-servant%27s-type-safe-links-work.html">How Servant's type-safe links work</a></h4> - January 20, 2017
<article>

    <p>Many Haskell web frameworks provide so called <em>type-safe links</em>. Servant is no exception and it provides one of the strongest safety check. It statically guarantees that all links are valid endpoints of the server!</p>
<p>In servant, we can create a type-safe URI using <code>safeLink</code> function. It takes both <em>the whole API</em> and <em>the API endpoint</em> we would like to point to. It signals a type error if the endpoint does not belong to the whole api.</p>


</article>
<a href="./posts/2017-01-20-how-servant%27s-type-safe-links-work.html">Read more</a>



<p>…or you can find more in the <a href="./archive.html">archives</a>.</p>

        </div>
        <div id="footer">
            <a href="./rss.xml">RSS</a> |
            <a href="./atom.xml">ATOM</a> |
            <a href="https://twitter.com/kwangyulseo" class="twitter-follow-button" data-show-count="false">Follow @kwangyulseo</a><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
        </div>
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-61779656-7', 'auto');
          ga('send', 'pageview');
        </script>
    </body>
</html>
